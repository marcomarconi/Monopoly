df$Forecast <- (
strategy_weights$Trend * df$ForecastTrend +
strategy_weights$Carry * df$ForecastCarry +
strategy_weights$Skew  * df$ForecastSkew   ) * FDM
df$Forecast <- cap_forecast(df$Forecast)
df$InstCapital <- capital * df$Weight * IDM
df$Exposure <- df$InstCapital * target_vol/df$Volatility
df$PositionOptimal <-  (df$Exposure * df$FX * df$Forecast/10) /
(df$ContractSize * df$Close  )
df$PositionMax <- (df$Exposure * df$FX * 20/10) /
(df$ContractSize * df$Close  )
df$Buffer <- position_buffering_level * (df$Exposure * df$FX * 10/10) / (df$ContractSize * df$Close)
#all[[symbol]] <- df
# Be careful, now it is reverse-date sorted, you cannot run any other function like EMA etc..
df <- arrange(df, desc(Date))
#write_csv(df, paste0(logs_instruments_dir, "/", symbol, ".csv"))
results[[symbol]] <- df[1,]
}
symbol <- "cad"
df <- instruments_data[[symbol]][[1]]
hc <- instruments_data[[symbol]][[2]]
df$Symbol <- symbol
df$ForecastTrend <- df$ForecastCarry <- df$ForecastSkew <- df$Forecast <- df$PositionMax <- df$PositionOptimal <- df$PositionOptimized <- df$AdjFactor  <- df$RequiredTrade <- df$Buffer <- df$Trading <- df$PositionPrevious <- df$PositionUnrounded <- df$Position <- df$PositionRisk  <- 0
df$Return <- c(0, diff(log(df$Close)))
df$Return[df$Period=="Weekly"]  <- df$Return[df$Period=="Weekly"] * 4.84 # adjust weekly data to daily volatility (4.84=252/52). Not sure if correct and/or necessary
df$Volatility <- calculate_volatility(df$Return)
fx <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(FX)
if(fx == "EUR") {
df$FX <- 1
} else {
df$FX <- dplyr::filter(FX_rates, FX == fx) %>% pull(Rate)
}
df$Weight <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Weight)
df$Product <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Product)
df$ContractSize <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(ContractSize)
df$PositionMin <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(PositionMin)
df$PositionTick <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(PositionTick)
df$Decimals <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Decimals)
df$Spread <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Spread)
df$Commission <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Commission)
df$CostPerTrade <- (df$Spread / 2 + df$Commission)
# Relative volatility (strategy 13, it does not seems to add much)
{
# df$M <- 1
# df$RV <- relative_volatility(df$Volatility) # quite slow, you can replace it with df$Volatility / runMean(df$Volatility, 2520))
# df$RV <- df$Volatility / runMean(df$Volatility, 252)
# df$Q <- sapply(1:length(df$RV), function(i) sum(df$RV[i] > df$RV[1:i], na.rm=TRUE) / i)
# df$M <- EMA(2 - 1.5 * df$Q, 10)
}
# Trend-following (strategy 9)
df$ForecastTrend <- rowMeans(do.call(cbind, lapply(list(multiple_EMA, multiple_DC, multiple_KF, multiple_TII), function(f) f(df$Close, df$Close, df$Volatility))))
df$ForecastTrend <- cap_forecast(df$ForecastTrend * FDMtrend)
# Carry
# It is based on cash contract interest rate, we remove the 3% commission, so low volatility assets like
# bonds are not negatively affected in this analysis. Of course low volatility assets must be played on the future contract
# if you want to obtain the carry, as interest rates of the cash are always negative (because of the 3% commission that
# is higher than the volatility itself). For high volatility assets you can choose between cash or future.
hc_max <- which.max(hc)
df$Product[1]
# Carry
# It is based on cash contract interest rate, we remove the 3% commission, so low volatility assets like
# bonds are not negatively affected in this analysis. Of course low volatility assets must be played on the future contract
# if you want to obtain the carry, as interest rates of the cash are always negative (because of the 3% commission that
# is higher than the volatility itself). For high volatility assets you can choose between cash or future.
hc_max <- which.max(hc)
hc_commission <- case_when(
df$Product[1] == "Cash" ~ 0,
df$Product[1] == "Index" ~ 0.03,
df$Product[1] == "Future" ~ 0.03,
TRUE ~ NA_real_)
hc_commission
hc_value <- (hc[hc_max]+hc_commission)
if(hc_value < 0)
hc_value <- 0
hc_value
# previous_position : vector of the previous optimal positions. All zeroes if not provided.
# max_positions : vector of the max allowed positions (in absolute contracts), usually corresponding to a forecast of 20 (see above formula). Ignored if NULL
# min_positions : vector of the min allowed positions (in absolute contracts). If NULL, it is set to the minimum incremental step (1 contract for futures).
# costs_per_contract : vector of the costs to trade one contract, in price scale.
# trade_shadow_cost : a factor multiplier of the cost per contracts.
# fractional : TRUE is your broker allow fractional contracts, like for CFDs. The algorithm will use the decimal part of the positions as incremental step
#              in the greedy algorithm. If you are trading futures where all contracts are 1, just set it to FALSE.
# max_factor : maximum multiple of optimal position allowed (e.g. if optimal position == 2 and max_factor == 2, the optimized position will be <= 4).
#
# returned value: a vector of optimized positions according to the dynamic portfolio algorithm.
dynamic_portfolio <- function(capital, optimal_positions, notional_exposures, cov_matrix,
previous_position = NULL, min_positions=NULL, max_positions=NULL, costs_per_contract = NULL, trade_shadow_cost = 1, fractional=TRUE, max_factor=2) {
# Calculate the cost of making trades. trade_shadow_cost represents the number of expected trades in year
calculate_costs <- function(weights) {
trade_gap <- abs(weights_previous - weights)
trade_costs <- trade_shadow_cost * sum(trade_gap * costs_per_trade_in_weight)
return(trade_costs)
}
# Calculate the error of given weights from the optimal weights considering instruments correlations, plus optional costs
evaluate <- function(weights_optimal, weights, cov_matrix) {
solution_gap <- weights_optimal - weights
track_error <- as.numeric(sqrt(t(solution_gap) %*% cov_matrix %*% solution_gap))
trade_costs <- calculate_costs(weights)
return(track_error + trade_costs)
}
# The greedy algorithm (see https://qoppac.blogspot.com/2021/10/mr-greedy-and-tale-of-minimum-tracking.html)
find_possible_new_best <- function(weights_optimal, weights_max, weights_per_contract, direction, best_solution, best_value, cov_matrix, max_factor, buffer) {
new_best_value <- best_value
new_solution <- best_solution
count_assets <- length(best_solution)
for (i in sample(1:count_assets)) {
temp_step <- best_solution
if(temp_step[i] == 0) {
temp_step[i] <- temp_step[i] + weights_min[i] * direction[i]
} else {
temp_step[i] <- temp_step[i] + weights_per_contract[i] * fractional[i] * direction[i]
}
if(abs(temp_step[i]) > weights_max[i])
temp_step[i] <- weights_max[i] * sign(temp_step[i])
else if (abs(temp_step[i]) > max_factor * abs(weights_optimal[i]))
temp_step[i] <- max_factor * weights_optimal[i]
temp_objective_value <- evaluate(weights_optimal, temp_step, cov_matrix)
if (temp_objective_value < new_best_value) {
new_best_value <- temp_objective_value
new_solution <- temp_step
}
return(list(new_best_value, new_solution))
}
# Number os instruments
n <- nrow(cov_matrix)
# Set previous positions as zero if not specified
if (is.null(previous_position)) {
previous_position <- rep(0, n)
}
# Set trading costs to zero if not specified
if (is.null(costs_per_contract)) {
costs_per_contract <- rep(0, n)
}
# Find a fractional increments from positions (e.g. if position == 1.2 then the increment is 0.1)
if (!fractional) {
fractional <- rep(1, n)
} else {
fractional <-  10^(floor(log10(abs(optimal_positions)))-1)
}
weights_per_contract <- notional_exposures / capital
weights_optimal <- optimal_positions * weights_per_contract
weights_max <- if(!is.null(max_positions)) max_positions * weights_per_contract else rep(Inf, n)
weights_min <- if(!is.null(min_positions)) min_positions * weights_per_contract else weights_per_contract * fractional
weights_previous <- previous_position * weights_per_contract
costs_per_trade_in_weight <- (costs_per_contract  / capital) / weights_per_contract
best_solution <- previous_position#rep(0,n)
best_value <- evaluate(weights_optimal, best_solution, cov_matrix)
while (1) {
res <- find_possible_new_best(weights_optimal, weights_max, weights_per_contract, sign(weights_optimal), best_solution, best_value, cov_matrix, max_factor)
new_best_value <- res[[1]]
new_solution <- res[[2]]
if (new_best_value < best_value) {
best_value <- new_best_value
best_solution <- new_solution
} else {
break
}
return(best_solution / weights_per_contract)
}
# load instruments infos and calculate instruments weights from asset classes groups (could be coded a little better maybe?)
print("Loading symbols info and previous positions file...")
instruments_info <- read_csv(instrument_file, col_names = TRUE, show_col_types = FALSE) %>% arrange(Symbol)
instruments_info$Weight <- instruments_info %>% group_by(Symbol) %>%
summarise(Symbol=Symbol,
n0=length(unique(instruments_info$Class1)),
n1=length(unique(instruments_info$Class2[instruments_info$Class1==Class1])),
n2=length((instruments_info$Class2[instruments_info$Class2==Class2]))) %>%
ungroup %>% mutate(Weight=1/n0/n1/n2) %>% pull(Weight)
# load previous positions file
if(!file.exists(positions_file))
stop("Previous positions file does not exists.")
previous_trading <- read_csv(positions_file, col_names = TRUE, show_col_types = FALSE) %>% arrange(Symbol)
# scrape price and FX data
print("Scraping price and FX data...")
setwd(main_dir)
# load price data from previous scrape
print("Loading price data...")
instruments_data <- list()
for(symbol in instruments_info$Symbol) {
cat(paste(symbol, ""))
instruments_data[[symbol]] <- load_cmc_cash_data(symbol, scrape_dir)
nas <- sum(is.na(instruments_data[[symbol]]$Price$Close))
if(nas > 0) {
warning(paste(symbol, "price data has", nas, "NAs. They have been filled"))
instruments_data[[symbol]]$Price$Close <- na.locf(instruments_data[[symbol]]$Price$Close, na.rm=FALSE)
}
# load FX data from previous scrape
print("")
print("Loading FX data...")
FX_names <- read_csv(FX_file, col_names = FALSE, show_col_types = FALSE) %>% unlist
files <- list()
for(fx in FX_names) {
cat(paste(fx, ""))
f <- read_csv(paste0(FX_dir, "/", fx, ".csv"), col_names = TRUE, show_col_types = FALSE)
colnames(f) <- c("Date", "Rate")
if(nrow(f) > 1) {
files[[fx]] <- arrange(f, Date) %>% na.locf(na.rm=FALSE) %>% tail(2) %>% head(1) ### we take yesterday's rate, to match CMC data
}else{
files[[fx]] <- arrange(f, Date) %>% na.locf(na.rm=FALSE) %>% tail(1)
}
FX_rates <- do.call(rbind, files) %>% mutate(FX=toupper(sub("eur", "", FX_names)))
colnames(FX_rates) <- c("Date", "Rate", "FX")
# the covariance matrix
print("Calculate covariance matrix...")
closes <- lapply(instruments_data, function(x)x[[1]] %>% select(Date, Close))
closes_merged <- Reduce(function(...) full_join(..., by="Date"), closes) %>% arrange(Date)
colnames(closes_merged) <- c("Date", names(instruments_data))
daily_returns <- data.frame(Date=closes_merged$Date, apply(closes_merged[,-1], 2, function(x) c(0,diff(log(x)))))
weekly_returns <- mutate(daily_returns, Date=yearweek(Date)) %>% group_by(Date) %>% summarise(across(everything(), ~mean(.x,na.rm=TRUE)))
vols <- data.frame(Date=daily_returns$Date, apply(daily_returns[,-1], 2, function(x) calculate_volatility(x)))
#cor_matrix <- cor(tail(weekly_returns[,-1], corr_length), use="pairwise.complete.obs") # static last corr matrix
cor_matrix <- runCorMatrix(as.matrix(weekly_returns[,-1]))[[ncol(weekly_returns[,-1])]] # running corr matrix
last_day_vol <- tail(vols, 1)[-1]
cov_matrix <- diag(last_day_vol) %*% cor_matrix %*% diag(last_day_vol)
rownames(cov_matrix) <- colnames(cov_matrix) <- names(instruments_data)
# iterate over data and calculate positions
print("Calculate new positions...")
#all <- list()
results <- list()
for(symbol in names(instruments_data)) {
print(symbol)
df <- instruments_data[[symbol]][[1]]
hc <- instruments_data[[symbol]][[2]]
df$Symbol <- symbol
df$ForecastTrend <- df$ForecastCarry <- df$ForecastSkew <- df$Forecast <- df$PositionMax <- df$PositionOptimal <- df$PositionOptimized <- df$AdjFactor  <- df$RequiredTrade <- df$Buffer <- df$Trading <- df$PositionPrevious <- df$PositionUnrounded <- df$Position <- df$PositionRisk  <- 0
df$Return <- c(0, diff(log(df$Close)))
df$Return[df$Period=="Weekly"]  <- df$Return[df$Period=="Weekly"] * 4.84 # adjust weekly data to daily volatility (4.84=252/52). Not sure if correct and/or necessary
df$Volatility <- calculate_volatility(df$Return)
df$Period <- NULL
fx <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(FX)
if(fx == "EUR") {
df$FX <- 1
} else {
df$FX <- dplyr::filter(FX_rates, FX == fx) %>% pull(Rate)
}
df$Weight <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Weight)
df$Product <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Product)
df$ContractSize <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(ContractSize)
df$PositionMin <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(PositionMin)
df$PositionTick <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(PositionTick)
df$Decimals <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Decimals)
df$Spread <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Spread)
df$Commission <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Commission)
df$CostPerTrade <- (df$Spread / 2 + df$Commission)
# Relative volatility (strategy 13, it does not seems to add much)
{
# df$M <- 1
# df$RV <- relative_volatility(df$Volatility) # quite slow, you can replace it with df$Volatility / runMean(df$Volatility, 2520))
# df$RV <- df$Volatility / runMean(df$Volatility, 252)
# df$Q <- sapply(1:length(df$RV), function(i) sum(df$RV[i] > df$RV[1:i], na.rm=TRUE) / i)
# df$M <- EMA(2 - 1.5 * df$Q, 10)
}
# Trend-following (strategy 9)
df$ForecastTrend <- rowMeans(do.call(cbind, lapply(list(multiple_EMA, multiple_DC, multiple_KF, multiple_TII), function(f) f(df$Close, df$Close, df$Volatility))))
df$ForecastTrend <- cap_forecast(df$ForecastTrend * FDMtrend)
# Carry
# It is based on cash contract interest rate, we remove the 3% commission, so low volatility assets like
# bonds are not negatively affected in this analysis. Of course low volatility assets must be played on the future contract
# if you want to obtain the carry, as interest rates of the cash are always negative (because of the 3% commission that
# is higher than the volatility itself). For high volatility assets you can choose between cash or future.
hc_max <- which.max(hc)
hc_commission <- case_when(
df$Product[1] == "Cash" ~ 0,
df$Product[1] == "Index" ~ 0.03,
df$Product[1] == "Future" ~ 0.03,
TRUE ~ NA_real_)
hc_value <- (hc[hc_max]+hc_commission)
# When carry is always against us (both long and short charge us), we assume it is zero
if(hc_value < 0)
hc_value <- 0
df$ForecastCarry <- ifelse(hc_max == 1, 1, -1) * hc_value / df$Volatility * 10
df$ForecastCarry <- cap_forecast(df$ForecastCarry * FDMcarry)
# Skewness (strategy 24)
df$ForecastSkew <- returns_skew(df$Return)
df$ForecastSkew <- cap_forecast(df$ForecastSkew * FDMskew)
# Final trade
df$Forecast <- (
strategy_weights$Trend * df$ForecastTrend +
strategy_weights$Carry * df$ForecastCarry +
strategy_weights$Skew  * df$ForecastSkew   ) * FDM
df$Forecast <- cap_forecast(df$Forecast)
df$InstCapital <- capital * df$Weight * IDM
df$Exposure <- df$InstCapital * target_vol/df$Volatility
df$PositionOptimal <-  (df$Exposure * df$FX * df$Forecast/10) /
(df$ContractSize * df$Close  )
df$PositionMax <- (df$Exposure * df$FX * 20/10) /
(df$ContractSize * df$Close  )
df$Buffer <- position_buffering_level * (df$Exposure * df$FX * 10/10) / (df$ContractSize * df$Close)
#all[[symbol]] <- df
# Be careful, now it is reverse-date sorted, you cannot run any other function like EMA etc..
df <- arrange(df, desc(Date))
#write_csv(df, paste0(logs_instruments_dir, "/", symbol, ".csv"))
results[[symbol]] <- df[1,]
}
# Final table
today_trading <- do.call(rbind, results)
if(!all(previous_trading$Symbol %in% today_trading$Symbol)) {
missing_prev <- previous_trading$Symbol[!(previous_trading$Symbol %in% today_trading$Symbol)]
missing_today <- today_trading$Symbol[!(today_trading$Symbol %in% previous_trading$Symbol)]
stop(paste("Previous position symbols (POSITION file) and current symbols (INSTRUMENTS file) do not match. Missing in current: ", missing_prev, ", missing in previous: ", missing_today, "\nFix it manually."))
}
# Dynamic portfolio
optimal_positions <- with(today_trading, PositionOptimal)
max_positions <- with(today_trading, PositionMax)
min_positions <- with(today_trading, PositionMin)
notional_exposures <- with(today_trading, ContractSize * Close / FX)
costs_per_contract <- with(today_trading, ContractSize * (Spread/2) / FX)
previous_position <- previous_trading$Position
position_dynamic <- dynamic_portfolio(capital, optimal_positions, notional_exposures,  cov_matrix,
previous_position = previous_position, max_positions = max_positions, min_positions = min_positions,
costs_per_contract=costs_per_contract, trade_shadow_cost = trade_shadow_cost)
position_optimized <- round_position(position_dynamic, today_trading$PositionMin,  today_trading$PositionTick)
# Buffering
res <- buffering_portfolio(capital, position_optimized, previous_position, notional_exposures, cov_matrix, portfolio_buffering_level, target_vol)
required_trades <- res[[1]]
portfolio_tracking_error <- res[[2]]
adjustment_factor <- res[[3]]
print(paste("Portfolio tracking error:", round(portfolio_tracking_error, 3), "against buffer level", portfolio_buffering_level/2*target_vol, "adjustment factor:", round(adjustment_factor, 3)))
# Update final positions
today_trading$PositionPrevious <- previous_position
today_trading$PositionOptimized <- position_optimized
today_trading$AdjFactor <- adjustment_factor
# buffering is the minimal position change allowed, equal to 1 forecast
today_trading$Buffer <- with(today_trading, position_buffering_level * (Exposure * FX * 10/10) / (ContractSize * Close))
# if the previous position is 0 we override the required trade obtained from the buffering portfolio, and instead
# we trade straight to the optimized position. Otherwise some positions never take place (like when the minimum position is very high)
today_trading$RequiredTrade <- required_trades
today_trading$RequiredTrade <- with(today_trading, ifelse(abs(RequiredTrade) > 0 & PositionPrevious == 0, PositionOptimized, RequiredTrade))
# trade only if the required trade if bigger than buffer, bigger than position tick size and bigger than minumum position
today_trading$Trading <- with(today_trading, abs(RequiredTrade) > Buffer & abs(RequiredTrade) > PositionTick & abs(RequiredTrade) > PositionMin)
today_trading$PositionUnrounded <- with(today_trading,  ifelse(Trading, PositionPrevious +  RequiredTrade, PositionPrevious))
today_trading$Position <- with(today_trading,  round_position(PositionUnrounded, PositionMin, PositionTick))
today_trading$PositionRisk <- abs(with(today_trading, Position * ContractSize * (Close / FX) * Volatility)) %>% round(2)
# Portfolio volatility
w <- with(today_trading, Position * ContractSize * Close / FX / capital) %>% as.numeric
portfolio_volatility <- round(sqrt(w %*% cov_matrix %*% w) * 100, 2)
print(paste("Portfolio volatility:", portfolio_volatility, "%"))
# Portfolio jump risk
jump <- lapply(results, function(x) quantile(x$Volatility, probs=0.99)) %>% unlist
jump_cov_matrix <- diag(jump) %*% cor_matrix %*% diag(jump)
jump_risk <- round(sqrt(w %*% jump_cov_matrix %*% w) * 100, 2)
print(paste("Portfolio jump risk:", jump_risk, "%"))
# Portfolio correlation risk
risks <- lapply(1:length(results), function(i) w[i] * tail(results[[i]]$Volatility, 1)) %>% unlist
correlation_shock_portfolio <- round(sum(abs(risks)), 2) * 100
print(paste("Portfolio correlation risk:", correlation_shock_portfolio, "%"))
# Active positions
print(paste("Active positions:", sum(today_trading$Position != 0), "total symbols:", nrow(today_trading)))
print("Positions to update:")
trades <- today_trading %>% filter(Trading == TRUE) %>% select(Date, Close, Symbol, Position, PositionUnrounded, PositionPrevious, RequiredTrade, PositionOptimized, PositionOptimal, Forecast)
print(trades, n=nrow(trades))
1.079785e+01
4650.77
# previous_position : vector of the previous optimal positions. All zeroes if not provided.
# max_positions : vector of the max allowed positions (in absolute contracts), usually corresponding to a forecast of 20 (see above formula). Ignored if NULL
# min_positions : vector of the min allowed positions (in absolute contracts). If NULL, it is set to the minimum incremental step (1 contract for futures).
# costs_per_contract : vector of the costs to trade one contract, in price scale.
# trade_shadow_cost : a factor multiplier of the cost per contracts.
# fractional : TRUE is your broker allow fractional contracts, like for CFDs. The algorithm will use the decimal part of the positions as incremental step
#              in the greedy algorithm. If you are trading futures where all contracts are 1, just set it to FALSE.
# max_factor : maximum multiple of optimal position allowed (e.g. if optimal position == 2 and max_factor == 2, the optimized position will be <= 4).
#
# returned value: a vector of optimized positions according to the dynamic portfolio algorithm.
dynamic_portfolio <- function(capital, optimal_positions, notional_exposures, cov_matrix,
previous_position = NULL, min_positions=NULL, max_positions=NULL, costs_per_contract = NULL, trade_shadow_cost = 1, fractional=TRUE, max_factor=2) {
# Calculate the cost of making trades. trade_shadow_cost represents the number of expected trades in year
calculate_costs <- function(weights) {
trade_gap <- abs(weights_previous - weights)
trade_costs <- trade_shadow_cost * sum(trade_gap * costs_per_trade_in_weight)
return(trade_costs)
}
# Calculate the error of given weights from the optimal weights considering instruments correlations, plus optional costs
evaluate <- function(weights_optimal, weights, cov_matrix) {
solution_gap <- weights_optimal - weights
track_error <- as.numeric(sqrt(t(solution_gap) %*% cov_matrix %*% solution_gap))
trade_costs <- calculate_costs(weights)
return(track_error + trade_costs)
}
# The greedy algorithm (see https://qoppac.blogspot.com/2021/10/mr-greedy-and-tale-of-minimum-tracking.html)
find_possible_new_best <- function(weights_optimal, weights_max, weights_per_contract, direction, best_solution, best_value, cov_matrix, max_factor, buffer) {
new_best_value <- best_value
new_solution <- best_solution
count_assets <- length(best_solution)
for (i in sample(1:count_assets)) {
temp_step <- best_solution
if(temp_step[i] == 0) {
temp_step[i] <- temp_step[i] + weights_min[i] * direction[i]
} else {
temp_step[i] <- temp_step[i] + weights_per_contract[i] * fractional[i] * direction[i]
}
if(abs(temp_step[i]) > weights_max[i])
temp_step[i] <- weights_max[i] * sign(temp_step[i])
else if (abs(temp_step[i]) > max_factor * abs(weights_optimal[i]))
temp_step[i] <- max_factor * weights_optimal[i]
temp_objective_value <- evaluate(weights_optimal, temp_step, cov_matrix)
if (temp_objective_value < new_best_value) {
new_best_value <- temp_objective_value
new_solution <- temp_step
}
return(list(new_best_value, new_solution))
}
# Number os instruments
n <- nrow(cov_matrix)
# Set previous positions as zero if not specified
if (is.null(previous_position)) {
previous_position <- rep(0, n)
}
# Set trading costs to zero if not specified
if (is.null(costs_per_contract)) {
costs_per_contract <- rep(0, n)
}
# Find a fractional increments from positions (e.g. if position == 1.2 then the increment is 0.1)
if (!fractional) {
fractional <- rep(1, n)
} else {
fractional <-  10^(floor(log10(abs(optimal_positions)))-1)
}
weights_per_contract <- notional_exposures / capital
weights_optimal <- optimal_positions * weights_per_contract
weights_max <- if(!is.null(max_positions)) max_positions * weights_per_contract else rep(Inf, n)
weights_min <- if(!is.null(min_positions)) min_positions * weights_per_contract else weights_per_contract * fractional
weights_previous <- previous_position * weights_per_contract
costs_per_trade_in_weight <- (costs_per_contract  / capital) / weights_per_contract
best_solution <- weights_previous#rep(0,n)
best_value <- evaluate(weights_optimal, best_solution, cov_matrix)
while (1) {
res <- find_possible_new_best(weights_optimal, weights_max, weights_per_contract, sign(weights_optimal), best_solution, best_value, cov_matrix, max_factor)
new_best_value <- res[[1]]
new_solution <- res[[2]]
if (new_best_value < best_value) {
best_value <- new_best_value
best_solution <- new_solution
} else {
break
}
return(best_solution / weights_per_contract)
}
# Dynamic portfolio
optimal_positions <- with(today_trading, PositionOptimal)
max_positions <- with(today_trading, PositionMax)
min_positions <- with(today_trading, PositionMin)
notional_exposures <- with(today_trading, ContractSize * Close / FX)
costs_per_contract <- with(today_trading, ContractSize * (Spread/2) / FX)
previous_position <- previous_trading$Position
position_dynamic <- dynamic_portfolio(capital, optimal_positions, notional_exposures,  cov_matrix,
previous_position = previous_position, max_positions = max_positions, min_positions = min_positions,
costs_per_contract=costs_per_contract, trade_shadow_cost = trade_shadow_cost)
position_optimized <- round_position(position_dynamic, today_trading$PositionMin,  today_trading$PositionTick)
# Buffering
res <- buffering_portfolio(capital, position_optimized, previous_position, notional_exposures, cov_matrix, portfolio_buffering_level, target_vol)
required_trades <- res[[1]]
portfolio_tracking_error <- res[[2]]
adjustment_factor <- res[[3]]
print(paste("Portfolio tracking error:", round(portfolio_tracking_error, 3), "against buffer level", portfolio_buffering_level/2*target_vol, "adjustment factor:", round(adjustment_factor, 3)))
# Update final positions
today_trading$PositionPrevious <- previous_position
today_trading$PositionOptimized <- position_optimized
today_trading$AdjFactor <- adjustment_factor
# buffering is the minimal position change allowed, equal to 1 forecast
today_trading$Buffer <- with(today_trading, position_buffering_level * (Exposure * FX * 10/10) / (ContractSize * Close))
# if the previous position is 0 we override the required trade obtained from the buffering portfolio, and instead
# we trade straight to the optimized position. Otherwise some positions never take place (like when the minimum position is very high)
today_trading$RequiredTrade <- required_trades
today_trading$RequiredTrade <- with(today_trading, ifelse(abs(RequiredTrade) > 0 & PositionPrevious == 0, PositionOptimized, RequiredTrade))
# trade only if the required trade if bigger than buffer, bigger than position tick size and bigger than minumum position
today_trading$Trading <- with(today_trading, abs(RequiredTrade) > Buffer & abs(RequiredTrade) > PositionTick & abs(RequiredTrade) > PositionMin)
today_trading$PositionUnrounded <- with(today_trading,  ifelse(Trading, PositionPrevious +  RequiredTrade, PositionPrevious))
today_trading$Position <- with(today_trading,  round_position(PositionUnrounded, PositionMin, PositionTick))
today_trading$PositionRisk <- abs(with(today_trading, Position * ContractSize * (Close / FX) * Volatility)) %>% round(2)
# Portfolio volatility
w <- with(today_trading, Position * ContractSize * Close / FX / capital) %>% as.numeric
portfolio_volatility <- round(sqrt(w %*% cov_matrix %*% w) * 100, 2)
print(paste("Portfolio volatility:", portfolio_volatility, "%"))
# Portfolio jump risk
jump <- lapply(results, function(x) quantile(x$Volatility, probs=0.99)) %>% unlist
jump_cov_matrix <- diag(jump) %*% cor_matrix %*% diag(jump)
jump_risk <- round(sqrt(w %*% jump_cov_matrix %*% w) * 100, 2)
print(paste("Portfolio jump risk:", jump_risk, "%"))
# Portfolio correlation risk
risks <- lapply(1:length(results), function(i) w[i] * tail(results[[i]]$Volatility, 1)) %>% unlist
correlation_shock_portfolio <- round(sum(abs(risks)), 2) * 100
print(paste("Portfolio correlation risk:", correlation_shock_portfolio, "%"))
# Active positions
print(paste("Active positions:", sum(today_trading$Position != 0), "total symbols:", nrow(today_trading)))
print("Positions to update:")
trades <- today_trading %>% filter(Trading == TRUE) %>% select(Date, Close, Symbol, Position, PositionUnrounded, PositionPrevious, RequiredTrade, PositionOptimized, PositionOptimal, Forecast)
print(trades, n=nrow(trades))
4.294768e+02
983.00
1.674155e+00
cov_matrix %>% corrplot::corrplot(order="hclust")
cor_matrix %>% corrplot::corrplot(order="hclust")
cor_matrix %>% abs %>% corrplot::corrplot(order="hclust")
cor_matrix %>% abs -> a
a[a==1] <- NA
rowMeans(a, na.rm=T)
rowMeans(a, na.rm=T) %>% sort
cor_matrix <- cor((weekly_returns[,-1], use="pairwise.complete.obs")
cor_matrix <- cor(weekly_returns[,-1], use="pairwise.complete.obs")
cor_matrix %>% abs -> a
a[a==1] <- NA
rowMeans(a, na.rm=T) %>% sort
cor_matrix %>% abs %>% corrplot::corrplot(order="hclust")
rowMeans(a, na.rm=T) %>% sort %>% plot
cor_matrix %>%  corrplot::corrplot(order="hclust")
a[a==1] <- NA
rowMeans(a, na.rm=T) %>% sort %>% plot
rowMeans(a, na.rm=T) %>% sort
cor_matrix  -> a
a[a==1] <- NA
rowMeans(a, na.rm=T) %>% sort
rowMeans(a, na.rm=T) %>% sort %>% plot
