}
# in case we have reached the end of the current contract we add the previous as nearest
# while(is.nan(curr) | is.na(curr)) {
#   j <- j - 1
#   i <- i - 1
#   if(j == 0)
#     break
#   curr <- m[i,j]
# }
nearest[i] <- curr
i <- i + 1
if(j == ncol(m)+1)
break
}
adjs <- lead(adjs)
continous <- nearest + adjs
return(data.frame(Date=df[,1], Nearest=nearest, Continous=continous, Adjs=adjs))
}
cbind(h,backadjust_future(h, 1))
# create a single future contract
backadjust_future <- function(df, N=1) {
m <- as.matrix(df[,-1]) # the first column is supposed to be the Date
nearest <- rep(NA, nrow(m))
continous <- rep(NA, nrow(m))
adjs <- rep(0, nrow(m))
jump <- 0
j <- 1;
i <- 1;
# number of days from the end of the previous contract
cc <- 0
while(i <= nrow(m)) {
# take note of the current adjustment between the current contract and the previous one
if(j < ncol(m)) {
n_jump <- m[i,j] - m[i,j+1]
if(!is.na(n_jump))
jump <- n_jump
}
curr <- m[i,j]
if(j < ncol(m))
prev <- m[i,j+1]
down <- m[i+1,j]
if(i>1)
adjs[i] <- adjs[i-1] # keep the previous adjustment
# if cc > 0 we have already found the end of the previous contract (see below)
if(cc > 0)
cc <- cc + 1
# we found the end of the previous contract, start the counter
if(j > 1 && cc == 0 &&  (is.nan(prev)))
cc <- 1
# rollback contract if:
# - we have reached the number of days from the end of previous contract
# - we have reached the start of the current contract
if(cc == (N+1) | is.nan(down) | is.na(down)) {
cc <- 0
j <- j + 1
adjs[i] <- adjs[i] + jump # update the adjustment now that we rollback the contract
#print(paste(i, j, up))
}
# in case we have reached the end of the current contract we add the previous as nearest
# while(is.nan(curr) | is.na(curr)) {
#   j <- j - 1
#   i <- i - 1
#   if(j == 0)
#     break
#   curr <- m[i,j]
# }
nearest[i] <- curr
i <- i + 1
if(j == ncol(m)+1)
break
}
adjs <- lead(adjs)
continous <- nearest + adjs
return(data.frame(Date=df[,1], Nearest=nearest, Continous=continous, Adjs=adjs))
}
cbind(h,backadjust_future(h, 1))
# create a single future contract
backadjust_future <- function(df, N=1) {
m <- as.matrix(df[,-1]) # the first column is supposed to be the Date
nearest <- rep(NA, nrow(m))
continous <- rep(NA, nrow(m))
adjs <- rep(0, nrow(m))
jump <- 0
j <- 1;
i <- 1;
# number of days from the end of the previous contract
cc <- 0
while(i <= nrow(m)) {
# take note of the current adjustment between the current contract and the previous one
if(j < ncol(m)) {
n_jump <-  m[i,j+1] - m[i,j]
if(!is.na(n_jump))
jump <- n_jump
}
curr <- m[i,j]
if(j < ncol(m))
prev <- m[i,j+1]
down <- m[i+1,j]
if(i>1)
adjs[i] <- adjs[i-1] # keep the previous adjustment
# if cc > 0 we have already found the end of the previous contract (see below)
if(cc > 0)
cc <- cc + 1
# we found the end of the previous contract, start the counter
if(j > 1 && cc == 0 &&  (is.nan(prev)))
cc <- 1
# rollback contract if:
# - we have reached the number of days from the end of previous contract
# - we have reached the start of the current contract
if(cc == (N+1) | is.nan(down) | is.na(down)) {
cc <- 0
j <- j + 1
adjs[i] <- adjs[i] + jump # update the adjustment now that we rollback the contract
#print(paste(i, j, up))
}
# in case we have reached the end of the current contract we add the previous as nearest
# while(is.nan(curr) | is.na(curr)) {
#   j <- j - 1
#   i <- i - 1
#   if(j == 0)
#     break
#   curr <- m[i,j]
# }
nearest[i] <- curr
i <- i + 1
if(j == ncol(m)+1)
break
}
adjs <- lead(adjs)
continous <- nearest + adjs
return(data.frame(Date=df[,1], Nearest=nearest, Continous=continous, Adjs=adjs))
}
cbind(h,backadjust_future(h, 1))
# create a single future contract
backadjust_future <- function(df, N=1) {
m <- as.matrix(df[,-1]) # the first column is supposed to be the Date
nearest <- rep(NA, nrow(m))
continous <- rep(NA, nrow(m))
adjs <- rep(0, nrow(m))
jump <- 0
j <- 1;
i <- 1;
# number of days from the end of the previous contract
cc <- 0
while(i <= nrow(m)) {
# take note of the current adjustment between the current contract and the previous one
if(j < ncol(m)) {
n_jump <-  m[i,j+1] - m[i,j]
if(!is.na(n_jump))
jump <- n_jump
}
curr <- m[i,j]
if(j < ncol(m))
prev <- m[i,j+1]
down <- m[i+1,j]
if(i>1)
adjs[i] <- adjs[i-1] # keep the previous adjustment
# if cc > 0 we have already found the end of the previous contract (see below)
if(cc > 0)
cc <- cc + 1
# we found the end of the previous contract, start the counter
if(j > 1 && cc == 0 &&  (is.nan(prev)))
cc <- 1
# rollback contract if:
# - we have reached the number of days from the end of previous contract
# - we have reached the start of the current contract
if(cc == (N+1) | is.nan(down) | is.na(down)) {
cc <- 0
j <- j + 1
adjs[i] <- adjs[i] + jump # update the adjustment now that we rollback the contract
#print(paste(i, j, up))
}
# in case we have reached the end of the current contract we add the previous as nearest
# while(is.nan(curr) | is.na(curr)) {
#   j <- j - 1
#   i <- i - 1
#   if(j == 0)
#     break
#   curr <- m[i,j]
# }
nearest[i] <- curr
i <- i + 1
if(j == ncol(m)+1)
break
}
adjs <- (adjs)
continous <- nearest + adjs
return(data.frame(Date=df[,1], Nearest=nearest, Continous=continous, Adjs=adjs))
}
cbind(h,backadjust_future(h, 1))
# create a single future contract
backadjust_future <- function(df, N=1) {
m <- as.matrix(df[,-1]) # the first column is supposed to be the Date
nearest <- rep(NA, nrow(m))
continous <- rep(NA, nrow(m))
adjs <- rep(0, nrow(m))
jump <- 0
j <- 1;
i <- 1;
# number of days from the end of the previous contract
cc <- 0
while(i <= nrow(m)) {
# take note of the current adjustment between the current contract and the previous one
if(j < ncol(m)) {
n_jump <-  m[i,j+1] - m[i,j]
if(!is.na(n_jump))
jump <- n_jump
}
curr <- m[i,j]
if(j < ncol(m))
prev <- m[i,j+1]
down <- m[i+1,j]
if(i>1)
adjs[i] <- adjs[i-1] # keep the previous adjustment
# if cc > 0 we have already found the end of the previous contract (see below)
if(cc > 0)
cc <- cc + 1
# we found the end of the previous contract, start the counter
# if(j > 1 && cc == 0 &&  (is.nan(prev)))
#   cc <- 1
# rollback contract if:
# - we have reached the number of days from the end of previous contract
# - we have reached the start of the current contract
if(cc == (N+1) | is.nan(down) | is.na(down)) {
cc <- 0
j <- j + 1
adjs[i] <- adjs[i] + jump # update the adjustment now that we rollback the contract
#print(paste(i, j, up))
}
# in case we have reached the end of the current contract we add the previous as nearest
# while(is.nan(curr) | is.na(curr)) {
#   j <- j - 1
#   i <- i - 1
#   if(j == 0)
#     break
#   curr <- m[i,j]
# }
nearest[i] <- curr
i <- i + 1
if(j == ncol(m)+1)
break
}
adjs <- (adjs)
continous <- nearest + adjs
return(data.frame(Date=df[,1], Nearest=nearest, Continous=continous, Adjs=adjs))
}
cbind(h,backadjust_future(h, 1))
a <- a$Adjs
a <- cbind(h,backadjust_future(h, 1))
a <- a$Adjs
a
a[10] <- 0.8
a
diff(a)
diff(a) %>% cumsum
diff(a) %>% rev %>% cumsum
(a) %>% rev %>% cumsum
(a) %>% cumsum
a <- backadjust_future(Futures[["RB"]],  N=1)
# create a single future contract
backadjust_future <- function(df, N=1) {
m <- as.matrix(df[,-1]) # the first column is supposed to be the Date
nearest <- rep(NA, nrow(m))
continous <- rep(NA, nrow(m))
adjs <- rep(0, nrow(m))
jump <- 0
j <- 1;
i <- 1;
# number of days from the end of the previous contract
cc <- 0
while(i < nrow(m)) {
# take note of the current adjustment between the current contract and the previous one
if(j < ncol(m)) {
n_jump <-  m[i,j+1] - m[i,j]
if(!is.na(n_jump))
jump <- n_jump
}
curr <- m[i,j]
if(j < ncol(m))
prev <- m[i,j+1]
down <- m[i+1,j]
if(i>1)
adjs[i] <- adjs[i-1] # keep the previous adjustment
# if cc > 0 we have already found the end of the previous contract (see below)
if(cc > 0)
cc <- cc + 1
# we found the end of the previous contract, start the counter
# if(j > 1 && cc == 0 &&  (is.nan(prev)))
#   cc <- 1
# rollback contract if:
# - we have reached the number of days from the end of previous contract
# - we have reached the start of the current contract
if(cc == (N+1) | is.nan(down) | is.na(down)) {
cc <- 0
j <- j + 1
adjs[i] <- adjs[i] + jump # update the adjustment now that we rollback the contract
#print(paste(i, j, up))
}
# in case we have reached the end of the current contract we add the previous as nearest
# while(is.nan(curr) | is.na(curr)) {
#   j <- j - 1
#   i <- i - 1
#   if(j == 0)
#     break
#   curr <- m[i,j]
# }
nearest[i] <- curr
i <- i + 1
if(j == ncol(m)+1)
break
}
adjs <- (adjs)
continous <- nearest + adjs
return(data.frame(Date=df[,1], Nearest=nearest, Continous=continous, Adjs=adjs))
}
a <- backadjust_future(Futures[["RB"]],  N=1)
plot(a$Continous)
plot(a$Nearest)
cbind(h,backadjust_future(h, 1))
a <- cbind(h,backadjust_future(h, 1))
rev(a$Adjs)
rev(a$Adjs) %>% diff
rev(a$Adjs) %>% diff %>% cumsum
diff(a$Adjs)
# create a single future contract
backadjust_future <- function(df, N=1) {
m <- as.matrix(df[,-1]) # the first column is supposed to be the Date
nearest <- rep(NA, nrow(m))
continous <- rep(NA, nrow(m))
adjs <- rep(0, nrow(m))
jump <- 0
j <- 1;
i <- 1;
# number of days from the end of the previous contract
cc <- 0
while(i < nrow(m)) {
# take note of the current adjustment between the current contract and the previous one
if(j < ncol(m)) {
n_jump <-  m[i,j+1] - m[i,j]
if(!is.na(n_jump))
jump <- n_jump
}
curr <- m[i,j]
if(j < ncol(m))
prev <- m[i,j+1]
down <- m[i+1,j]
if(i>1)
adjs[i] <- adjs[i-1] # keep the previous adjustment
# if cc > 0 we have already found the end of the previous contract (see below)
if(cc > 0)
cc <- cc + 1
# we found the end of the previous contract, start the counter
# if(j > 1 && cc == 0 &&  (is.nan(prev)))
#   cc <- 1
# rollback contract if:
# - we have reached the number of days from the end of previous contract
# - we have reached the start of the current contract
if(cc == (N+1) | is.nan(down) | is.na(down) & i < nrow(m) - 1) {
cc <- 0
j <- j + 1
adjs[i] <- adjs[i] + jump # update the adjustment now that we rollback the contract
#print(paste(i, j, up))
}
# in case we have reached the end of the current contract we add the previous as nearest
# while(is.nan(curr) | is.na(curr)) {
#   j <- j - 1
#   i <- i - 1
#   if(j == 0)
#     break
#   curr <- m[i,j]
# }
nearest[i] <- curr
i <- i + 1
if(j == ncol(m)+1)
break
}
adjs <- (adjs)
continous <- nearest + adjs
return(data.frame(Date=df[,1], Nearest=nearest, Continous=continous, Adjs=adjs))
}
a <- cbind(h,backadjust_future(h, 1))
a
# create a single future contract
backadjust_future <- function(df, N=1) {
m <- as.matrix(df[,-1]) # the first column is supposed to be the Date
nearest <- rep(NA, nrow(m))
continous <- rep(NA, nrow(m))
adjs <- rep(0, nrow(m))
jump <- 0
j <- 1;
i <- 1;
# number of days from the end of the previous contract
cc <- 0
while(i < nrow(m)) {
# take note of the current adjustment between the current contract and the previous one
if(j < ncol(m)) {
n_jump <-  m[i,j+1] - m[i,j]
if(!is.na(n_jump))
jump <- n_jump
}
curr <- m[i,j]
if(j < ncol(m))
prev <- m[i,j+1]
down <- m[i+1,j]
if(i>1)
adjs[i] <- adjs[i-1] # keep the previous adjustment
# if cc > 0 we have already found the end of the previous contract (see below)
if(cc > 0)
cc <- cc + 1
# we found the end of the previous contract, start the counter
# if(j > 1 && cc == 0 &&  (is.nan(prev)))
#   cc <- 1
# rollback contract if:
# - we have reached the number of days from the end of previous contract
# - we have reached the start of the current contract
if(cc == (N+1) | is.nan(down) | is.na(down) & i < nrow(m) - 2) {
cc <- 0
j <- j + 1
adjs[i] <- adjs[i] + jump # update the adjustment now that we rollback the contract
#print(paste(i, j, up))
}
# in case we have reached the end of the current contract we add the previous as nearest
# while(is.nan(curr) | is.na(curr)) {
#   j <- j - 1
#   i <- i - 1
#   if(j == 0)
#     break
#   curr <- m[i,j]
# }
nearest[i] <- curr
i <- i + 1
if(j == ncol(m)+1)
break
}
adjs <- (adjs)
continous <- nearest + adjs
return(data.frame(Date=df[,1], Nearest=nearest, Continous=continous, Adjs=adjs))
}
a <- cbind(h,backadjust_future(h, 1))
a
# create a single future contract
backadjust_future <- function(df, N=1) {
m <- as.matrix(df[,-1]) # the first column is supposed to be the Date
nearest <- rep(NA, nrow(m))
continous <- rep(NA, nrow(m))
adjs <- rep(0, nrow(m))
jump <- 0
j <- 1;
i <- 1;
# number of days from the end of the previous contract
cc <- 0
while(i < nrow(m)) {
# take note of the current adjustment between the current contract and the previous one
if(j < ncol(m)) {
n_jump <-  m[i,j+1] - m[i,j]
if(!is.na(n_jump))
jump <- n_jump
}
curr <- m[i,j]
if(j < ncol(m))
prev <- m[i,j+1]
down <- m[i+1,j]
if(i>1)
adjs[i] <- adjs[i-1] # keep the previous adjustment
# if cc > 0 we have already found the end of the previous contract (see below)
if(cc > 0)
cc <- cc + 1
# we found the end of the previous contract, start the counter
# if(j > 1 && cc == 0 &&  (is.nan(prev)))
#   cc <- 1
# rollback contract if:
# - we have reached the number of days from the end of previous contract
# - we have reached the start of the current contract
if((cc == (N+1) | is.nan(down) | is.na(down)) & i < nrow(m) - 1) {
cc <- 0
j <- j + 1
adjs[i] <- adjs[i] + jump # update the adjustment now that we rollback the contract
#print(paste(i, j, up))
}
# in case we have reached the end of the current contract we add the previous as nearest
# while(is.nan(curr) | is.na(curr)) {
#   j <- j - 1
#   i <- i - 1
#   if(j == 0)
#     break
#   curr <- m[i,j]
# }
nearest[i] <- curr
i <- i + 1
if(j == ncol(m)+1)
break
}
adjs <- (adjs)
continous <- nearest + adjs
return(data.frame(Date=df[,1], Nearest=nearest, Continous=continous, Adjs=adjs))
}
a <- cbind(h,backadjust_future(h, 1))
a
diff(a$Adjs)
diff(a$Adjs %>% head(-1))
diff(a$Adjs %>% head(-1)) %>% cumsum
diff(a$Adjs %>% head(-1)) %>% rev %>% cumsum
diff(a$Adjs %>% head(-1)) %>% rev %>% cumsum %>% rev
diff(a$Adjs %>% head(-1)) %>% rev %>% cumsum %>% rev -> b
a$Nearest + b
a$Nearest + c(b,0)
length(a$Nearest)
length(b)
a$Nearest + c(0,b,0)
diff(a$Adjs) %>% rev %>% cumsum %>% rev
diff(a$Adjs %>% head(-1)) %>% rev %>% cumsum %>% rev
a
