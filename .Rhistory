df$ForecastCarry <- ifelse(hc_max == 1, 1, -1) * hc_value / df$Volatility * 10
df$ForecastCarry <- cap_forecast(df$ForecastCarry * FDMcarry)
# Skewness (strategy 24)
df$ForecastSkew <- returns_skew(df$Return)
df$ForecastSkew <- cap_forecast(df$ForecastSkew * FDMskew)
# Final trade
df$Forecast <- (
strategy_weights$Trend * df$ForecastTrend +
strategy_weights$Carry * df$ForecastCarry +
strategy_weights$Skew  * df$ForecastSkew   )
df$Forecast <- cap_forecast(df$Forecast)
df$InstCapital <- capital * df$Weight * IDM
df$Exposure <- df$InstCapital * target_vol/df$Volatility
df$PositionRaw <-  (df$Exposure * df$FX * df$Forecast/10) /
(df$ContractSize * df$Close  )
df$PositionMax <- (df$Exposure * df$FX * 2) /
(df$ContractSize * df$Close  )
{
# df$Buffer <-  df$Exposure * buffering /
#   (df$ContractSize * df$Close)
# df$BufferUp <- df$Position + df$Buffer
# df$BufferLow <- df$Position - df$Buffer
# A little simulation of position buffering, it can be removed
# df$PositionSim <- NA
# df$PositionSim[1] <- 0
# for(i in 2:nrow(df)) {
#   df$PositionSim[i] <- df$PositionSim[i-1]
#   if(is.na(df$BufferUp[i]) | is.na(df$Position[i]))
#     next
#   if(df$PositionSim[i-1] > df$BufferUp[i] | df$PositionSim[i-1] < df$BufferLow[i])
#     df$PositionSim[i] <- df$Position[i]
# }
}
# Be careful, now it is reverse-date sorted, you cannot run any other function like EMA etc..
df <- arrange(df, desc(Date))
#write_csv(df, paste0(instruments_logs, "/", symbol, ".csv"))
results[[symbol]] <- df[1,]
}
# Final table
today_trading <- do.call(rbind, results)
if(!all(previous_trading$Symbol %in% today_trading$Symbol)) {
missing_prev <- previous_trading$Symbol[!(previous_trading$Symbol %in% today_trading$Symbol)]
missing_today <- today_trading$Symbol[!(today_trading$Symbol %in% previous_trading$Symbol)]
stop(paste("Previous position symbols (POSITION file) and current symbols (INSTRUMENTS file) do not match. Missing in current: ", missing_prev, ", missing in previous: ", missing_today, "\nFix it manually."))
}
# Dynamic portfolio
optimal_positions <- with(today_trading, PositionRaw)
# load previous positions file
previous_trading <- read_csv(positions_file, col_names = TRUE, show_col_types = FALSE) %>% arrange(Symbol)
# Dynamic portfolio
optimal_positions <- with(today_trading, PositionRaw)
max_positions <- with(today_trading, PositionMax)
notional_exposures <- with(today_trading, ContractSize * Close / FX)
costs_per_contract <- with(today_trading, ContractSize * (Spread/2) / FX)
# Final table
today_trading <- do.call(rbind, results)
if(!all(previous_trading$Symbol %in% today_trading$Symbol)) {
missing_prev <- previous_trading$Symbol[!(previous_trading$Symbol %in% today_trading$Symbol)]
missing_today <- today_trading$Symbol[!(today_trading$Symbol %in% previous_trading$Symbol)]
stop(paste("Previous position symbols (POSITION file) and current symbols (INSTRUMENTS file) do not match. Missing in current: ", missing_prev, ", missing in previous: ", missing_today, "\nFix it manually."))
}
# Dynamic portfolio
optimal_positions <- with(today_trading, PositionRaw)
max_positions <- with(today_trading, PositionMax)
notional_exposures <- with(today_trading, ContractSize * Close / FX)
costs_per_contract <- with(today_trading, ContractSize * (Spread/2) / FX)
previous_position <- previous_trading$Position
position_dynamic <- dynamic_portfolio(capital, optimal_positions, max_positions, notional_exposures,  cov_matrix,
previous_position = previous_position,
costs_per_contract=costs_per_contract, trade_shadow_cost = trade_shadow_cost)
position_final <- round_position(position_dynamic, today_trading$MinPosition,  today_trading$Decimals)
# Buffering
res <- buffering_portfolio(capital, position_final, previous_position, notional_exposures, cov_matrix, buffering_level, target_vol)
required_trades <- res[[1]]
portfolio_tracking_error <- res[[2]]
print(paste("Portfolio tracking error:", round(portfolio_tracking_error, 3), "against buffer level", buffering_level/2*target_vol))
portfolio_update_requred <- ifelse(all(required_trades == 0), FALSE, TRUE)
if(portfolio_update_requred) {
print("Portfolio update requited, check 'RequitedTrade' column in the positions file.")
} else {
print("No portfolio update requited.")
}
# Final positions trading file
today_trading$PositionPrevious <- previous_position
today_trading$PositionDynamic <- position_dynamic
today_trading$Position <- position_final
today_trading$PositionRisk <- abs(with(today_trading, Position * ContractSize * (Close / FX) * Volatility))
today_trading$RequiredTrade <- required_trades
sum(today_trading$Weight)
instruments_info <- read_csv(instrument_file, col_names = TRUE, show_col_types = FALSE) %>% arrange(Symbol)
instruments_info$Weight <- instruments_info %>% group_by(Symbol) %>%
summarise(Symbol=Symbol,
n0=length(unique(instruments_info$Class1)),
n1=length(unique(instruments_info$Class2[instruments_info$Class1==Class1])) ,
n2=length((instruments_info$Class2[instruments_info$Class2==Class2]))) %>%
ungroup %>% mutate(Weight=1/n0/n1/n2) %>% pull(Weight)
instruments_info <- read_csv(instrument_file, col_names = TRUE, show_col_types = FALSE) %>% arrange(Symbol)
instruments_info$Weight <- instruments_info %>% group_by(Symbol) %>%
summarise(Symbol=Symbol,
n0=length(unique(instruments_info$Class1)),
n1=length(unique(instruments_info$Class2[instruments_info$Class1==Class1])) ,
n2=length((instruments_info$Class2[instruments_info$Class2==Class2]))) %>%
ungroup %>% mutate(Weight=1/n0/n1/n2) %>% pull(Weight)
# load previous positions file
previous_trading <- read_csv(positions_file, col_names = TRUE, show_col_types = FALSE) %>% arrange(Symbol)
instruments_info <- read_csv(instrument_file, col_names = TRUE, show_col_types = FALSE) %>% arrange(Symbol)
instruments_info$Weight <- instruments_info %>% group_by(Symbol) %>%
summarise(Symbol=Symbol,
n0=length(unique(instruments_info$Class1)),
n1=length(unique(instruments_info$Class2[instruments_info$Class1==Class1])) ,
n2=length((instruments_info$Class2[instruments_info$Class2==Class2]))) %>%
ungroup %>% mutate(Weight=1/n0/n1/n2) %>% pull(Weight)
instruments_info <- read_csv(instrument_file, col_names = TRUE, show_col_types = FALSE) %>% arrange(Symbol)
instruments_info$Weight <- instruments_info %>% group_by(Symbol) %>%
summarise(Symbol=Symbol,
n0=length(unique(instruments_info$Class1)),
n1=length(unique(instruments_info$Class2[instruments_info$Class1==Class1])) ,
n2=length((instruments_info$Class2[instruments_info$Class2==Class2]))) %>%
ungroup %>% mutate(Weight=1/n0/n1/n2) %>% pull(Weight)
results <- list()
for(symbol in names(instruments_data)) {
print(symbol)
df <- instruments_data[[symbol]][[1]]
hc <- instruments_data[[symbol]][[2]]
df$Symbol <- symbol
df$Forecast <- df$ForecastTrend <- df$ForecastCarry <- df$ForecastSkew <- df$PositionMax <- df$PositionRaw <- df$PositionDynamic <- df$PositionPrevious <- df$RequiredTrade <- df$PositionRisk <- df$Position <- 0
df$Return <- c(0, diff(log(df$Close)))
df$Volatility = calculate_volatility(df$Return)
fx <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(FX)
if(fx == "EUR") {
df$FX <- 1
} else {
df$FX <- dplyr::filter(FX_rates, FX == fx) %>% pull(Rate)
}
df$Weight <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Weight)
df$Product <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Product)
df$ContractSize <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(ContractSize)
df$MinPosition <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(MinPosition)
df$TickSize <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(TickSize)
df$Decimals <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Decimals)
df$Spread <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Spread)
df$Commission <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Commission)
df$CostPerTrade <- (df$Spread / 2 + df$Commission)
# Relative volatility (strategy 13, it does not seems to add much)
{
# df$M <- 1
# df$RV <- relative_volatility(df$Volatility) # quite slow, you can replace it with df$Volatility / runMean(df$Volatility, 2520))
# df$RV <- df$Volatility / runMean(df$Volatility, 252)
# df$Q <- sapply(1:length(df$RV), function(i) sum(df$RV[i] > df$RV[1:i], na.rm=TRUE) / i)
# df$M <- EMA(2 - 1.5 * df$Q, 10)
}
# Trend-following (strategy 9)
df$ForecastTrend <- rowMeans(do.call(cbind, lapply(list(multiple_EMA, multiple_DC, multiple_KF, multiple_TII), function(f) f(df$Close, df$Close, df$Volatility))))
df$ForecastTrend <- cap_forecast(df$ForecastTrend * FDMtrend)
# Carry
# It is based on cash contract interest rate, we remove the 3% commission, so low volatility assets like
# bonds are not negatively affected in this analysis. Of course low volatility assets must be played on the future contract
# if you want to obtain the carry, as interest rates of the cash are always negative (because of the 3% commission that
# is higher than the volatility itself). For high volatility assets you can choose between cash or future.
hc_max <- which.max(hc)
hc_commission <- case_when(
df$Product[1] == "Cash" ~ 0,
df$Product[1] == "Index" ~ 0.03,
df$Product[1] == "Future" ~ 0.03,
TRUE ~ NA_real_)
hc_value <- (hc[hc_max]+hc_commission)
if(hc_value < 0)
hc_value <- 0
df$ForecastCarry <- ifelse(hc_max == 1, 1, -1) * hc_value / df$Volatility * 10
df$ForecastCarry <- cap_forecast(df$ForecastCarry * FDMcarry)
# Skewness (strategy 24)
df$ForecastSkew <- returns_skew(df$Return)
df$ForecastSkew <- cap_forecast(df$ForecastSkew * FDMskew)
# Final trade
df$Forecast <- (
strategy_weights$Trend * df$ForecastTrend +
strategy_weights$Carry * df$ForecastCarry +
strategy_weights$Skew  * df$ForecastSkew   )
df$Forecast <- cap_forecast(df$Forecast)
df$InstCapital <- capital * df$Weight * IDM
df$Exposure <- df$InstCapital * target_vol/df$Volatility
df$PositionRaw <-  (df$Exposure * df$FX * df$Forecast/10) /
(df$ContractSize * df$Close  )
df$PositionMax <- (df$Exposure * df$FX * 2) /
(df$ContractSize * df$Close  )
{
# df$Buffer <-  df$Exposure * buffering /
#   (df$ContractSize * df$Close)
# df$BufferUp <- df$Position + df$Buffer
# df$BufferLow <- df$Position - df$Buffer
# A little simulation of position buffering, it can be removed
# df$PositionSim <- NA
# df$PositionSim[1] <- 0
# for(i in 2:nrow(df)) {
#   df$PositionSim[i] <- df$PositionSim[i-1]
#   if(is.na(df$BufferUp[i]) | is.na(df$Position[i]))
#     next
#   if(df$PositionSim[i-1] > df$BufferUp[i] | df$PositionSim[i-1] < df$BufferLow[i])
#     df$PositionSim[i] <- df$Position[i]
# }
}
# Be careful, now it is reverse-date sorted, you cannot run any other function like EMA etc..
df <- arrange(df, desc(Date))
#write_csv(df, paste0(instruments_logs, "/", symbol, ".csv"))
results[[symbol]] <- df[1,]
}
# Final table
today_trading <- do.call(rbind, results)
if(!all(previous_trading$Symbol %in% today_trading$Symbol)) {
missing_prev <- previous_trading$Symbol[!(previous_trading$Symbol %in% today_trading$Symbol)]
missing_today <- today_trading$Symbol[!(today_trading$Symbol %in% previous_trading$Symbol)]
stop(paste("Previous position symbols (POSITION file) and current symbols (INSTRUMENTS file) do not match. Missing in current: ", missing_prev, ", missing in previous: ", missing_today, "\nFix it manually."))
}
# Dynamic portfolio
optimal_positions <- with(today_trading, PositionRaw)
# load previous positions file
previous_trading <- read_csv(positions_file, col_names = TRUE, show_col_types = FALSE) %>% arrange(Symbol)
# Final table
today_trading <- do.call(rbind, results)
if(!all(previous_trading$Symbol %in% today_trading$Symbol)) {
missing_prev <- previous_trading$Symbol[!(previous_trading$Symbol %in% today_trading$Symbol)]
missing_today <- today_trading$Symbol[!(today_trading$Symbol %in% previous_trading$Symbol)]
stop(paste("Previous position symbols (POSITION file) and current symbols (INSTRUMENTS file) do not match. Missing in current: ", missing_prev, ", missing in previous: ", missing_today, "\nFix it manually."))
}
# load instruments infos and calculate instruments weights from asset classes groups (could be coded a little better maybe?)
print("Loading symbosl info and previous positions file...")
instruments_info <- read_csv(instrument_file, col_names = TRUE, show_col_types = FALSE) %>% arrange(Symbol)
instruments_info$Weight <- instruments_info %>% group_by(Symbol) %>%
summarise(Symbol=Symbol,
n0=length(unique(instruments_info$Class1)),
n1=length(unique(instruments_info$Class2[instruments_info$Class1==Class1])) ,
n2=length((instruments_info$Class2[instruments_info$Class2==Class2]))) %>%
ungroup %>% mutate(Weight=1/n0/n1/n2) %>% pull(Weight)
# load previous positions file
previous_trading <- read_csv(positions_file, col_names = TRUE, show_col_types = FALSE) %>% arrange(Symbol)
# load price data from previous scrape
print("Loading price data...")
instruments_data <- list()
for(symbol in instruments_info$Symbol) {
instruments_data[[symbol]] <- load_cmc_cash_data(symbol, scrape_dir)
nas <- sum(is.na(instruments_data[[symbol]]$Price$Close))
if(nas > 0) {
warning(paste(symbol, "price data has", nas, "NAs. They have been filled"))
instruments_data[[symbol]]$Price$Close <- na.locf(instruments_data[[symbol]]$Price$Close, na.rm=FALSE)
}
# load FX data from previous scrape
print("Loading FX data...")
FX_names <- read_csv(FX_file, col_names = FALSE, show_col_types = FALSE) %>% unlist
files <- list()
for(fx in FX_names) {
f <- read_csv(paste0(FX_dir, "/", fx, ".csv"), col_names = FALSE, show_col_types = FALSE)
colnames(f) <- c("Date", "Rate")
files[[fx]] <- arrange(f, Date) %>% tail(2) %>% head(1) # we take yesterday's rate, to match CMC data
}
FX_rates <- do.call(rbind, files) %>% mutate(FX=toupper(sub("eur", "", FX_names)))
colnames(FX_rates) <- c("Date", "Rate", "FX")
# the covariance matrix
print("Calculate covariance matrix...")
closes <- lapply(instruments_data, function(x)x[[1]])
closes_merged <- Reduce(function(...) full_join(..., by="Date"), closes) %>% arrange(Date)
colnames(closes_merged) <- c("Date", names(instruments_data))
returns_merged <- data.frame(Date=closes_merged$Date, apply(closes_merged[,-1], 2, function(x) c(0,diff(log(x)))))
vols <- data.frame(Date=returns_merged$Date, apply(returns_merged[,-1], 2, function(x) calculate_volatility(x)))
cor_matrix <- cor(tail(returns_merged[,-1], corr_days), use="pairwise.complete.obs")
last_day_vol <- tail(vols, 1)[-1]
cov_matrix <- diag(last_day_vol) %*% cor_matrix %*% diag(last_day_vol)
rownames(cov_matrix) <- colnames(cov_matrix) <- names(instruments_data)
# iterate over data and calculate positions
print("Calculate new positions...")
results <- list()
for(symbol in names(instruments_data)) {
print(symbol)
df <- instruments_data[[symbol]][[1]]
hc <- instruments_data[[symbol]][[2]]
df$Symbol <- symbol
df$Forecast <- df$ForecastTrend <- df$ForecastCarry <- df$ForecastSkew <- df$PositionMax <- df$PositionRaw <- df$PositionDynamic <- df$PositionPrevious <- df$RequiredTrade <- df$PositionRisk <- df$Position <- 0
df$Return <- c(0, diff(log(df$Close)))
df$Volatility = calculate_volatility(df$Return)
fx <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(FX)
if(fx == "EUR") {
df$FX <- 1
} else {
df$FX <- dplyr::filter(FX_rates, FX == fx) %>% pull(Rate)
}
df$Weight <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Weight)
df$Product <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Product)
df$ContractSize <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(ContractSize)
df$MinPosition <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(MinPosition)
df$TickSize <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(TickSize)
df$Decimals <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Decimals)
df$Spread <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Spread)
df$Commission <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Commission)
df$CostPerTrade <- (df$Spread / 2 + df$Commission)
# Relative volatility (strategy 13, it does not seems to add much)
{
# df$M <- 1
# df$RV <- relative_volatility(df$Volatility) # quite slow, you can replace it with df$Volatility / runMean(df$Volatility, 2520))
# df$RV <- df$Volatility / runMean(df$Volatility, 252)
# df$Q <- sapply(1:length(df$RV), function(i) sum(df$RV[i] > df$RV[1:i], na.rm=TRUE) / i)
# df$M <- EMA(2 - 1.5 * df$Q, 10)
}
# Trend-following (strategy 9)
df$ForecastTrend <- rowMeans(do.call(cbind, lapply(list(multiple_EMA, multiple_DC, multiple_KF, multiple_TII), function(f) f(df$Close, df$Close, df$Volatility))))
df$ForecastTrend <- cap_forecast(df$ForecastTrend * FDMtrend)
# Carry
# It is based on cash contract interest rate, we remove the 3% commission, so low volatility assets like
# bonds are not negatively affected in this analysis. Of course low volatility assets must be played on the future contract
# if you want to obtain the carry, as interest rates of the cash are always negative (because of the 3% commission that
# is higher than the volatility itself). For high volatility assets you can choose between cash or future.
hc_max <- which.max(hc)
hc_commission <- case_when(
df$Product[1] == "Cash" ~ 0,
df$Product[1] == "Index" ~ 0.03,
df$Product[1] == "Future" ~ 0.03,
TRUE ~ NA_real_)
hc_value <- (hc[hc_max]+hc_commission)
if(hc_value < 0)
hc_value <- 0
df$ForecastCarry <- ifelse(hc_max == 1, 1, -1) * hc_value / df$Volatility * 10
df$ForecastCarry <- cap_forecast(df$ForecastCarry * FDMcarry)
# Skewness (strategy 24)
df$ForecastSkew <- returns_skew(df$Return)
df$ForecastSkew <- cap_forecast(df$ForecastSkew * FDMskew)
# Final trade
df$Forecast <- (
strategy_weights$Trend * df$ForecastTrend +
strategy_weights$Carry * df$ForecastCarry +
strategy_weights$Skew  * df$ForecastSkew   )
df$Forecast <- cap_forecast(df$Forecast)
df$InstCapital <- capital * df$Weight * IDM
df$Exposure <- df$InstCapital * target_vol/df$Volatility
df$PositionRaw <-  (df$Exposure * df$FX * df$Forecast/10) /
(df$ContractSize * df$Close  )
df$PositionMax <- (df$Exposure * df$FX * 2) /
(df$ContractSize * df$Close  )
{
# df$Buffer <-  df$Exposure * buffering /
#   (df$ContractSize * df$Close)
# df$BufferUp <- df$Position + df$Buffer
# df$BufferLow <- df$Position - df$Buffer
# A little simulation of position buffering, it can be removed
# df$PositionSim <- NA
# df$PositionSim[1] <- 0
# for(i in 2:nrow(df)) {
#   df$PositionSim[i] <- df$PositionSim[i-1]
#   if(is.na(df$BufferUp[i]) | is.na(df$Position[i]))
#     next
#   if(df$PositionSim[i-1] > df$BufferUp[i] | df$PositionSim[i-1] < df$BufferLow[i])
#     df$PositionSim[i] <- df$Position[i]
# }
}
# Be careful, now it is reverse-date sorted, you cannot run any other function like EMA etc..
df <- arrange(df, desc(Date))
#write_csv(df, paste0(instruments_logs, "/", symbol, ".csv"))
results[[symbol]] <- df[1,]
}
# Final table
today_trading <- do.call(rbind, results)
if(!all(previous_trading$Symbol %in% today_trading$Symbol)) {
missing_prev <- previous_trading$Symbol[!(previous_trading$Symbol %in% today_trading$Symbol)]
missing_today <- today_trading$Symbol[!(today_trading$Symbol %in% previous_trading$Symbol)]
stop(paste("Previous position symbols (POSITION file) and current symbols (INSTRUMENTS file) do not match. Missing in current: ", missing_prev, ", missing in previous: ", missing_today, "\nFix it manually."))
}
# Dynamic portfolio
optimal_positions <- with(today_trading, PositionRaw)
max_positions <- with(today_trading, PositionMax)
notional_exposures <- with(today_trading, ContractSize * Close / FX)
costs_per_contract <- with(today_trading, ContractSize * (Spread/2) / FX)
previous_position <- previous_trading$Position
position_dynamic <- dynamic_portfolio(capital, optimal_positions, max_positions, notional_exposures,  cov_matrix,
previous_position = previous_position,
costs_per_contract=costs_per_contract, trade_shadow_cost = trade_shadow_cost)
position_final <- round_position(position_dynamic, today_trading$MinPosition,  today_trading$Decimals)
# Buffering
res <- buffering_portfolio(capital, position_final, previous_position, notional_exposures, cov_matrix, buffering_level, target_vol)
required_trades <- res[[1]]
portfolio_tracking_error <- res[[2]]
print(paste("Portfolio tracking error:", round(portfolio_tracking_error, 3), "against buffer level", buffering_level/2*target_vol))
portfolio_update_requred <- ifelse(all(required_trades == 0), FALSE, TRUE)
if(portfolio_update_requred) {
print("Portfolio update requited, check 'RequitedTrade' column in the positions file.")
} else {
print("No portfolio update requited.")
}
# Final positions trading file
today_trading$PositionPrevious <- previous_position
today_trading$PositionDynamic <- position_dynamic
today_trading$Position <- position_final
today_trading$PositionRisk <- abs(with(today_trading, Position * ContractSize * (Close / FX) * Volatility))
today_trading$RequiredTrade <- required_trades
instruments_info$Weight <- 1 / length(instruments_info$Weight )
results <- list()
for(symbol in names(instruments_data)) {
print(symbol)
df <- instruments_data[[symbol]][[1]]
hc <- instruments_data[[symbol]][[2]]
df$Symbol <- symbol
df$Forecast <- df$ForecastTrend <- df$ForecastCarry <- df$ForecastSkew <- df$PositionMax <- df$PositionRaw <- df$PositionDynamic <- df$PositionPrevious <- df$RequiredTrade <- df$PositionRisk <- df$Position <- 0
df$Return <- c(0, diff(log(df$Close)))
df$Volatility = calculate_volatility(df$Return)
fx <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(FX)
if(fx == "EUR") {
df$FX <- 1
} else {
df$FX <- dplyr::filter(FX_rates, FX == fx) %>% pull(Rate)
}
df$Weight <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Weight)
df$Product <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Product)
df$ContractSize <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(ContractSize)
df$MinPosition <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(MinPosition)
df$TickSize <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(TickSize)
df$Decimals <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Decimals)
df$Spread <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Spread)
df$Commission <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Commission)
df$CostPerTrade <- (df$Spread / 2 + df$Commission)
# Relative volatility (strategy 13, it does not seems to add much)
{
# df$M <- 1
# df$RV <- relative_volatility(df$Volatility) # quite slow, you can replace it with df$Volatility / runMean(df$Volatility, 2520))
# df$RV <- df$Volatility / runMean(df$Volatility, 252)
# df$Q <- sapply(1:length(df$RV), function(i) sum(df$RV[i] > df$RV[1:i], na.rm=TRUE) / i)
# df$M <- EMA(2 - 1.5 * df$Q, 10)
}
# Trend-following (strategy 9)
df$ForecastTrend <- rowMeans(do.call(cbind, lapply(list(multiple_EMA, multiple_DC, multiple_KF, multiple_TII), function(f) f(df$Close, df$Close, df$Volatility))))
df$ForecastTrend <- cap_forecast(df$ForecastTrend * FDMtrend)
# Carry
# It is based on cash contract interest rate, we remove the 3% commission, so low volatility assets like
# bonds are not negatively affected in this analysis. Of course low volatility assets must be played on the future contract
# if you want to obtain the carry, as interest rates of the cash are always negative (because of the 3% commission that
# is higher than the volatility itself). For high volatility assets you can choose between cash or future.
hc_max <- which.max(hc)
hc_commission <- case_when(
df$Product[1] == "Cash" ~ 0,
df$Product[1] == "Index" ~ 0.03,
df$Product[1] == "Future" ~ 0.03,
TRUE ~ NA_real_)
hc_value <- (hc[hc_max]+hc_commission)
if(hc_value < 0)
hc_value <- 0
df$ForecastCarry <- ifelse(hc_max == 1, 1, -1) * hc_value / df$Volatility * 10
df$ForecastCarry <- cap_forecast(df$ForecastCarry * FDMcarry)
# Skewness (strategy 24)
df$ForecastSkew <- returns_skew(df$Return)
df$ForecastSkew <- cap_forecast(df$ForecastSkew * FDMskew)
# Final trade
df$Forecast <- (
strategy_weights$Trend * df$ForecastTrend +
strategy_weights$Carry * df$ForecastCarry +
strategy_weights$Skew  * df$ForecastSkew   )
df$Forecast <- cap_forecast(df$Forecast)
df$InstCapital <- capital * df$Weight * IDM
df$Exposure <- df$InstCapital * target_vol/df$Volatility
df$PositionRaw <-  (df$Exposure * df$FX * df$Forecast/10) /
(df$ContractSize * df$Close  )
df$PositionMax <- (df$Exposure * df$FX * 2) /
(df$ContractSize * df$Close  )
{
# df$Buffer <-  df$Exposure * buffering /
#   (df$ContractSize * df$Close)
# df$BufferUp <- df$Position + df$Buffer
# df$BufferLow <- df$Position - df$Buffer
# A little simulation of position buffering, it can be removed
# df$PositionSim <- NA
# df$PositionSim[1] <- 0
# for(i in 2:nrow(df)) {
#   df$PositionSim[i] <- df$PositionSim[i-1]
#   if(is.na(df$BufferUp[i]) | is.na(df$Position[i]))
#     next
#   if(df$PositionSim[i-1] > df$BufferUp[i] | df$PositionSim[i-1] < df$BufferLow[i])
#     df$PositionSim[i] <- df$Position[i]
# }
}
# Be careful, now it is reverse-date sorted, you cannot run any other function like EMA etc..
df <- arrange(df, desc(Date))
#write_csv(df, paste0(instruments_logs, "/", symbol, ".csv"))
results[[symbol]] <- df[1,]
}
# Final table
today_trading <- do.call(rbind, results)
if(!all(previous_trading$Symbol %in% today_trading$Symbol)) {
missing_prev <- previous_trading$Symbol[!(previous_trading$Symbol %in% today_trading$Symbol)]
missing_today <- today_trading$Symbol[!(today_trading$Symbol %in% previous_trading$Symbol)]
stop(paste("Previous position symbols (POSITION file) and current symbols (INSTRUMENTS file) do not match. Missing in current: ", missing_prev, ", missing in previous: ", missing_today, "\nFix it manually."))
}
# Dynamic portfolio
optimal_positions <- with(today_trading, PositionRaw)
max_positions <- with(today_trading, PositionMax)
notional_exposures <- with(today_trading, ContractSize * Close / FX)
costs_per_contract <- with(today_trading, ContractSize * (Spread/2) / FX)
previous_position <- previous_trading$Position
position_dynamic <- dynamic_portfolio(capital, optimal_positions, max_positions, notional_exposures,  cov_matrix,
previous_position = previous_position,
costs_per_contract=costs_per_contract, trade_shadow_cost = trade_shadow_cost)
position_final <- round_position(position_dynamic, today_trading$MinPosition,  today_trading$Decimals)
# Buffering
res <- buffering_portfolio(capital, position_final, previous_position, notional_exposures, cov_matrix, buffering_level, target_vol)
required_trades <- res[[1]]
portfolio_tracking_error <- res[[2]]
print(paste("Portfolio tracking error:", round(portfolio_tracking_error, 3), "against buffer level", buffering_level/2*target_vol))
portfolio_update_requred <- ifelse(all(required_trades == 0), FALSE, TRUE)
if(portfolio_update_requred) {
print("Portfolio update requited, check 'RequitedTrade' column in the positions file.")
} else {
print("No portfolio update requited.")
}
# Final positions trading file
today_trading$PositionPrevious <- previous_position
today_trading$PositionDynamic <- position_dynamic
today_trading$Position <- position_final
today_trading$PositionRisk <- abs(with(today_trading, Position * ContractSize * (Close / FX) * Volatility))
today_trading$RequiredTrade <- required_trades
