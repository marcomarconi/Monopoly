df$ForecastCSM <- cross_sectional_momentum(df$NP, df$A) * FDMcsm
df$ForecastCSM <- cap_forecast(df$ForecastCSM)
}
# Skewness (strategy 24)
if(weights[["Skew"]]  > 0) {
df$ForecastSkew <- returns_skew(df$Return) * FDMskew
df$ForecastSkew <- cap_forecast(df$ForecastSkew)
}
if(weights[["Test"]]  > 0) {
logitm <- 30; logitr <- 25
rsi <- multiple_RSI(df$Close%>% na.locf(na.rm=F)) / 20
rsi <- -((invlogit(logitm*rsi-logitr) + invlogit(logitm*rsi+25))-1) * 20
forecast <- EMA(rsi , 5)
forecast <- multiple_RSI(df$Close%>% na.locf(na.rm=F))
df$ForecastTest <-   forecast
}
{  # Tests
# # Kurtosis
# if(weights[["Test"]]  > 0) {
#   df$ForecastTest <- returns_kurtosis(df$Return) * FDMkurtosis
#   forecast <- rollapply(df$Return, width=20, kurt,  fill=NA, align="right")
#   df$ForecastTest <- cap_forecast(df$ForecastTest)
# }
# Acceleration
# if(weights[["Test"]]  > 0) {
#   df$Forecast16 <- (EMA(df$AdjClose, 16) -  EMA(df$AdjClose, 64)) / (df$Close * df$Volatility / 16) * 4.1
#   df$Forecast32 <- (EMA(df$AdjClose, 32) -  EMA(df$AdjClose, 128)) / (df$Close * df$Volatility / 16) * 2.79
#   df$Forecast64 <- (EMA(df$AdjClose, 64) -  EMA(df$AdjClose, 256)) / (df$Close * df$Volatility / 16) * 1.91
#   df$Forecast128 <- (EMA(df$AdjClose, 128) -  EMA(df$AdjClose, 512)) / (df$Close * df$Volatility / 16) * 1.50
#   df$Acc16 <- c(rep(NA, 16), diff(df$Forecast16, 16)) * 1.90
#   df$Acc32 <- c(rep(NA, 32), diff(df$Forecast32, 32)) * 1.98
#   df$Acc64 <- c(rep(NA, 64), diff(df$Forecast64, 64)) * 2.05
#   df$Acc128 <- c(rep(NA, 128), diff(df$Forecast128, 128)) * 2.10
#   df$ForecastTest <- cap_forecast(rowMeans(cbind(df$Acc16 , df$Acc32 , df$Acc64, df$Acc128)) * 1.55)
# }
# COT
# COT <- read_csv("/home/marco/trading/Systems/Monopoly/COT.csv")
# select(COT, c("Market and Exchange Names", "As of Date in Form YYYY-MM-DD", "Noncommercial Positions-Long (All)","Noncommercial Positions-Short (All)", "Commercial Positions-Long (All)","Commercial Positions-Short (All)")) -> a
# colnames(a) <- c("Name", "Date", "NC_long", "NC_short", "C_long", "C_short")
# mutate(a, NC=NC_long/(NC_long+NC_short),C=C_long/(C_long+C_short) ) -> COT
# if(weights[["Test"]]  > 0) {
#     df$COT <- to_load[to_load$Symbol==symbol,]$COT %>% gsub('\"', '', .)
#     if(is.na(df$COT[1]) | symbol =="CL"| symbol =="KO"| symbol =="TG") {
#         df$ForecastTest <- 0
#
#     } else {
#     cot <- filter(COT, Name==df$COT[1])  %>%  select(Date, C)
#     df_ <- df
#     df_ <- merge(df_, cot, by="Date", all = TRUE, incomparables = NA)
#     df <- arrange(df_, Date) %>% mutate(C = na.locf(C, na.rm=F))
#     df$C <- lag(df$C );
#     r <- c(0,diff(log(df$C))); r[r==0] <- NA; r = na.locf(r, na.rm=F)
#     f <- AbsoluteStrength(df$C, 20) /  calculate_volatility(r) * 28
#     f <- multiple_AS(df$C, df$C, calculate_volatility(r))
#     forecast <- f
#     df$ForecastTest <- (forecast)
#     }
# }
}
# Final trade
df$Forecast <- ( weights[["Trend"]] * df$ForecastTrend +
weights[["Carry"]] * df$ForecastCarry +
weights[["CSM"]] * df$ForecastCSM +
weights[["Skew"]] * df$ForecastSkew +
weights[["Test"]] * df$ForecastTest) / 10
df$Forecast <- lag(df$Forecast)
df$Excess <- df$Return * df$Position * df$Forecast * IDM
forecasts[[symbol]]  <-   select(df, Date, Forecast)
exposures[[symbol]]  <-  mutate(df, Exposure=Position * Forecast) %>% select(Date, Exposure)
returns[[symbol]]  <-  select(df, Date, Return)
vols[[symbol]]  <-  select(df, Date, Volatility)
results[[symbol]] <- select(df, Date, Excess)
} # end of symbol sloop
print("")
portfolio <- merge_portfolio_list(results)
weights <- 1 / length(names(Assets)) # equal weights per instrument
res <- portfolio_summary(as.matrix(portfolio[,-1]) * weights, dates = portfolio$Date, plot_stats = TRUE, symbol_wise = symbol_wise  )
print(res$Aggregate %>% unlist)
res <- portfolio_summary(as.matrix(portfolio[,-1]) * portfolio_weights, dates = as.Date(portfolio$Date), plot_stats = TRUE, symbol_wise = symbol_wise)
print(res$Aggregate %>% unlist)
all_forecasts <- do.call(rbind,forecasts)[,2] %>% na.omit
avg_forecast_turnover <- round(252 * mean(abs(diff(all_forecasts/10))), 2)
avg_trade_turnover <- round(length(rle(all_forecasts>0)$length) / (length(all_forecasts)/252), 2)
print(paste("Average Forecast Turnover:", avg_forecast_turnover))
print(paste("Average Trade Turnover:", avg_trade_turnover))
if(symbol_wise) {
res$Symbols$Class <- lapply(Assets[names(results)], function(x) x$Class[1]) %>% unlist
group_by(res$Symbols, Class) %>% summarise(SR_mean=mean(`Sharpe ratio`, na.rm=T), SR_sd=sd(`Sharpe ratio`, na.rm=T))
}
## Some figures takes from the Risk Management section
# Figure 97: Portfolio volatility, check it is in line with target volatility
# full_df_exposures <- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), exposures) %>% arrange(Date)
# full_df_returns <- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), returns) %>% arrange(Date)
# full_df_vols<- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), vols) %>% arrange(Date)
# a <- sapply(181:nrow(full_df_returns),  function(i) { w <- as.numeric(full_df_exposures[i,-1]); w[is.na(w)] <- 0; S <-  cov(full_df_returns[(i-180):i,-1], use="pairwise.complete.obs"); S[is.na(S)] <- 0; sqrt( w %*% S %*% w  )  } )
# plot.ts(a*100); abline(h=target_vol*100)
# a <- rowSums(abs(full_df_exposures[,-1] * full_df_vols[,-1]), na.rm=T)
}
# Final Backtest
{
# A subset of instrument I might actually trade
CMC_selection <- c("ZN","G","GG","CC","CA","KC","RM","HG","ZC","CT","CL","RB","HO", "LF", "PL","PA", "SI", "GC","HE","GF", "LE","LS","NG","ZO",
"OJ","ZR","ZS","ZL","ZR","ZC","SW","ZM",
"ES","DX","ZW","D6","HS","NY","LX","A6","B6","E6","J6","M6","N6","NR","QT","S6","T6","SK")
Assets <- BackAdj[CMC_selection] # or BackAdj[CMC_selection]
results <- list()
forecasts <- list()
exposures <- list()
returns <- list()
vols <- list()
target_vol <- 0.25
IDM = 2.5
FDMtrend <- 1.33
FDMcarry <- 1.05 # so small?
FDMcsm <- 1.4
FDMskew <- 1.18
FDM <- 1
# Apply relative volatility
relative_vol <- FALSE
# Apply Marker Correlation
market_cor <- FALSE
# Symbol-wise results
symbol_wise <- FALSE
# Strategies weights
weights <- list("Long"=0, "Trend"=0.4, "Carry"=0.5, "CSM"=0, "Skew"=0.1, "Test"=0)
if(sum(unlist(weights)) != 1)
warning("Strategy weights do not sum to zero")
# Asset class indices
if(weights[["CSM"]] > 0) {
NPs <- list()
for(n in names(Assets)) {
df <- Assets[[n]]
df$Volatility = calculate_volatility(df$Return)
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$dNP = c(0, diff(df$NP))
NPs[[n]] <- select(df, Date, Symbol, Class, NP, dNP)
}
allNPs <- do.call(rbind, NPs)
Asset_class_indices <- group_by(allNPs, Class, Date) %>% summarise(Symbol=Symbol, R=mean(dNP)) %>%
arrange(Class, Date) %>% select(-Symbol)  %>%  unique %>% group_by( Class) %>% mutate(A=cumsum(R)) %>% ungroup()
}
# iterate over symbols
for(symbol in names(Assets)) {
cat(paste(symbol, ""))
df <- Assets[[symbol]]
df$Volatility = calculate_volatility(df$Return)
df$Position = lag(target_vol / df$Volatility)
df$Return[is.na(df$Return)] <- 0
df$ForecastTrend <- df$ForecastCarry <- df$ForecastCSM <- df$ForecastSkew <- df$ForecastTest <- 0
# Relative volatility (strategy 13, improvement is minimal, and we only apply it to trend)
df$M <- 1
if(relative_vol) {
df$RV <- relative_volatility(df$Volatility)
df$Q <- sapply(1:length(df$RV), function(i) sum(df$RV[i] > df$RV[1:i], na.rm=TRUE) / i)
df$M <- EMA(2 - 1.5 * df$Q, 10)
}
# Correlation with market
df$Cor <- 1
if(market_cor) {
df <- merge(df, select(BackAdj$ES, Date, Return) %>% mutate(ES=Return) %>% select(-Return), by="Date")
df$Cor <- multiple_cor(df$Return %>% na.locf(na.rm=F), df$ES %>% na.locf(na.rm=F))
df$Cor <- -df$Cor * 0.75 + 1.25
}
# Trend-following (strategy 9)
if(weights[["Trend"]]  > 0) {
df$ForecastEMA <- multiple_EMA(df$AdjClose, df$Close, df$Volatility)
df$ForecastDC <- multiple_DC(df$AdjClose, df$Close, df$Volatility)
df$ForecastKF <- multiple_KF(df$AdjClose, df$Close, df$Volatility)
df$ForecastTII <- multiple_TII(df$AdjClose, df$Close, df$Volatility)
df$ForecastTrend <- rowMeans(cbind(df$ForecastEMA, df$ForecastDC, df$ForecastKF, df$ForecastTII)) * FDMtrend * df$M * df$Cor
df$ForecastTrend <- cap_forecast(df$ForecastTrend)
}
# Carry (strategy 10)
if(weights[["Carry"]]  > 0) {
df$ForecastCarry <- multiple_Carry(df$Basis, df$Basis_distance, df$Volatility)  * FDMcarry
df$ForecastCarry <- cap_forecast(df$ForecastCarry)
}
# Cross-sectional momentum (strategy 19)
if(weights[["CSM"]]  > 0) {
df <- merge(df, filter(Asset_class_indices, Class==df$Class[1]) %>%  select(Date, A), by="Date") # Asset_class_indices obtained from before
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$ForecastCSM <- cross_sectional_momentum(df$NP, df$A) * FDMcsm
df$ForecastCSM <- cap_forecast(df$ForecastCSM)
}
# Skewness (strategy 24)
if(weights[["Skew"]]  > 0) {
df$ForecastSkew <- returns_skew(df$Return) * FDMskew
df$ForecastSkew <- cap_forecast(df$ForecastSkew)
}
if(weights[["Test"]]  > 0) {
logitm <- 30; logitr <- 25
rsi <- multiple_RSI(df$Close%>% na.locf(na.rm=F)) / 20
rsi <- -((invlogit(logitm*rsi-logitr) + invlogit(logitm*rsi+25))-1) * 20
forecast <- EMA(rsi , 5)
forecast <- multiple_RSI(df$Close%>% na.locf(na.rm=F))
df$ForecastTest <-   forecast
}
{  # Tests
# # Kurtosis
# if(weights[["Test"]]  > 0) {
#   df$ForecastTest <- returns_kurtosis(df$Return) * FDMkurtosis
#   forecast <- rollapply(df$Return, width=20, kurt,  fill=NA, align="right")
#   df$ForecastTest <- cap_forecast(df$ForecastTest)
# }
# Acceleration
# if(weights[["Test"]]  > 0) {
#   df$Forecast16 <- (EMA(df$AdjClose, 16) -  EMA(df$AdjClose, 64)) / (df$Close * df$Volatility / 16) * 4.1
#   df$Forecast32 <- (EMA(df$AdjClose, 32) -  EMA(df$AdjClose, 128)) / (df$Close * df$Volatility / 16) * 2.79
#   df$Forecast64 <- (EMA(df$AdjClose, 64) -  EMA(df$AdjClose, 256)) / (df$Close * df$Volatility / 16) * 1.91
#   df$Forecast128 <- (EMA(df$AdjClose, 128) -  EMA(df$AdjClose, 512)) / (df$Close * df$Volatility / 16) * 1.50
#   df$Acc16 <- c(rep(NA, 16), diff(df$Forecast16, 16)) * 1.90
#   df$Acc32 <- c(rep(NA, 32), diff(df$Forecast32, 32)) * 1.98
#   df$Acc64 <- c(rep(NA, 64), diff(df$Forecast64, 64)) * 2.05
#   df$Acc128 <- c(rep(NA, 128), diff(df$Forecast128, 128)) * 2.10
#   df$ForecastTest <- cap_forecast(rowMeans(cbind(df$Acc16 , df$Acc32 , df$Acc64, df$Acc128)) * 1.55)
# }
# COT
# COT <- read_csv("/home/marco/trading/Systems/Monopoly/COT.csv")
# select(COT, c("Market and Exchange Names", "As of Date in Form YYYY-MM-DD", "Noncommercial Positions-Long (All)","Noncommercial Positions-Short (All)", "Commercial Positions-Long (All)","Commercial Positions-Short (All)")) -> a
# colnames(a) <- c("Name", "Date", "NC_long", "NC_short", "C_long", "C_short")
# mutate(a, NC=NC_long/(NC_long+NC_short),C=C_long/(C_long+C_short) ) -> COT
# if(weights[["Test"]]  > 0) {
#     df$COT <- to_load[to_load$Symbol==symbol,]$COT %>% gsub('\"', '', .)
#     if(is.na(df$COT[1]) | symbol =="CL"| symbol =="KO"| symbol =="TG") {
#         df$ForecastTest <- 0
#
#     } else {
#     cot <- filter(COT, Name==df$COT[1])  %>%  select(Date, C)
#     df_ <- df
#     df_ <- merge(df_, cot, by="Date", all = TRUE, incomparables = NA)
#     df <- arrange(df_, Date) %>% mutate(C = na.locf(C, na.rm=F))
#     df$C <- lag(df$C );
#     r <- c(0,diff(log(df$C))); r[r==0] <- NA; r = na.locf(r, na.rm=F)
#     f <- AbsoluteStrength(df$C, 20) /  calculate_volatility(r) * 28
#     f <- multiple_AS(df$C, df$C, calculate_volatility(r))
#     forecast <- f
#     df$ForecastTest <- (forecast)
#     }
# }
}
# Final trade
df$Forecast <- ( weights[["Trend"]] * df$ForecastTrend +
weights[["Carry"]] * df$ForecastCarry +
weights[["CSM"]] * df$ForecastCSM +
weights[["Skew"]] * df$ForecastSkew +
weights[["Test"]] * df$ForecastTest) / 10
df$Forecast <- lag(df$Forecast)
df$Excess <- df$Return * df$Position * df$Forecast * IDM
forecasts[[symbol]]  <-   select(df, Date, Forecast)
exposures[[symbol]]  <-  mutate(df, Exposure=Position * Forecast) %>% select(Date, Exposure)
returns[[symbol]]  <-  select(df, Date, Return)
vols[[symbol]]  <-  select(df, Date, Volatility)
results[[symbol]] <- select(df, Date, Excess)
} # end of symbol sloop
print("")
portfolio <- merge_portfolio_list(results)
weights <- 1 / length(names(Assets)) # equal weights per instrument
res <- portfolio_summary(as.matrix(portfolio[,-1]) * weights, dates = portfolio$Date, plot_stats = TRUE, symbol_wise = symbol_wise  )
print(res$Aggregate %>% unlist)
res <- portfolio_summary(as.matrix(portfolio[,-1]) * portfolio_weights, dates = as.Date(portfolio$Date), plot_stats = TRUE, symbol_wise = symbol_wise)
print(res$Aggregate %>% unlist)
all_forecasts <- do.call(rbind,forecasts)[,2] %>% na.omit
avg_forecast_turnover <- round(252 * mean(abs(diff(all_forecasts/10))), 2)
avg_trade_turnover <- round(length(rle(all_forecasts>0)$length) / (length(all_forecasts)/252), 2)
print(paste("Average Forecast Turnover:", avg_forecast_turnover))
print(paste("Average Trade Turnover:", avg_trade_turnover))
if(symbol_wise) {
res$Symbols$Class <- lapply(Assets[names(results)], function(x) x$Class[1]) %>% unlist
group_by(res$Symbols, Class) %>% summarise(SR_mean=mean(`Sharpe ratio`, na.rm=T), SR_sd=sd(`Sharpe ratio`, na.rm=T))
}
{
## Some figures takes from the Risk Management section
# Figure 97: Portfolio volatility, check it is in line with target volatility
# full_df_exposures <- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), exposures) %>% arrange(Date)
# full_df_returns <- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), returns) %>% arrange(Date)
# full_df_vols<- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), vols) %>% arrange(Date)
# a <- sapply(181:nrow(full_df_returns),  function(i) { w <- as.numeric(full_df_exposures[i,-1]); w[is.na(w)] <- 0; S <-  cov(full_df_returns[(i-180):i,-1], use="pairwise.complete.obs"); S[is.na(S)] <- 0; sqrt( w %*% S %*% w  )  } )
# plot.ts(a*100); abline(h=target_vol*100)
# a <- rowSums(abs(full_df_exposures[,-1] * full_df_vols[,-1]), na.rm=T)
}
# for some reason, scrapped CMC data are lagged one day, check for example https://www.cmcmarkets.com/en-gb/instruments/coffee-arabica-jul-2023?search=1
merge_barchart_cmc_data <- function(symbol, future, dir="/home/marco/trading/Historical Data/CMC/", lagged=TRUE) {
symbol_dir <- paste0(dir, "/", symbol)
files <- list()
for (l in list.files(symbol_dir)) {
n <- sub(".csv", "", l)
f <- read_csv(paste0(symbol_dir, "/", l), show_col_types = FALSE, col_names = FALSE)
if(lagged)
f[,1] <- f[,1]+1
colnames(f) <- c("Date", n)
files[[n]] <- f
}
df = Reduce(function(...) full_join(..., by="Date"), files) %>% arrange(Date)
mg <- merge(future, df, by="Date", all=TRUE)
return(mg)
}
# Load future contracts, we expect all the contract to be in the directory, and the contract order in the file order.txt
load_future_contracts <- function(symbol, dir, order_years=c(80:99,0:30), order_months=c("f", "g", "h", "j", "k", "m", "n", "q", "u", "v", "x", "z")) {
order_years <- sapply(order_years, function(x) ifelse(x < 10, paste0("0", as.character(x)), as.character(x)))
order_comb <- apply(expand.grid(order_months, order_years), 1, function(x) tolower(paste0(symbol, paste0(x, collapse = ""))))
files <- list()
# load all the contracts, adding an infinite before and after each contract (so you can recognize start and end)
for(l in list.files(dir, pattern = ".csv")) {
f <- fread(paste0(dir, "/", l)) %>% select(Time, Last) %>% rename(Date=Time)
f$Date <- as.Date(f$Date, format="%m/%d/%Y")
f <- arrange(f, Date)
f <- rbind(data.frame(Date=f$Date[1]-1, Last=NaN), f, data.frame(Date=f$Date[length(f$Date)]+1, Last=NaN))
files[[sub(".csv", "", l)]] <- f
}
# Join all the contracts and sort them by Date and contracts order
df <- Reduce(function(...) full_join(..., by="Date", all=T), files) %>% arrange(Date)
colnames(df) <- c("Date", names(files))
df <- as.data.frame(df)
#order <- scan(paste0(dir, "/", order_file), what="string") %>% tolower()
order <- colnames(df)[-1][na.omit(match(order_comb, colnames(df)[-1]))]
df <- df[,c("Date", order)] %>% arrange(Date)
return(df)
}
# create a backadjusted future contract
# N: days to expiration to rollover
backadjust_future <- function(df, N=1, period=365) {
month_code <- setNames(1:12,c("f", "g", "h", "j", "k", "m", "n", "q", "u", "v", "x", "z"))
m <- as.matrix(df[,-1]) # the first column is supposed to be the Date
d <- as.Date(df[,1]) # dates
sc <- rep(NA, ncol(m)) # contracts starts
ec <- rep(NA, ncol(m)) # contracts ends
ym <- rep(yearmonth(0), ncol(m)) # contracts name in yearmonth
for(j in 1:ncol(m)) {
a <- which(is.nan(m[,j]))
sc[j] <- a[1]+1
ec[j] <- a[2]-1
code_j <- colnames(m)[j]
year_j <- as.numeric(substr(code_j, nchar(code_j)-1, nchar(code_j))); year_j <- ifelse(year_j > 40, year_j + 1900, year_j + 2000)
month_j <- as.numeric(month_code[substr(code_j, nchar(code_j)-2, nchar(code_j)-2)]);
ym[j] <- yearmonth(paste0(year_j, "-", month_j))
}
j <- 1;
i <- 1;
adjclose <- rep(NA, nrow(m)); # the final continous backadjusted price
close <- rep(NA, nrow(m)); # the current contract unadjusted price
basis <- rep(NA, nrow(m)); # basis as log differences
basis_price <- rep(NA, nrow(m)); # basis as price differences
basis_distance <- rep(NA, nrow(m)); # months between basis contracts
basis_gordon <- rep(NA, nrow(m)); # months between basis contracts as defined in gorton et. al 2013
spot <- rep(NA, nrow(m)); # implied spot price as defined in gorton et. al 2013
rollover <- rep(FALSE, nrow(m)); # rollover dates
contract <- rep(NA, nrow(m)); # current contract
maturity <- rep(NA, nrow(m)); # days to maturity
difference <- rep(NA, nrow(m)); # returns considering rollover (in price differences)
ret <- rep(NA, nrow(m)); # returns considering rollover (in log price)
first <- NA # first value to use to adjust
last <- 0 # last value to use to adjust
for(i in 3:(nrow(m)-1)) { # this assume first and last entries are Inf
ret[i] <- log(m[i,j] / m[i-1,j])
difference[i] <- m[i,j] - m[i-1,j]
if(j < ncol(m) && i >= ec[j]-N+2) { # we have not reached the last contract and we have not reached the last holding day
j <- j + 1;
rollover[i] <- TRUE
ret[i] <- log(m[i,j] / m[i-1,j])
difference[i] <- m[i,j] - m[i-1,j]
}
close[i] <- m[i,j]
adjclose[i] <- m[i,j] - m[i-1,j]
contract[i] <- colnames(m)[j]
maturity[i] <- ec[j] - i
if(j < ncol(m)) {
k <- ifelse(j+1 > ncol(m), ncol(m), j+1 )
basis[i] <- log(m[i,j]) - log(m[i,k]) # simple log difference between contracts
basis_price[i] <- m[i,j] - m[i,k] # simple price difference between contracts
basis_distance[i] <- ym[k] - ym[j] # distance in months
basis_gordon[i] <- period * ((m[i,j] / m[i,k]) - 1) / ((ec[k]-i) - (ec[j]-i)) # as defined in Gorton et al. 2013
#spot[i] <-  m[i,j] * (1 + basis[i] / period * (ec[j]-i)) # as defined in Gorton et al. 2013
}
if(!(is.na(m[i,j]) | is.nan(m[i,j]))) {
last <- m[i,j]
if(is.na(first))
first <- m[i,j]
}
adjclose[is.na(adjclose)] <- 0
adjclose <- first + cumsum(adjclose)
adjclose <- adjclose + (last - adjclose[length(adjclose)])
final <- data.frame(
Date=df[,1], Close=close, AdjClose=adjclose, Return=ret, Difference=difference, Adjs=adjclose-close,
Contract=contract, Rollover=rollover, Maturity=maturity,
Basis=basis, Basis_price=basis_price, Basis_gordon=basis_gordon, Basis_distance=basis_distance, Spot=spot )
delete <- c()
for(i in 1:nrow(m)) # if a row wall all NAs (probably because it just stored a Nan) in the original data, remove it from the final result
if(all(is.na(m[i,])))
delete <- c(delete, i)
if(length(delete) > 0)
final <- final[-delete,]
return(final)
}
# create a backadjusted future spread contract
backadjust_spread <- function(df1, df2, N1=1, N2=1, mult=c(1,1), func=backadjust_future) {
c1 <- func(df1, N1)
c2 <- func(df2, N2)
z <- merge(c1, c2, by="Date", all=TRUE)
z$Adjs.x <- zoo::na.locf.default(z$Adjs.x, na.rm = FALSE, fromLast = TRUE)
z$Adjs.y <- zoo::na.locf.default(z$Adjs.y, na.rm = FALSE, fromLast = TRUE)
close <- z$Close.x*mult[1] - z$Close.y*mult[2]
backadj <- close + (z$Adjs.x*mult[1] - z$Adjs.y*mult[2])
z$Return.x <- z$Return.x * mult
z$Return.y <- z$Return.y * mult
return(data.frame(Date=z[,1], Close1=z$Close.x, Close2=z$Close.y,
Backadj1=z$AdjClose.x, Backadj2=z$AdjClose.y,
Rollover1=z$Rollover.x, Rollover2=z$Rollover.y,
Adj1=z$Adjs.x , Adj2=z$Adjs.y,
Return1=z$Return.x, Return2=z$Return.y,
Close=close, AdjClose=backadj, Return=z$Return.x-z$Return.y))
}
# Load future contracts, we expect all the contract to be in the directory, and the contract order in the file order.txt
load_cash_contract <- function(f) {
df <- read_csv(f, show_col_types = FALSE) %>%
select(Time, Last) %>% rename(Date=Time) %>% mutate(Date = as.Date(Date, format="%m/%d/%Y")) %>%    arrange(f, Date) %>%
mutate(Symbol=toupper(sub("y00.csv", "", f)), Return = c(0,diff(log(Last))) )
return(df)
}
# build up the rollover curve given a df from load_future_contracts, assume only N x T data.frame
rollover_curve <- function(df, forward=2, lm=FALSE) {
curve_diff <- rep(NA, nrow(df))
curve_ret1 <- rep(NA, nrow(df))
curve_ret2 <- rep(NA, nrow(df))
if(lm) {
curve_lm <- rep(NA, nrow(df))
curve_err <- rep(NA, nrow(df))
}
m <- log(as.matrix(df[,-1]))
for(i in 2:nrow(m)) {
b <- na.omit(m[i, ])
b_prev <- na.omit(m[i-1, ])
if(length(b) < forward)
next
b <- b[1:forward]
x <- 1:length(b)
if(lm) {
fit <- lm(b ~ x)
curve_lm[i] <- -12*coef(fit)[2]
curve_err[i] <- sqrt(diag(vcov(fit)))[2]
}
curve_diff[i] <- (b[forward] - b[1])
}
if(lm)
res <- data.frame(Date=df$Date, Basis=curve_diff, Lm=curve_lm, Err=curve_err)
else
res <- data.frame(Date=df$Date, Basis=curve_diff)
return(res)
}
# create a intramarket future spread
intramarket_spread <- function(df, N=1, D=1) {
m <- as.matrix(df[,-1]) # the first column is supposed to be the Date
d <- as.Date(df[,1])
sc <- rep(NA, ncol(m))
ec <- rep(NA, ncol(m))
for(j in 1:ncol(m)) {
a <- which(is.nan(m[,j]))
sc[j] <- a[1]+1
ec[j] <- a[2]-1
}
j <- 1;
i <- 1;
rollover <- rep(NA, nrow(m));
spread <- rep(NA, nrow(m));
ret <- rep(NA, nrow(m));
for(i in 2:nrow(m)) {
ret[i] <- log(m[i,j] / m[i-1,j])
if(j < ncol(m))
spread[i] <- m[i,j] - m[i,j+D]
if(j < (ncol(m)-D) && (i >= ec[j]-N+2)) {
j <- j + 1;
rollover[i] <- TRUE
ret[i] <- log(m[i,j] / m[i-1,j])
spread[i] <- m[i,j] - m[i,j+D]
}
return(data.frame(Date=df[,1], Spread=spread, Return=ret, Rollover=rollover))
}
setwd( "/home/marco/trading/Historical Data/Barchart/")
to_load <- read_csv("Instrument_List.csv")
# load the full futures contracts
Futures <- list()
for(i in 1:nrow(to_load) ){
symbol <- as.character(to_load[i,1])
if(!is.null(Futures[[symbol]]))
next
print(symbol)
dir <- as.character(to_load[i,2])
Futures[[symbol]] <- load_future_contracts(symbol, dir)
}
library(data.table)
# load the full futures contracts
Futures <- list()
for(i in 1:nrow(to_load) ){
symbol <- as.character(to_load[i,1])
if(!is.null(Futures[[symbol]]))
next
print(symbol)
dir <- as.character(to_load[i,2])
Futures[[symbol]] <- load_future_contracts(symbol, dir)
}
# Backadjust the prices
BackAdj <- list()
for(symbol in names(Futures)) {
if(!is.null(BackAdj[[symbol]])) {
next
}
print(symbol)
BackAdj[[symbol]] <- backadjust_future(Futures[[symbol]], N=2)
BackAdj[[symbol]]$Symbol <- symbol
BackAdj[[symbol]]$Name <- to_load$Name[to_load$Symbol == symbol]
BackAdj[[symbol]]$Class <- to_load$Class[to_load$Symbol == symbol]
}
write_rds(Futures, "/home/marco/trading/Historical Data/Barchart/Futures.RDS")
