# N: days to expiration to rollover
backadjust_future <- function(df, N=1, period=365) {
month_code <- setNames(1:12,c("f", "g", "h", "j", "k", "m", "n", "q", "u", "v", "x", "z"))
m <- as.matrix(df[,-1]) # the first column is supposed to be the Date
d <- as.Date(df[,1]) # dates
sc <- rep(NA, ncol(m)) # contracts starts
ec <- rep(NA, ncol(m)) # contracts ends
ym <- rep(yearmonth(0), ncol(m)) # contracts name in yearmonth
for(j in 1:ncol(m)) {
a <- which(is.nan(m[,j]))
sc[j] <- a[1]+1
ec[j] <- a[2]-1
code_j <- colnames(m)[j]
year_j <- as.numeric(substr(code_j, nchar(code_j)-1, nchar(code_j))); year_j <- ifelse(year_j > 40, year_j + 1900, year_j + 2000)
month_j <- as.numeric(month_code[substr(code_j, nchar(code_j)-2, nchar(code_j)-2)]);
ym[j] <- yearmonth(paste0(year_j, "-", month_j))
}
j <- 1;
i <- 1;
adjclose <- rep(NA, nrow(m)); # the final continous backadjusted price
close <- rep(NA, nrow(m)); # the current contract unadjusted price
basis <- rep(NA, nrow(m)); # basis as log differences
basis_price <- rep(NA, nrow(m)); # basis as price differences
basis_distance <- rep(NA, nrow(m)); # months between basis contracts
basis_gordon <- rep(NA, nrow(m)); # months between basis contracts as defined in gorton et. al 2013
spot <- rep(NA, nrow(m)); # implied spot price as defined in gorton et. al 2013
rollover <- rep(FALSE, nrow(m)); # rollover dates
contract <- rep(NA, nrow(m)); # current contract
maturity <- rep(NA, nrow(m)); # days to maturity
difference <- rep(NA, nrow(m)); # returns considering rollover (in price differences)
ret <- rep(NA, nrow(m)); # returns considering rollover (in log price)
constant <- rep(NA, nrow(m)); # hypothetical constant maturity contract (using the next two contracts)
constant_ret <- rep(NA, nrow(m)); # hypothetical constant maturity contract log return (using the next two contracts)
first <- NA # first value to use to adjust
last <- 0 # last value to use to adjust
for(i in 3:(nrow(m)-1)) { # this assume first and last entries are Inf
ret[i] <- log(m[i,j] / m[i-1,j])
difference[i] <- m[i,j] - m[i-1,j]
# we have not reached the last contract but we have reached the last holding day, we roll to the next contract
if(j < ncol(m) && i >= ec[j]-N+2) {
j <- j + 1;
rollover[i] <- TRUE
ret[i] <- log(m[i,j] / m[i-1,j])
difference[i] <- m[i,j] - m[i-1,j]
}
close[i] <- m[i,j]
adjclose[i] <- m[i,j] - m[i-1,j]
contract[i] <- colnames(m)[j]
maturity[i] <- ec[j] - i
# we have not reached the last contract
if(j < ncol(m)) {
k <- ifelse(j+1 > ncol(m), ncol(m), j+1 )
basis[i] <- log(m[i,j]) - log(m[i,k]) # simple log difference between contracts
basis_price[i] <- m[i,j] - m[i,k] # simple price difference between contracts
basis_distance[i] <- ym[k] - ym[j] # distance in months
basis_gordon[i] <- period * ((m[i,j] / m[i,k]) - 1) / ((ec[k]-i) - (ec[j]-i)) # as defined in Gorton et al. 2013
spot[i] <-  m[i,j] * (1 + basis[i] / period * (ec[j]-i)) # as defined in Gorton et al. 2013
maturity1 <- maturity[i] - 1
maturity2 <- ec[j+1] - i - 1
dist1 <- abs(maturity1 - 30)
dist2 <- abs(maturity2 - 30)
if(min(dist1, dist2) >= 30)
w <- 1
else
w <- ((dist1 + dist2) - dist1) / (dist1 + dist2)
constant[i] <- w * m[i,j] + (1-w) * m[i,j+1]
constant_ret[i] <- w * log(m[i,j]/m[i-1,j]) + (1-w) * log(m[i,j+1]/m[i-1,j+1])
}
if(!(is.na(m[i,j]) | is.nan(m[i,j]))) {
last <- m[i,j]
if(is.na(first))
first <- m[i,j]
}
# backadjust the price
adjclose[is.na(adjclose)] <- 0
adjclose <- first + cumsum(adjclose)
adjclose <- adjclose + (last - adjclose[length(adjclose)])
# the final data frame
final <- data.frame(
Date=df[,1], Close=close, AdjClose=adjclose, Return=ret, Difference=difference, Adjs=adjclose-close,
Contract=contract, Rollover=rollover, Maturity=maturity,
Basis=basis, Basis_price=basis_price, Basis_gordon=basis_gordon, Basis_distance=basis_distance, Spot=spot, Constant=constant, Constant_return=constant_ret)
# if a row has all NAs (probably because it just stored a Nan in the original data), remove it from the final result
delete <- c()
for(i in 1:nrow(m))
if(all(is.na(m[i,])))
delete <- c(delete, i)
if(length(delete) > 0)
final <- final[-delete,]
return(final)
}
# create a backadjusted future contract from futures contracts in wide format as returned by load_future_contracts_wide
# N: days to expiration to rollover
backadjust_future <- function(df, N=1, period=365) {
month_code <- setNames(1:12,c("f", "g", "h", "j", "k", "m", "n", "q", "u", "v", "x", "z"))
m <- as.matrix(df[,-1]) # the first column is supposed to be the Date
d <- as.Date(df[,1]) # dates
sc <- rep(NA, ncol(m)) # contracts starts
ec <- rep(NA, ncol(m)) # contracts ends
ym <- rep(yearmonth(0), ncol(m)) # contracts name in yearmonth
for(j in 1:ncol(m)) {
a <- which(is.nan(m[,j]))
sc[j] <- a[1]+1
ec[j] <- a[2]-1
code_j <- colnames(m)[j]
year_j <- as.numeric(substr(code_j, nchar(code_j)-1, nchar(code_j))); year_j <- ifelse(year_j > 40, year_j + 1900, year_j + 2000)
month_j <- as.numeric(month_code[substr(code_j, nchar(code_j)-2, nchar(code_j)-2)]);
ym[j] <- yearmonth(paste0(year_j, "-", month_j))
}
j <- 1;
i <- 1;
adjclose <- rep(NA, nrow(m)); # the final continous backadjusted price
close <- rep(NA, nrow(m)); # the current contract unadjusted price
basis <- rep(NA, nrow(m)); # basis as log differences
basis_price <- rep(NA, nrow(m)); # basis as price differences
basis_distance <- rep(NA, nrow(m)); # months between basis contracts
basis_gordon <- rep(NA, nrow(m)); # months between basis contracts as defined in gorton et. al 2013
spot <- rep(NA, nrow(m)); # implied spot price as defined in gorton et. al 2013
rollover <- rep(FALSE, nrow(m)); # rollover dates
contract <- rep(NA, nrow(m)); # current contract
maturity <- rep(NA, nrow(m)); # days to maturity
difference <- rep(NA, nrow(m)); # returns considering rollover (in price differences)
ret <- rep(NA, nrow(m)); # returns considering rollover (in log price)
constant <- rep(NA, nrow(m)); # hypothetical constant maturity contract (using the next two contracts)
constant_ret <- rep(NA, nrow(m)); # hypothetical constant maturity contract log return (using the next two contracts)
first <- NA # first value to use to adjust
last <- 0 # last value to use to adjust
for(i in 3:(nrow(m)-1)) { # this assume first and last entries are Inf
ret[i] <- log(m[i,j] / m[i-1,j])
difference[i] <- m[i,j] - m[i-1,j]
# we have not reached the last contract but we have reached the last holding day, we roll to the next contract
if(j < ncol(m) && i >= ec[j]-N+2) {
j <- j + 1;
rollover[i] <- TRUE
ret[i] <- log(m[i,j] / m[i-1,j])
difference[i] <- m[i,j] - m[i-1,j]
}
close[i] <- m[i,j]
if((j+3) < ncol(m))
adjclose[i] <- m[i,j+2] - m[i-1,j+3]
contract[i] <- colnames(m)[j]
maturity[i] <- ec[j] - i
# we have not reached the last contract
if(j < ncol(m)) {
k <- ifelse(j+1 > ncol(m), ncol(m), j+1 )
basis[i] <- log(m[i,j]) - log(m[i,k]) # simple log difference between contracts
basis_price[i] <- m[i,j] - m[i,k] # simple price difference between contracts
basis_distance[i] <- ym[k] - ym[j] # distance in months
basis_gordon[i] <- period * ((m[i,j] / m[i,k]) - 1) / ((ec[k]-i) - (ec[j]-i)) # as defined in Gorton et al. 2013
spot[i] <-  m[i,j] * (1 + basis[i] / period * (ec[j]-i)) # as defined in Gorton et al. 2013
maturity1 <- maturity[i] - 1
maturity2 <- ec[j+1] - i - 1
dist1 <- abs(maturity1 - 30)
dist2 <- abs(maturity2 - 30)
if(min(dist1, dist2) >= 30)
w <- 1
else
w <- ((dist1 + dist2) - dist1) / (dist1 + dist2)
constant[i] <- w * m[i,j] + (1-w) * m[i,j+1]
constant_ret[i] <- w * log(m[i,j]/m[i-1,j]) + (1-w) * log(m[i,j+1]/m[i-1,j+1])
}
if(!(is.na(m[i,j]) | is.nan(m[i,j]))) {
last <- m[i,j]
if(is.na(first))
first <- m[i,j]
}
# backadjust the price
adjclose[is.na(adjclose)] <- 0
adjclose <- first + cumsum(adjclose)
adjclose <- adjclose + (last - adjclose[length(adjclose)])
# the final data frame
final <- data.frame(
Date=df[,1], Close=close, AdjClose=adjclose, Return=ret, Difference=difference, Adjs=adjclose-close,
Contract=contract, Rollover=rollover, Maturity=maturity,
Basis=basis, Basis_price=basis_price, Basis_gordon=basis_gordon, Basis_distance=basis_distance, Spot=spot, Constant=constant, Constant_return=constant_ret)
# if a row has all NAs (probably because it just stored a Nan in the original data), remove it from the final result
delete <- c()
for(i in 1:nrow(m))
if(all(is.na(m[i,])))
delete <- c(delete, i)
if(length(delete) > 0)
final <- final[-delete,]
return(final)
}
w <- backadjust_future(Futures[[symbol]], N=2)
plot.ts(w$AdjClose)
# create a backadjusted future contract from futures contracts in wide format as returned by load_future_contracts_wide
# N: days to expiration to rollover
backadjust_future <- function(df, N=1, period=365) {
month_code <- setNames(1:12,c("f", "g", "h", "j", "k", "m", "n", "q", "u", "v", "x", "z"))
m <- as.matrix(df[,-1]) # the first column is supposed to be the Date
d <- as.Date(df[,1]) # dates
sc <- rep(NA, ncol(m)) # contracts starts
ec <- rep(NA, ncol(m)) # contracts ends
ym <- rep(yearmonth(0), ncol(m)) # contracts name in yearmonth
for(j in 1:ncol(m)) {
a <- which(is.nan(m[,j]))
sc[j] <- a[1]+1
ec[j] <- a[2]-1
code_j <- colnames(m)[j]
year_j <- as.numeric(substr(code_j, nchar(code_j)-1, nchar(code_j))); year_j <- ifelse(year_j > 40, year_j + 1900, year_j + 2000)
month_j <- as.numeric(month_code[substr(code_j, nchar(code_j)-2, nchar(code_j)-2)]);
ym[j] <- yearmonth(paste0(year_j, "-", month_j))
}
j <- 1;
i <- 1;
adjclose <- rep(NA, nrow(m)); # the final continous backadjusted price
close <- rep(NA, nrow(m)); # the current contract unadjusted price
basis <- rep(NA, nrow(m)); # basis as log differences
basis_price <- rep(NA, nrow(m)); # basis as price differences
basis_distance <- rep(NA, nrow(m)); # months between basis contracts
basis_gordon <- rep(NA, nrow(m)); # months between basis contracts as defined in gorton et. al 2013
spot <- rep(NA, nrow(m)); # implied spot price as defined in gorton et. al 2013
rollover <- rep(FALSE, nrow(m)); # rollover dates
contract <- rep(NA, nrow(m)); # current contract
maturity <- rep(NA, nrow(m)); # days to maturity
difference <- rep(NA, nrow(m)); # returns considering rollover (in price differences)
ret <- rep(NA, nrow(m)); # returns considering rollover (in log price)
constant <- rep(NA, nrow(m)); # hypothetical constant maturity contract (using the next two contracts)
constant_ret <- rep(NA, nrow(m)); # hypothetical constant maturity contract log return (using the next two contracts)
first <- NA # first value to use to adjust
last <- 0 # last value to use to adjust
for(i in 3:(nrow(m)-1)) { # this assume first and last entries are Inf
ret[i] <- log(m[i,j] / m[i-1,j])
difference[i] <- m[i,j] - m[i-1,j]
# we have not reached the last contract but we have reached the last holding day, we roll to the next contract
if(j < ncol(m) && i >= ec[j]-N+2) {
j <- j + 1;
rollover[i] <- TRUE
ret[i] <- log(m[i,j] / m[i-1,j])
difference[i] <- m[i,j] - m[i-1,j]
}
close[i] <- m[i,j]
if((j+3) < ncol(m))
adjclose[i] <- m[i,j+1] - m[i-1,j+2]
contract[i] <- colnames(m)[j]
maturity[i] <- ec[j] - i
# we have not reached the last contract
if(j < ncol(m)) {
k <- ifelse(j+1 > ncol(m), ncol(m), j+1 )
basis[i] <- log(m[i,j]) - log(m[i,k]) # simple log difference between contracts
basis_price[i] <- m[i,j] - m[i,k] # simple price difference between contracts
basis_distance[i] <- ym[k] - ym[j] # distance in months
basis_gordon[i] <- period * ((m[i,j] / m[i,k]) - 1) / ((ec[k]-i) - (ec[j]-i)) # as defined in Gorton et al. 2013
spot[i] <-  m[i,j] * (1 + basis[i] / period * (ec[j]-i)) # as defined in Gorton et al. 2013
maturity1 <- maturity[i] - 1
maturity2 <- ec[j+1] - i - 1
dist1 <- abs(maturity1 - 30)
dist2 <- abs(maturity2 - 30)
if(min(dist1, dist2) >= 30)
w <- 1
else
w <- ((dist1 + dist2) - dist1) / (dist1 + dist2)
constant[i] <- w * m[i,j] + (1-w) * m[i,j+1]
constant_ret[i] <- w * log(m[i,j]/m[i-1,j]) + (1-w) * log(m[i,j+1]/m[i-1,j+1])
}
if(!(is.na(m[i,j]) | is.nan(m[i,j]))) {
last <- m[i,j]
if(is.na(first))
first <- m[i,j]
}
# backadjust the price
adjclose[is.na(adjclose)] <- 0
adjclose <- first + cumsum(adjclose)
adjclose <- adjclose + (last - adjclose[length(adjclose)])
# the final data frame
final <- data.frame(
Date=df[,1], Close=close, AdjClose=adjclose, Return=ret, Difference=difference, Adjs=adjclose-close,
Contract=contract, Rollover=rollover, Maturity=maturity,
Basis=basis, Basis_price=basis_price, Basis_gordon=basis_gordon, Basis_distance=basis_distance, Spot=spot, Constant=constant, Constant_return=constant_ret)
# if a row has all NAs (probably because it just stored a Nan in the original data), remove it from the final result
delete <- c()
for(i in 1:nrow(m))
if(all(is.na(m[i,])))
delete <- c(delete, i)
if(length(delete) > 0)
final <- final[-delete,]
return(final)
}
q <- backadjust_future(Futures[[symbol]], N=2)
plot.ts(q$AdjClose)
plot.ts(w$AdjClose-q$AdjClose)
# create a backadjusted future contract from futures contracts in wide format as returned by load_future_contracts_wide
# N: days to expiration to rollover
backadjust_future <- function(df, N=1, period=365) {
month_code <- setNames(1:12,c("f", "g", "h", "j", "k", "m", "n", "q", "u", "v", "x", "z"))
m <- as.matrix(df[,-1]) # the first column is supposed to be the Date
d <- as.Date(df[,1]) # dates
sc <- rep(NA, ncol(m)) # contracts starts
ec <- rep(NA, ncol(m)) # contracts ends
ym <- rep(yearmonth(0), ncol(m)) # contracts name in yearmonth
for(j in 1:ncol(m)) {
a <- which(is.nan(m[,j]))
sc[j] <- a[1]+1
ec[j] <- a[2]-1
code_j <- colnames(m)[j]
year_j <- as.numeric(substr(code_j, nchar(code_j)-1, nchar(code_j))); year_j <- ifelse(year_j > 40, year_j + 1900, year_j + 2000)
month_j <- as.numeric(month_code[substr(code_j, nchar(code_j)-2, nchar(code_j)-2)]);
ym[j] <- yearmonth(paste0(year_j, "-", month_j))
}
j <- 1;
i <- 1;
adjclose <- rep(NA, nrow(m)); # the final continous backadjusted price
close <- rep(NA, nrow(m)); # the current contract unadjusted price
basis <- rep(NA, nrow(m)); # basis as log differences
basis_price <- rep(NA, nrow(m)); # basis as price differences
basis_distance <- rep(NA, nrow(m)); # months between basis contracts
basis_gordon <- rep(NA, nrow(m)); # months between basis contracts as defined in gorton et. al 2013
spot <- rep(NA, nrow(m)); # implied spot price as defined in gorton et. al 2013
rollover <- rep(FALSE, nrow(m)); # rollover dates
contract <- rep(NA, nrow(m)); # current contract
maturity <- rep(NA, nrow(m)); # days to maturity
difference <- rep(NA, nrow(m)); # returns considering rollover (in price differences)
ret <- rep(NA, nrow(m)); # returns considering rollover (in log price)
constant <- rep(NA, nrow(m)); # hypothetical constant maturity contract (using the next two contracts)
constant_ret <- rep(NA, nrow(m)); # hypothetical constant maturity contract log return (using the next two contracts)
first <- NA # first value to use to adjust
last <- 0 # last value to use to adjust
for(i in 3:(nrow(m)-1)) { # this assume first and last entries are Inf
ret[i] <- log(m[i,j] / m[i-1,j])
difference[i] <- m[i,j] - m[i-1,j]
# we have not reached the last contract but we have reached the last holding day, we roll to the next contract
if(j < ncol(m) && i >= ec[j]-N+2) {
j <- j + 1;
rollover[i] <- TRUE
ret[i] <- log(m[i,j] / m[i-1,j])
difference[i] <- m[i,j] - m[i-1,j]
}
close[i] <- m[i,j]
adjclose[i] <- m[i,j] - m[i-1,j]
contract[i] <- colnames(m)[j]
maturity[i] <- ec[j] - i
# we have not reached the last contract
if(j < ncol(m)) {
k <- ifelse(j+1 > ncol(m), ncol(m), j+1 )
basis[i] <- log(m[i,j]) - log(m[i,k]) # simple log difference between contracts
basis_price[i] <- m[i,j] - m[i,k] # simple price difference between contracts
basis_distance[i] <- ym[k] - ym[j] # distance in months
basis_gordon[i] <- period * ((m[i,j] / m[i,k]) - 1) / ((ec[k]-i) - (ec[j]-i)) # as defined in Gorton et al. 2013
spot[i] <-  m[i,j] * (1 + basis[i] / period * (ec[j]-i)) # as defined in Gorton et al. 2013
maturity1 <- maturity[i] - 1
maturity2 <- ec[j+1] - i - 1
dist1 <- abs(maturity1 - 30)
dist2 <- abs(maturity2 - 30)
if(min(dist1, dist2) >= 30)
w <- 1
else
w <- ((dist1 + dist2) - dist1) / (dist1 + dist2)
constant[i] <- w * m[i,j] + (1-w) * m[i,j+1]
constant_ret[i] <- w * log(m[i,j]/m[i-1,j]) + (1-w) * log(m[i,j+1]/m[i-1,j+1])
}
if(!(is.na(m[i,j]) | is.nan(m[i,j]))) {
last <- m[i,j]
if(is.na(first))
first <- m[i,j]
}
# backadjust the price
adjclose[is.na(adjclose)] <- 0
adjclose <- first + cumsum(adjclose)
adjclose <- adjclose + (last - adjclose[length(adjclose)])
# the final data frame
final <- data.frame(
Date=df[,1], Close=close, AdjClose=adjclose, Return=ret, Difference=difference, Adjs=adjclose-close,
Contract=contract, Rollover=rollover, Maturity=maturity,
Basis=basis, Basis_price=basis_price, Basis_gordon=basis_gordon, Basis_distance=basis_distance, Spot=spot, Constant=constant, Constant_return=constant_ret)
# if a row has all NAs (probably because it just stored a Nan in the original data), remove it from the final result
delete <- c()
for(i in 1:nrow(m))
if(all(is.na(m[i,])))
delete <- c(delete, i)
if(length(delete) > 0)
final <- final[-delete,]
return(final)
}
a
plot.ts(a$Back - a$Front)
plot.ts(a$Front - a$Back)
plot.ts(a$Back - a$Front)
BackAdj$VI$Basis %>% plot.ts
a$SpreadLog %>% plot.ts
build_spreads(df, C = list(c(1,2)), expiry_df=expiry_df)  -> a
head(df)
a$SpreadLog %>% plot.ts
BackAdj$VI$Basis %>% plot.ts
build_spreads(df, C = list(c(1,2)), expiry_df=expiry_df) %>% filter(DTE>0) -> a
a$SpreadLog %>% plot.ts
BackAdj$VI$Basis %>% plot.ts
a$SpreadLog %>% tail(500) %>% plot.ts
tail(a)
tail(BackAdj$VI$Basis)
tail(BackAdj$VI)
head(BackAdj$VI)
head(a)
dim(a)
dim(BackAdj$VI$Basis)
dim(BackAdj$VI)
merge(a, BackAdj$VI, by="Date") -> b
head(b)
matplot2(cbind(b$SpreadLog, b$Basis) %>% tail(500))
matplot2(cbind(b$SpreadLog, b$Basis))
matplot2(cbind(b$SpreadLog, b$Basis) %>% tail(1500))
b$SpreadLog %>% Ac
b$SpreadLog %>% Acf
b$SpreadLog %>% diff %>% Acf
plot.ts(Spreads$ES$SpreadLog)
plot.ts(Spreads$ES$SpreadLog %>% tail(500))
plot.ts(Spreads$ES$SpreadLog %>% tail(1500))
plot.ts(Spreads$CL$SpreadLog %>% tail(1500))
plot.ts(Spreads$CL$SpreadLog)
plot.ts(Spreads$CL$SpreadPoint)
symbol <- "CL"
symbol <- "CrudeOil"
name <- "CrudeOil"
symbol <- "CL"
symbol <- as.character(to_load[i,1])
name <- as.character(to_load[i,2])
print(paste(symbol, name))
dir <- paste0("/home/marco/trading/HistoricalData/Barchart/", name)
df <- load_future_contracts_long(symbol, dir)
Futures_long[[symbol]] <- df
expiry_df <- load_expiry_file(paste0(dir, "/", "expirations.txt"))
# calculate the contracts combinations to pass to build_spreads
contracts <- df %>%  group_by(Symbol) %>% arrange(Date) %>% group_by(Date) %>% mutate(Contract = row_number())
max_level <- min(c(5, max(contracts$Contract)))
contract_spreads <- cbind(1:(max_level-1), 2:max_level) %>% apply(., 1, c, simplify = F)
Spreads[[symbol]] <- build_spreads(df, C = contract_spreads, expiry_df=expiry_df)
plot.ts(Spreads$CL %>% filter(Contracts=="c_23") %>% SpreadPoint)
plot.ts(Spreads$CL %>% filter(Contracts=="c_23") %>% pull(SpreadPoint))
plot.ts(Spreads$CL %>% filter(Contracts=="c_23") %>% pull(SpreadLog))
plot.ts(Spreads$CL %>% filter(Contracts=="c_23") %>% pull(SpreadLog) %>% tail(500))
plot.ts(Spreads$ZW %>% filter(Contracts=="c_23") %>% pull(SpreadLog) %>% tail(500))
Spreads$ZW %>% filter(Contracts=="c_23") %>% head
Spreads$ZW %>% filter(Contracts=="c_23") %>% tail(252) %>% head
Spreads$ZW %>% filter(Contracts=="c_23") %>% tail(500) %>% head
Spreads$ZW %>% filter(Contracts=="c_23") %>% tail(200) %>% head
Spreads$ZW %>% filter(Contracts=="c_23") %>% tail(180) %>% head
Spreads$ZW %>% filter(Contracts=="c_23") %>% tail(200) %>% pull(SpreadPoints) %>% plot.ts
Spreads$ZW %>% filter(Contracts=="c_23") %>% tail(200) %>% pull(SpreadPoint) %>% plot.ts
Spreads$ZW %>% filter(Contracts=="c_23") %>% tail(200) %>% pull(SpreadPoint) %>% na.omit %>% plot.ts
Spreads$ZW %>% filter(Contracts=="c_23") %>% tail(200) %>% pull(SpreadPoint) %>% `*`(-1) %>% na.omit %>% plot.ts
Spreads$ZW %>% filter(Contracts=="c_23") %>% tail(200) %>% pull(SpreadPoint) %>% na.omit %>% plot.ts
Spreads$ZW %>% filter(Contracts=="c_23") %>% tail(200) %>% pull(SpreadPoint) %>% tail
Spreads$ZW %>% filter(Contracts=="c_23") %>% tail(200)  %>% tail
Spreads$ZW %>% filter(Contracts=="c_23") %>% tail(200)  %>% head
Spreads$ZW %>% filter(Contracts=="c_23") %>% tail(200) %>% pull(SpreadPoint) %>% `+`(20) %>% na.omit %>% plot.ts
# build spreads from futures contracts in long format as returned by load_future_contracts_long
build_spreads <- function(df, C=list(c(1,2)), expiry_df=NULL) {
N <- max(sapply(C, max))
front_c <- sapply(C, function(x)x[1])
back_c <- sapply(C, function(x)x[2])
# Calculate DTE if expiry file is provided, otherwise use contract length (for non-yet expired contract this will return a wrong DTE)
if(is.null(expiry_df))
contracts <- df %>%  group_by(Symbol) %>% arrange(Date) %>% mutate(DTE = (n()-1):0)
else {
contracts <- left_join(df, expiry_df %>% rename(Expiry=Date), by="Symbol") %>%  group_by(Symbol) %>% arrange(Date) %>% mutate(DTE = as.numeric(Expiry - Date))
}
contracts <- contracts %>% group_by(Date) %>% mutate(Contract = row_number()) %>%  filter(Contract <= N)
if(max(contracts$Contract) < N)
stop(paste("Max contract is lower than supplied", N))
# Turn the prices and returns into a wide format
symbols <- contracts %>%  select(Symbol, Date, Contract) %>%
pivot_wider(names_from = Contract, names_prefix = 'c_', values_from = Symbol)
prices <- contracts %>%  select(Symbol, Date, Contract, Close) %>%
pivot_wider(id_cols = -Symbol, names_from = Contract, names_prefix = 'c_', values_from = Close)
dte <- contracts %>%  select(Symbol, Date, Contract, DTE) %>%
pivot_wider(id_cols = -Symbol, names_from = Contract, names_prefix = 'c_', values_from = DTE)
returns <- contracts %>% select(Symbol, Date, Contract, Return) %>%
pivot_wider(id_cols = -Symbol, names_from = Contract, names_prefix = 'c_', values_from = Return)
volume <- contracts %>%   select(Symbol, Date, Contract, Volume) %>%
pivot_wider(id_cols = -Symbol, names_from = Contract, names_prefix = 'c_', values_from = Volume)
oi <- contracts %>%    select(Symbol, Date, Contract, `Open Int`) %>%
pivot_wider(id_cols = -Symbol, names_from = Contract, names_prefix = 'c_', values_from = `Open Int`)
expiry <- contracts %>%    select(Symbol, Date, Contract, Expiry) %>%
pivot_wider(id_cols = -Symbol, names_from = Contract, names_prefix = 'c_', values_from = Expiry)
dates <- prices[,1]
labels <- paste0("c_",paste0(front_c, back_c))
symbol1 <- data.frame(dates, symbols[, front_c+1])
symbol2 <- data.frame(dates, symbols[, back_c+1])
price1 <- data.frame(dates, prices[, front_c+1])
price2 <- data.frame(dates, prices[, back_c+1])
return1 <- data.frame(dates, returns[, front_c+1])
return2 <- data.frame(dates, returns[, back_c+1])
dtes <- data.frame(dates, dte[, front_c+1])
volumes <- data.frame(dates, volume[, front_c+1] + volume[, back_c+1])
ois <- data.frame(dates, oi[, front_c+1] + oi[, back_c+1])
expiries <- data.frame(dates, expiry[, front_c+1])
dtes <- data.frame(dates, dte[, front_c+1])
spreadpoints <- data.frame(dates, price2[,-1] - price1[,-1])
spreadlogs <- data.frame(dates, log(price2[,-1] / price1[,-1]))
spreadreturns <- data.frame(dates,  returns[,front_c+1] - returns[,back_c+1])
colnames(symbol1) <- colnames(symbol2) <-
colnames(price1) <- colnames(price2) <- colnames(return1) <- colnames(return2)  <-
colnames(spreadpoints) <-   colnames(spreadlogs) <- colnames(spreadreturns) <-
colnames(dtes)  <- colnames(volumes) <- colnames(ois)<- colnames(expiries) <- c("Date", labels)
symbol1_l <- pivot_longer(symbol1, -Date, names_to = "Contracts", values_to = "Symbol1")
symbol2_l <- pivot_longer(symbol2, -Date, names_to = "Contracts", values_to = "Symbol2")
price1_l <- pivot_longer(price1, -Date, names_to = "Contracts", values_to = "Price1")
price2_l <- pivot_longer(price2, -Date, names_to = "Contracts", values_to = "Price2")
return1_l <- pivot_longer(return1, -Date, names_to = "Contracts", values_to = "Return1")
return2_l <- pivot_longer(return2, -Date, names_to = "Contracts", values_to = "Return2")
spreadpoints_l <- pivot_longer(spreadpoints, -Date, names_to = "Contracts", values_to = "SpreadPoint")
spreadlogs_l <- pivot_longer(spreadlogs, -Date, names_to = "Contracts", values_to = "SpreadLog")
spreadreturns_l <- pivot_longer(spreadreturns, -Date, names_to = "Contracts", values_to = "SpreadReturn")
dtes_l <- pivot_longer(dtes, -Date, names_to = "Contracts", values_to = "DTE")
volumes_l <- pivot_longer(volumes, -Date, names_to = "Contracts", values_to = "Volume")
ois_l <- pivot_longer(ois, -Date, names_to = "Contracts", values_to = "OpenInt")
expiries_l <- pivot_longer(expiries, -Date, names_to = "Contracts", values_to = "Expiry")
spreads <- Reduce(function(...) full_join(..., by = c("Date", "Contracts")),
list(symbol1_l, symbol2_l, price1_l, price2_l, return1_l, return2_l,
spreadpoints_l, spreadlogs_l, spreadreturns_l, dtes_l, volumes_l, ois_l, expiries_l)) %>% arrange(Date)
return(spreads)
}
