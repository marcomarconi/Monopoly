alpha[t] <- 1*sin(t*0.1)# a0 + a1 * eta[t-1]^3 + a2 * alpha[t - 1] ;
beta[t] <-  3#b0 + b1 * eta[t]^4 + b2 * beta[t - 1] ;
phi[t] <- 1 / sqrt(2*pi*sigma[t]) * exp(eta[t]^2 - sigma[t])
psi[t] <- 1 + (alpha[t] / 6) * (eta[t]^3 - 3*eta[t]) + ((beta[t] - 3) / 24) * (eta[t]^4 - 6 * eta[t]^2 + 3)
gamma[t] <- 1 + (alpha[t]^2) / 6 + ((beta[t]-3)^2) / 24;
g <- phi[t] *  psi[t]^2 / gamma[t]
alpha[t]
r[t] <- rsn(1, 0, sigma[t], alpha[t])  #rnorm(1, eta[t], psi[t]^2 / gamma[t] * sigma[t])
}
v <- EMA(r^2, 30) %>% sqrt
s1 <- EMA(r^3/v^3, 30)
s2 <- rollapply(data = r, 30, skew, fill=NA, align="right")
plot.ts(cbind(r, alpha, s1, s2))
}
fit <- mod$sample(data = list( T=N, r=r, sigma1=sd(r), gamma1=0), iter_sampling = 100, iter_warmup = 250, chains=1)
a <- fit$draws(variables = "alpha") %>% merge_chains( ) %>% colMeans() %>% as.vector
matplot2(cbind(alpha, a))
fit
{
N <- 500
r <- c(0)
a0 <- 0
a1 <- 0.1
a2 <- 0.9
sigma <- c(0.1)
gamma <- c(0)
delta <- c(0)
alpha <- c(1)
beta <- c(0)
eta <- c(0)
phi <- c(0)
psi <- c(0)
for(t in 2:N) {
sigma[t] <- sigma[t-1]
eta[t] <- r[t-1]/sigma[t-1]
alpha[t] <-  a0 + a1 * eta[t-1]^3 + a2 * alpha[t - 1] ;
beta[t] <-  3#b0 + b1 * eta[t]^4 + b2 * beta[t - 1] ;
phi[t] <- 1 / sqrt(2*pi*sigma[t]) * exp(eta[t]^2 - sigma[t])
psi[t] <- 1 + (alpha[t] / 6) * (eta[t]^3 - 3*eta[t]) + ((beta[t] - 3) / 24) * (eta[t]^4 - 6 * eta[t]^2 + 3)
gamma[t] <- 1 + (alpha[t]^2) / 6 + ((beta[t]-3)^2) / 24;
g <- phi[t] *  psi[t]^2 / gamma[t]
alpha[t]
r[t] <- rsn(1, 0, sigma[t], alpha[t])  #rnorm(1, eta[t], psi[t]^2 / gamma[t] * sigma[t])
}
v <- EMA(r^2, 30) %>% sqrt
s1 <- EMA(r^3/v^3, 30)
s2 <- rollapply(data = r, 30, skew, fill=NA, align="right")
plot.ts(cbind(r, alpha, s1, s2))
}
{
N <- 500
r <- c(0)
a0 <- 0
a1 <- 0.1
a2 <- 0.9
sigma <- c(0.1)
gamma <- c(0)
delta <- c(0)
alpha <- c(1)
beta <- c(0)
eta <- c(0)
phi <- c(0)
psi <- c(0)
for(t in 2:N) {
sigma[t] <- sigma[t-1]
eta[t] <- r[t-1]/sigma[t-1]
alpha[t] <-  a0 + a1 * eta[t-1]^3 + a2 * alpha[t - 1] ;
beta[t] <-  3#b0 + b1 * eta[t]^4 + b2 * beta[t - 1] ;
phi[t] <- 1 / sqrt(2*pi*sigma[t]) * exp(eta[t]^2 - sigma[t])
psi[t] <- 1 + (alpha[t] / 6) * (eta[t]^3 - 3*eta[t]) + ((beta[t] - 3) / 24) * (eta[t]^4 - 6 * eta[t]^2 + 3)
gamma[t] <- 1 + (alpha[t]^2) / 6 + ((beta[t]-3)^2) / 24;
g <- phi[t] *  psi[t]^2 / gamma[t]
alpha[t]
r[t] <- rsn(1, 0, sigma[t], alpha[t])  #rnorm(1, eta[t], psi[t]^2 / gamma[t] * sigma[t])
}
v <- EMA(r^2, 30) %>% sqrt
s1 <- EMA(r^3/v^3, 30)
s2 <- rollapply(data = r, 30, skew, fill=NA, align="right")
plot.ts(cbind(r, alpha, s1, s2))
}
{
N <- 500
r <- c(0)
a0 <- 0
a1 <- 0.1
a2 <- 0.9
sigma <- c(0.1)
gamma <- c(0)
delta <- c(0)
alpha <- c(1)
beta <- c(0)
eta <- c(0)
phi <- c(0)
psi <- c(0)
for(t in 2:N) {
sigma[t] <- sigma[t-1]
eta[t] <- r[t-1]/sigma[t-1]
alpha[t] <-  a0 + a1 * eta[t-1]^3 + a2 * alpha[t - 1] ;
beta[t] <-  3#b0 + b1 * eta[t]^4 + b2 * beta[t - 1] ;
phi[t] <- 1 / sqrt(2*pi*sigma[t]) * exp(eta[t]^2 - sigma[t])
psi[t] <- 1 + (alpha[t] / 6) * (eta[t]^3 - 3*eta[t]) + ((beta[t] - 3) / 24) * (eta[t]^4 - 6 * eta[t]^2 + 3)
gamma[t] <- 1 + (alpha[t]^2) / 6 + ((beta[t]-3)^2) / 24;
g <- phi[t] *  psi[t]^2 / gamma[t]
alpha[t]
r[t] <- rsn(1, 0, sigma[t], alpha[t])  #rnorm(1, eta[t], psi[t]^2 / gamma[t] * sigma[t])
}
v <- EMA(r^2, 30) %>% sqrt
s1 <- EMA(r^3/v^3, 30)
s2 <- rollapply(data = r, 30, skew, fill=NA, align="right")
plot.ts(cbind(r, alpha, s1, s2))
}
fit <- mod$sample(data = list( T=N, r=r, sigma1=sd(r), gamma1=0), iter_sampling = 100, iter_warmup = 250, chains=1)
a <- fit$draws(variables = "alpha") %>% merge_chains( ) %>% colMeans() %>% as.vector
matplot2(cbind(alpha, a))
fit
{
N <- 500
r <- c(0)
a0 <- 0
a1 <- 0.1
a2 <- 0.9
sigma <- c(0.5)
gamma <- c(0)
delta <- c(0)
alpha <- c(1)
beta <- c(0)
eta <- c(0)
phi <- c(0)
psi <- c(0)
for(t in 2:N) {
sigma[t] <- sigma[t-1]
eta[t] <- r[t-1]/sigma[t-1]
alpha[t] <-  a0 + a1 * eta[t-1]^3 + a2 * alpha[t - 1] ;
beta[t] <-  3#b0 + b1 * eta[t]^4 + b2 * beta[t - 1] ;
phi[t] <- 1 / sqrt(2*pi*sigma[t]) * exp(eta[t]^2 - sigma[t])
psi[t] <- 1 + (alpha[t] / 6) * (eta[t]^3 - 3*eta[t]) + ((beta[t] - 3) / 24) * (eta[t]^4 - 6 * eta[t]^2 + 3)
gamma[t] <- 1 + (alpha[t]^2) / 6 + ((beta[t]-3)^2) / 24;
g <- phi[t] *  psi[t]^2 / gamma[t]
alpha[t]
r[t] <- rsn(1, 0, sigma[t], alpha[t])  #rnorm(1, eta[t], psi[t]^2 / gamma[t] * sigma[t])
}
v <- EMA(r^2, 30) %>% sqrt
s1 <- EMA(r^3/v^3, 30)
s2 <- rollapply(data = r, 30, skew, fill=NA, align="right")
plot.ts(cbind(r, alpha, s1, s2))
}
fit <- mod$sample(data = list( T=N, r=r, sigma1=sd(r), gamma1=0), iter_sampling = 100, iter_warmup = 250, chains=1)
a <- fit$draws(variables = "alpha") %>% merge_chains( ) %>% colMeans() %>% as.vector
matplot2(cbind(alpha, a))
fit
mod <- cmdstan_model("skew.stan")
fit <- mod$sample(data = list( T=N, r=r, sigma1=sd(r), gamma1=0), iter_sampling = 100, iter_warmup = 250, chains=1)
a <- fit$draws(variables = "alpha") %>% merge_chains( ) %>% colMeans() %>% as.vector
matplot2(cbind(alpha, a))
fit
a <- fit$draws(variables = "alpha") %>% merge_chains( ) %>% colMeans() %>% as.vector
matplot2(cbind(alpha, a))
a <- fit$draws(variables = "beta") %>% merge_chains( ) %>% colMeans() %>% as.vector
matplot2(cbind(alpha, a))
mod <- cmdstan_model("skew.stan")
a <- fit$draws(variables = "alpha") %>% merge_chains( ) %>% colMeans() %>% as.vector
fit <- mod$sample(data = list( T=N, r=r, sigma1=sd(r), gamma1=0), iter_sampling = 100, iter_warmup = 250, chains=1)
fit
a <- fit$draws(variables = "alpha") %>% merge_chains( ) %>% colMeans() %>% as.vector
matplot2(cbind(alpha, a))
matplot2(cbind(alpha, a*10))
matplot2(cbind(alpha, -a*10))
matplot2(cbind(alpha, -a*50))
matplot2(cbind(alpha, -a*100))
matplot2(cbind(alpha, a*100))
matplot2(cbind(alpha, a*100+50))
mod <- cmdstan_model("skew.stan")
fit <- mod$sample(data = list( T=N, r=r, sigma1=sd(r), gamma1=0), iter_sampling = 100, iter_warmup = 250, chains=1)
a <- fit$draws(variables = "alpha") %>% merge_chains( ) %>% colMeans() %>% as.vector
matplot2(cbind(alpha, a))
fit
matplot2(cbind(alpha, a*100+50))
mod <- cmdstan_model("skew.stan")
fit <- mod$sample(data = list( T=N, r=r, sigma1=sd(r), gamma1=0), iter_sampling = 100, iter_warmup = 250, chains=1)
a <- fit$draws(variables = "alpha") %>% merge_chains( ) %>% colMeans() %>% as.vector
matplot2(cbind(alpha, a))
fit
{
N <- 500
r <- c(0)
a0 <- 0
a1 <- 0.1
a2 <- 0.9
sigma <- c(0.5)
gamma <- c(0)
delta <- c(0)
alpha <- c(1)
beta <- c(0)
eta <- c(0)
phi <- c(0)
psi <- c(0)
for(t in 2:N) {
sigma[t] <- sigma[t-1]
eta[t] <- r[t-1]/sigma[t-1]
alpha[t] <-  a0 + a1 * eta[t-1]^3 + a2 * alpha[t - 1] ;
beta[t] <-  3#b0 + b1 * eta[t]^4 + b2 * beta[t - 1] ;
phi[t] <- 1 / sqrt(2*pi*sigma[t]) * exp(eta[t]^2 - sigma[t])
psi[t] <- 1 + (alpha[t] / 6) * (eta[t]^3 - 3*eta[t]) + ((beta[t] - 3) / 24) * (eta[t]^4 - 6 * eta[t]^2 + 3)
gamma[t] <- 1 + (alpha[t]^2) / 6 + ((beta[t]-3)^2) / 24;
g <- phi[t] *  psi[t]^2 / gamma[t]
alpha[t]
r[t] <- rsn(1, 0, sigma[t], -alpha[t])  #rnorm(1, eta[t], psi[t]^2 / gamma[t] * sigma[t])
}
v <- EMA(r^2, 30) %>% sqrt
s1 <- EMA(r^3/v^3, 30)
s2 <- rollapply(data = r, 30, skew, fill=NA, align="right")
plot.ts(cbind(r, alpha, s1, s2))
}
fit <- mod$sample(data = list( T=N, r=r, sigma1=sd(r), gamma1=0), iter_sampling = 100, iter_warmup = 250, chains=1)
a <- fit$draws(variables = "alpha") %>% merge_chains( ) %>% colMeans() %>% as.vector
matplot2(cbind(alpha, a))
fit
plot.ts(cbind(r, alpha, s1, s2))
mod <- cmdstan_model("skew.stan")
fit <- mod$sample(data = list( T=N, r=r, sigma1=sd(r), gamma1=0), iter_sampling = 100, iter_warmup = 250, chains=1)
a <- fit$draws(variables = "alpha") %>% merge_chains( ) %>% colMeans() %>% as.vector
matplot2(cbind(alpha, a))
fit
#TODO:
# minium position in dynamic portfolio: it should be first increment in the greedy algorithm
{
suppressMessages(library(tidyverse))
suppressMessages(library(moments))
suppressMessages(library(TTR))
suppressMessages(library(lubridate))
suppressMessages(library(tsibble))
suppressMessages(library(zoo))
suppressMessages(library(moments))
suppressMessages(library(ggthemes))
suppressMessages(library(data.table))
source("/home/marco/trading/Systems/Common/RiskManagement.R")
}
# Functions
{
# for some reason, scrapped CMC daily data are leaded one day, check for example https://www.cmcmarkets.com/en-gb/instruments/coffee-arabica-jul-2023?search=1
# weekly data is leaded 2 days
load_cmc_cash_data <- function(symbol,  dir, lagged=TRUE){
symbol_dir <- paste0(dir, "/", symbol)
# # load intra-day data
system(paste("cat", paste(list.files(symbol_dir, pattern = "intraday", full.names = TRUE), collapse = " "),  " | sort -u  > _tmp"))
df_intraday <- fread("_tmp", header= FALSE)
file.remove("_tmp")
colnames(df_intraday) <- c("Date", "Close")
df_intraday$Date <- as_date(df_intraday$Date)
df_intraday <- arrange(df_intraday, Date)
df_intraday <- tail(df_intraday, 1)
# # load daily data, lag date by one day
# files <- list()
# for (l in list.files(symbol_dir, pattern = "daily")) {
#   #f <- read_csv(paste0(symbol_dir, "/", l), show_col_types = FALSE, col_names = FALSE)
#   f <- fread(paste0(symbol_dir, "/", l), header= FALSE)
#   colnames(f) <- c("Date", "Close")
#   if(lagged)
#     f <- f %>% mutate(Date = as_date((ifelse(wday(Date) == 5, Date+2, Date+1  ))))
#   files[[l]] <- f
# }
# # merge into one continous time series, remove possible dubplicates by keeping the last one
# df_daily = do.call(rbind, files) %>% arrange(Date) %>% group_by(Date) %>% summarize(Date=last(Date), Close=last(Close)) %>% ungroup
system(paste("cat", paste(list.files(symbol_dir, pattern = "daily", full.names = TRUE), collapse = " "),  " | sort -u  > _tmp"))
df_daily <- fread("_tmp", header= FALSE)
colnames(df_daily) <- c("Date", "Close")
df_daily <- arrange(df_daily, Date)
if(lagged)
df_daily <- df_daily %>% mutate(Date = as_date((ifelse(wday(Date) == "Fri", Date+2, Date+1  ))))
# only keep daily data up to the last element of intradaily data
df_daily <-  dplyr::filter(df_daily, Date < df_intraday$Date[1])
# load weekly data, lag date by two days
# files <- list()
# for (l in list.files(symbol_dir, pattern = "weekly")) {
#   #f <- read_csv(paste0(symbol_dir, "/", l), show_col_types = FALSE, col_names = FALSE)
#   f <- fread(paste0(symbol_dir, "/", l), header= FALSE)
#   colnames(f) <- c("Date", "Close")
#   if(lagged) {
#     f[,1] <- f[,1]+2
#     f <- f[-1,]
#   }
#   files[[l]] <- f
# }
# # merge into one continous time series, remove possible dubplicates by keeping the last one
# df_weekly = do.call(rbind, files) %>% arrange(Date) %>% group_by(Date) %>% summarize(Date=last(Date), Close=last(Close)) %>% ungroup
#
system(paste("cat", paste(list.files(symbol_dir, pattern = "weekly", full.names = TRUE), collapse = " "),  " | sort -u  > _tmp"))
df_weekly <- fread("_tmp", header= FALSE)
colnames(df_weekly) <- c("Date", "Close")
df_weekly <- arrange(df_weekly, Date)
if(lagged) {
df_weekly[,1] <- df_weekly[,1]+2
df_weekly <- df_weekly[-1,]
}
# only keep weekly data up to the start of daily data
df_weekly <- mutate(df_weekly, Date=as.Date(Date)) %>% dplyr::filter(Date < df_daily$Date[1])
# interpolate weekly data to create daily data
# first, recreate full daily Date excluding weekends
dates <- seq(df_weekly$Date[1], df_weekly$Date[length(df_weekly$Date)], by=1) %>%
as_tibble() %>% mutate(Date=value) %>% select(-value) %>% dplyr::filter(!(lubridate::wday(Date, label = TRUE) %in% c("Sat", "Sun")))
# then interpolate
df_weekly <- merge(df_weekly, dates, by="Date", all=TRUE) %>% mutate(Close=na.approx(Close), Date=as_date(Date))
# merge all data
df_intraday$Period <- "Intraday"
df_daily$Period <- "Daily"
df_weekly$Period <- "Weekly"
df <- rbind(df_weekly, df_daily) %>% group_by(Date) %>% summarize(Date=last(Date), Close=last(Close), Period=last(Period)) %>% ungroup %>%
arrange(Date)
df <- rbind(df, mutate(df_intraday, Date=as_date(Date))) %>% mutate(Date=as.Date(Date))
# load last holding cost
l <- tail(sort(list.files(symbol_dir, pattern = "holding_cost")), 1)
f <- read_csv(paste0(symbol_dir, "/", l), show_col_types = FALSE, col_names = FALSE)
if(dim(f)[1] == 0) {
warning(paste("Holding cost file empty for symbol:", symbol))
hc <- c(0,0)
} else {
hc <- unlist(f[,-1])
}
if((length(unique(df$Date)) != length(df$Date)))
stop(paste("Duplicate dates in ", symbol))
return(list("Price"=df, "HC"=hc))
}
multiple_EMA <- function(adjclose, close, volatility, spans=c(4, 8, 16, 32, 64), scalars=c(8.53, 5.95, 4.1, 2.79, 1.91), mult=4, cap=20, period=252) {
n <- length(spans)
EWMACs <- lapply(1:n, function(i) EMA(adjclose, spans[i]) -  EMA(adjclose, spans[i]*mult))
EWMACs <- lapply(1:n, function(i) EWMACs[[i]] / (close * volatility / sqrt(period)) * scalars[i] )
EWMACs <- lapply(1:n, function(i) cap_forecast(EWMACs[[i]], cap))
forecast <- rowMeans(do.call(cbind, EWMACs))
return(forecast)
}
multiple_DC <- function(adjclose, close, volatility, spans=c(20, 40, 80, 160, 320), scalars=c(0.67, 0.70, 0.73, 0.74, 0.74), cap=20, period=252) {
n <- length(spans)
DCs <- lapply(1:n, function(i) {dc <- DonchianChannel(adjclose, spans[i]); (adjclose - dc[,2]) / abs(dc[,1] - dc[,3])})
DCs <- lapply(1:n, function(i) EMA(na.locf(DCs[[i]], na.rm=F) * 40, spans[i]/4) * scalars[i] )
DCs <- lapply(1:n, function(i) cap_forecast(DCs[[i]], cap))
forecast <- rowMeans(do.call(cbind, DCs))
return(forecast)
}
KalmanFilterIndicator <- function(x, sharpness=1, K=1) {
n <- length(x)
value <- rep(NA, n)
distance <- rep(NA, n)
velocity <- rep(NA, n)
error <- rep(NA, n)
value[1] <- x[1]
velocity[1] <- 0
distance[1] <- 0
error[1] <- 0
for(i in 2:length(x)){
distance[i] <- x[i] - value[i-1]
error[i] <- value[i-1] + distance[i] * sqrt(sharpness * K / 100)
velocity[i] <- velocity[i-1] + distance[i]*K/100
value[i] <- error[i]+velocity[i]
}
return(cbind(value=value, velocity=velocity, distance=distance, error=error))
}
multiple_KF <- function(adjclose, close, volatility, spans=c(0.5, 1, 2, 5, 10), scalars=c(66, 55, 46, 37, 31), cap=20, period=252) {
n <- length(spans)
KFs <- lapply(1:n, function(i) KalmanFilterIndicator(adjclose, sharpness = 1, K = spans[i])[,2])
KFs <- lapply(1:n, function(i) KFs[[i]] / ((close * volatility / sqrt(period))) * scalars[i] )
KFs <- lapply(1:n, function(i) cap_forecast(KFs[[i]], cap))
forecast <- rowMeans(do.call(cbind, KFs))
return(forecast)
}
TII <- function(x, P = 60, ma=TTR::EMA) {
ma_p <- ma(x, P)
diff <- x - ma_p
pos_count <- runSum(diff>0, floor(P/2))
return(400 * (pos_count) / P - 100)
}
multiple_TII <- function(adjclose, close, volatility, spans=c(21, 63, 126, 252)) {
n <- length(spans)
TII <- lapply(1:n, function(i) TII(adjclose, P = spans[i]) / 5)
forecast <- rowMeans(do.call(cbind, TII))
return(forecast)
}
# basis and volatility are in percentage
multiple_Carry <- function(basis, expiry_difference, volatility, spans=c(21, 63, 126), scalar=30, expiry_span=12, cap=20) {
n <- length(spans)
Carry <- (basis / (expiry_difference / expiry_span)) / ( volatility )
Carry <- na.locf(Carry, na.rm=FALSE); Carry[is.na(Carry)] <- 0
EMAs <- lapply(1:n, function(i) EMA(Carry, spans[i]) * scalar)
EMAs <- lapply(1:n, function(i)  cap_forecast(EMAs[[i]], cap))
forecast <- rowMeans(do.call(cbind, EMAs))
return(forecast)
}
relative_volatility <- function(volatility, period=2520) {
return(unlist(Map(function(i) mean(tail(volatility[1:i], period), na.rm=TRUE), 1:length(volatility))))
}
multiple_Skew <- function(returns, spans=c(60, 120, 240), scalars=c(33.3, 37.2, 39.2), cap=20) {
n <- length(spans)
returns[is.na(returns)] <- 0
Skews <- lapply(1:n, function(i) -rollapply(returns, width=spans[i], skewness,  fill=NA, align="right"))
Skews <-  lapply(1:n, function(i) replace(Skews[[i]], is.na(Skews[[i]]), 0))
Skews <-  lapply(1:n, function(i) EMA(Skews[[i]], ceiling(spans[i]/4)) * scalars[i])
Skews <- lapply(1:n, function(i) cap_forecast(Skews[[i]], cap))
forecast <- rowMeans(do.call(cbind, Skews))
return(forecast)
}
# Parameters (maybe put them in a config file?)
{
main_dir <- "/home/marco/trading/Systems/Monopoly/ExecuteATFS/"
positions_file <- paste0(main_dir, "POSITIONS.csv")
instrument_file <- paste0(main_dir, "INSTRUMENTS.csv")
FX_file <- paste0(main_dir, "FX.csv")
scrape_dir <- paste0(main_dir, "Scraping/")
FX_dir <- paste0(main_dir, "FX/")
logs_dir <- paste0(main_dir, "Logs/")
logs_instruments_dir <- paste0(logs_dir, "Instruments/")
scrape_script <- "SCRAPE_DATA.sh"
target_vol <- 0.33
IDM = 3.5
FDMtrend <- 1.3
FDMcarry <- 3.3
FDMskew <- 1.2
FDM <- 1.5
strategy_weights <- list("Trend" = 0.4, "Carry" = 0.5, "Skew" = 0.1)
corr_length <- 25
portfolio_buffering_level <- 0.1
position_buffering_level <- 0.2
trade_shadow_cost <- 10
}
previous_trading <- read_csv(positions_file, col_names = TRUE, show_col_types = FALSE) %>% arrange(Symbol)
previous_trading$Forecast %>% sort %>% plot
previous_trading$ForecastSkew %>% sort %>% points(pch=16, col="blue")
previous_trading$ForecastCarry %>% sort %>% points(pch=16, col="red")
previous_trading$ForecastTrend %>% sort %>% points(pch=16, col="green")
previous_trading$ForecastCarry %>% abs %>% mean
previous_trading$ForecastTrend %>% abs %>% mean
previous_trading$ForecastSkew %>% abs %>% mean
previous_trading$Forecast %>% abs %>% mean
{
library(ggthemes)
source("/home/marco/trading/Systems/Monopoly/Futures.R")
}
BackAdj <- read_rds("/home/marco/trading/Historical Data/Barchart/BackAdj.RDS")
# Live cattle
{
df <- BackAdj[["LE"]] %>% filter(year(Date) > 2000)
a <-
mutate(df, dom = mday(Date)) %>% mutate(dom = case_when(dom <= 7 ~ 1, dom > 7 & dom <= 14 ~ 2, dom > 14 & dom <= 21 ~ 3, dom > 21 & dom <= 31 ~ 4, TRUE ~ 0)) %>%
mutate(df, date=yearweek(Date)) %>%
mutate( Cost = 0.0006) %>%
mutate(Trend = lag(EMA(AdjClose, 1) - EMA(AdjClose, 4))) %>%
mutate(Trade = case_when((dom == 3  | dom == 4 ) & Trend > 0  ~ 1  ,TRUE ~ 0)) %>%
mutate(Excess = Return * Trade) %>%
group_by(date) %>% summarise(Excess=sum(Excess, na.rm=TRUE), Trades=first(sum(unique(Trade)!=0)), Cost=first(Cost*Trades)) %>% ungroup %>%
summarise(date=date,PnL=cumsum(Excess-Cost),Excess=Excess-Cost, Cost=Cost)
ggplot(a) + geom_line(aes(date, PnL), linewidth=2)
with(a, mean(Excess)/sd(Excess)*sqrt(52))
# Mean annual return      Annualized SD       Sharpe ratio               Skew         Lower tail         Upper tail
# 9.96               8.68               1.17               1.87               2.87              -5.29
# Max DD             Avg DD         Adj Avg DD                GSR                 R2
# -14.88              -2.64              -0.30               1.11               0.99
#
}
ggplot(a) + geom_line(aes(date, PnL), linewidth=2)
df <- BackAdj[["LE"]] %>% filter(year(Date) > 2000)
a <-
mutate(df, dom = mday(Date)) %>% mutate(dom = case_when(dom <= 7 ~ 1, dom > 7 & dom <= 14 ~ 2, dom > 14 & dom <= 21 ~ 3, dom > 21 & dom <= 31 ~ 4, TRUE ~ 0)) %>%
mutate(df, date=yearweek(Date)) %>%
mutate( Cost = 0.0006) %>%
mutate(Trend = lag(EMA(AdjClose, 1) - EMA(AdjClose, 4))) %>%
mutate(Trade = case_when((dom == 3  | dom == 4 )  ~ 1  ,TRUE ~ 0)) %>%
mutate(Excess = Return * Trade) %>%
group_by(date) %>% summarise(Excess=sum(Excess, na.rm=TRUE), Trades=first(sum(unique(Trade)!=0)), Cost=first(Cost*Trades)) %>% ungroup %>%
summarise(date=date,PnL=cumsum(Excess-Cost),Excess=Excess-Cost, Cost=Cost)
ggplot(a) + geom_line(aes(date, PnL), linewidth=2)
with(a, mean(Excess)/sd(Excess)*sqrt(52))
a <-
mutate(df, dom = mday(Date)) %>% mutate(dom = case_when(dom <= 7 ~ 1, dom > 7 & dom <= 14 ~ 2, dom > 14 & dom <= 21 ~ 3, dom > 21 & dom <= 31 ~ 4, TRUE ~ 0)) %>%
mutate(df, date=yearweek(Date)) %>%
mutate( Cost = 0.0006) %>%
mutate(Trend = lag(EMA(AdjClose, 1) - EMA(AdjClose, 4))) %>%
mutate(Trade = case_when((dom == 3  | dom == 4 ) & Basis > 0  ~ 1  ,TRUE ~ 0)) %>%
mutate(Excess = Return * Trade) %>%
group_by(date) %>% summarise(Excess=sum(Excess, na.rm=TRUE), Trades=first(sum(unique(Trade)!=0)), Cost=first(Cost*Trades)) %>% ungroup %>%
summarise(date=date,PnL=cumsum(Excess-Cost),Excess=Excess-Cost, Cost=Cost)
ggplot(a) + geom_line(aes(date, PnL), linewidth=2)
a <-
mutate(df, dom = mday(Date)) %>% mutate(dom = case_when(dom <= 7 ~ 1, dom > 7 & dom <= 14 ~ 2, dom > 14 & dom <= 21 ~ 3, dom > 21 & dom <= 31 ~ 4, TRUE ~ 0)) %>%
mutate(df, date=yearweek(Date)) %>%
mutate( Cost = 0.0006) %>%
mutate(Trend = lag(EMA(AdjClose, 1) - EMA(AdjClose, 4))) %>%
mutate(Trade = case_when((dom == 3  | dom == 4 ) & Basis < 0  ~ 1  ,TRUE ~ 0)) %>%
mutate(Excess = Return * Trade) %>%
group_by(date) %>% summarise(Excess=sum(Excess, na.rm=TRUE), Trades=first(sum(unique(Trade)!=0)), Cost=first(Cost*Trades)) %>% ungroup %>%
summarise(date=date,PnL=cumsum(Excess-Cost),Excess=Excess-Cost, Cost=Cost)
ggplot(a) + geom_line(aes(date, PnL), linewidth=2)
with(a, mean(Excess)/sd(Excess)*sqrt(52))
a <-
mutate(df, dom = mday(Date)) %>% mutate(dom = case_when(dom <= 7 ~ 1, dom > 7 & dom <= 14 ~ 2, dom > 14 & dom <= 21 ~ 3, dom > 21 & dom <= 31 ~ 4, TRUE ~ 0)) %>%
mutate(df, date=yearweek(Date)) %>%
mutate( Cost = 0.0006) %>%
mutate(Trend = lag(EMA(AdjClose, 1) - EMA(AdjClose, 4))) %>%
mutate(Trade = case_when((dom == 3  | dom == 4 ) & Basis < 0  & Trend < 0 ~ 1  ,TRUE ~ 0)) %>%
mutate(Excess = Return * Trade) %>%
group_by(date) %>% summarise(Excess=sum(Excess, na.rm=TRUE), Trades=first(sum(unique(Trade)!=0)), Cost=first(Cost*Trades)) %>% ungroup %>%
summarise(date=date,PnL=cumsum(Excess-Cost),Excess=Excess-Cost, Cost=Cost)
ggplot(a) + geom_line(aes(date, PnL), linewidth=2)
with(a, mean(Excess)/sd(Excess)*sqrt(52))
a <-
mutate(df, dom = mday(Date)) %>% mutate(dom = case_when(dom <= 7 ~ 1, dom > 7 & dom <= 14 ~ 2, dom > 14 & dom <= 21 ~ 3, dom > 21 & dom <= 31 ~ 4, TRUE ~ 0)) %>%
mutate(df, date=yearweek(Date)) %>%
mutate( Cost = 0.0006) %>%
mutate(Trend = lag(EMA(AdjClose, 1) - EMA(AdjClose, 4))) %>%
mutate(Trade = case_when((dom == 3  | dom == 4 ) & Basis < 0  & Trend > 0 ~ 1  ,TRUE ~ 0)) %>%
mutate(Excess = Return * Trade) %>%
group_by(date) %>% summarise(Excess=sum(Excess, na.rm=TRUE), Trades=first(sum(unique(Trade)!=0)), Cost=first(Cost*Trades)) %>% ungroup %>%
summarise(date=date,PnL=cumsum(Excess-Cost),Excess=Excess-Cost, Cost=Cost)
ggplot(a) + geom_line(aes(date, PnL), linewidth=2)
with(a, mean(Excess)/sd(Excess)*sqrt(52))
