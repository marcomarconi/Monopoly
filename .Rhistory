weights_optimal <- optimal_positions * weights_per_contract / multiplier
weights_previous <- previous_position * weights_per_contract / multiplier
costs_per_trade_in_weight <- (costs_per_contract / multiplier / capital) / weights_per_contract
print(weights_per_contract)
best_solution <- rep(0, n)
best_value <- evaluate(weights_optimal, best_solution, cov_matrix)
while(1) {
res <- find_possible_new_best(weights_optimal, weights_per_contract, sign(weights_optimal), best_solution, best_value, cov_matrix)
new_best_value <- res[[1]]
new_solution <- res[[2]]
if(new_best_value < best_value) {
best_value = new_best_value
best_solution = new_solution
} else
break
#print(best_value)
}
return(best_solution / (weights_per_contract / multiplier))
}
j <- 53;setNames(dynamic_portfolio(capital, optimal_positions[1:j] , notional_exposures[1:j],  cov_matrix[1:j,1:j], digits = NULL), today_trading$Symbol[1:j])
optimal_positions %>% plot
notional_exposures %>% plot
dynamic_portfolio <- function(capital, optimal_positions, notional_exposures, cov_matrix,
previous_position=NULL, costs_per_contract=NULL, trade_shadow_cost=1, digits=NULL) {
calculate_costs <- function(weights) {
trade_gap <- weights - weights_previous
trade_costs <- sum(abs(costs_per_contract * trade_gap * trade_shadow_cost))
return(trade_costs)
}
evaluate <- function(weights_optimal, weights, cov_matrix) {
solution_gap <- weights_optimal - weights
track_error <- as.numeric(sqrt(t(solution_gap) %*%  cov_matrix %*% solution_gap))
trade_costs = calculate_costs(weights)
#print(paste(track_error, trade_costs))
return(track_error + trade_costs)
}
find_possible_new_best <- function(weights_optimal, per_contract_value, direction, best_solution, best_value, cov_matrix){
new_best_value = best_value
new_solution = best_solution
count_assets = length(best_solution)
for(i in 1:n) {
#print(i)
temp_step <- best_solution
temp_step[i] = temp_step[i] + per_contract_value[i] * direction[i]
temp_objective_value <-  evaluate(weights_optimal, temp_step, cov_matrix)
if(temp_objective_value < new_best_value) {
new_best_value = temp_objective_value
new_solution = temp_step
#print("acepted")
}
return (list(new_best_value, new_solution))
}
n <- nrow(cov_matrix)
if(is.null(previous_position))
previous_position <- rep(0, n)
if(is.null(costs_per_contract))
costs_per_contract <- rep(0, n)
if(is.null(digits))
multiplier <- rep(1, n)
else
multiplier <- 10^digits
weights_per_contract <- notional_exposures * multiplier / capital
weights_optimal <- optimal_positions * weights_per_contract / multiplier
weights_previous <- previous_position * weights_per_contract / multiplier
costs_per_trade_in_weight <- (costs_per_contract / multiplier / capital) / weights_per_contract
print(costs_per_trade_in_weight)
best_solution <- rep(0, n)
best_value <- evaluate(weights_optimal, best_solution, cov_matrix)
while(1) {
res <- find_possible_new_best(weights_optimal, weights_per_contract, sign(weights_optimal), best_solution, best_value, cov_matrix)
new_best_value <- res[[1]]
new_solution <- res[[2]]
if(new_best_value < best_value) {
best_value = new_best_value
best_solution = new_solution
} else
break
#print(best_value)
}
return(best_solution / (weights_per_contract / multiplier))
}
notional_exposures %>% plot
j <- 53;setNames(dynamic_portfolio(capital, optimal_positions[1:j] , notional_exposures[1:j],  cov_matrix[1:j,1:j], digits = NULL), today_trading$Symbol[1:j])
dynamic_portfolio <- function(capital, optimal_positions, notional_exposures, cov_matrix,
previous_position=NULL, costs_per_contract=NULL, trade_shadow_cost=1, digits=NULL) {
calculate_costs <- function(weights) {
trade_gap <- weights - weights_previous
trade_costs <- sum(abs(costs_per_contract * trade_gap * trade_shadow_cost))
return(trade_costs)
}
evaluate <- function(weights_optimal, weights, cov_matrix) {
solution_gap <- weights_optimal - weights
track_error <- as.numeric(sqrt(t(solution_gap) %*%  cov_matrix %*% solution_gap))
trade_costs = calculate_costs(weights)
#print(paste(track_error, trade_costs))
return(track_error + trade_costs)
}
find_possible_new_best <- function(weights_optimal, per_contract_value, direction, best_solution, best_value, cov_matrix){
new_best_value = best_value
new_solution = best_solution
count_assets = length(best_solution)
for(i in 1:n) {
#print(i)
temp_step <- best_solution
temp_step[i] = temp_step[i] + per_contract_value[i] * direction[i]
temp_objective_value <-  evaluate(weights_optimal, temp_step, cov_matrix)
if(temp_objective_value < new_best_value) {
new_best_value = temp_objective_value
new_solution = temp_step
#print("acepted")
}
return (list(new_best_value, new_solution))
}
n <- nrow(cov_matrix)
if(is.null(previous_position))
previous_position <- rep(0, n)
if(is.null(costs_per_contract))
costs_per_contract <- rep(0, n)
if(is.null(digits))
multiplier <- rep(1, n)
else
multiplier <- 10^digits
weights_per_contract <- notional_exposures * multiplier / capital
weights_optimal <- optimal_positions * weights_per_contract / multiplier
weights_previous <- previous_position * weights_per_contract / multiplier
costs_per_trade_in_weight <- (costs_per_contract / multiplier / capital) / weights_per_contract
print(weights_optimal)
best_solution <- rep(0, n)
best_value <- evaluate(weights_optimal, best_solution, cov_matrix)
while(1) {
res <- find_possible_new_best(weights_optimal, weights_per_contract, sign(weights_optimal), best_solution, best_value, cov_matrix)
new_best_value <- res[[1]]
new_solution <- res[[2]]
if(new_best_value < best_value) {
best_value = new_best_value
best_solution = new_solution
} else
break
#print(best_value)
}
return(best_solution / (weights_per_contract / multiplier))
}
j <- 53;setNames(dynamic_portfolio(capital, optimal_positions[1:j] , notional_exposures[1:j],  cov_matrix[1:j,1:j], digits = NULL), today_trading$Symbol[1:j])
j <- 53;setNames(dynamic_portfolio(capital, optimal_positions[1:j] , notional_exposures[1:j],  cov_matrix[1:j,1:j], digits = NULL), today_trading$Symbol[1:j])  -> b
b
styler:::style_selection()
dynamic_portfolio <- function(capital, optimal_positions, notional_exposures, cov_matrix,
previous_position = NULL, costs_per_contract = NULL, trade_shadow_cost = 1, digits = NULL) {
calculate_costs <- function(weights) {
trade_gap <- weights - weights_previous
trade_costs <- sum(abs(costs_per_contract * trade_gap * trade_shadow_cost))
return(trade_costs)
}
evaluate <- function(weights_optimal, weights, cov_matrix) {
solution_gap <- weights_optimal - weights
track_error <- as.numeric(sqrt(t(solution_gap) %*% cov_matrix %*% solution_gap))
trade_costs <- calculate_costs(weights)
# print(paste(track_error, trade_costs))
return(track_error + trade_costs)
}
find_possible_new_best <- function(weights_optimal, per_contract_value, direction, best_solution, best_value, cov_matrix) {
new_best_value <- best_value
new_solution <- best_solution
count_assets <- length(best_solution)
for (i in 1:count_assets) {
# print(i)
temp_step <- best_solution
temp_step[i] <- temp_step[i] + per_contract_value[i] * direction[i]
temp_objective_value <- evaluate(weights_optimal, temp_step, cov_matrix)
if (temp_objective_value < new_best_value) {
new_best_value <- temp_objective_value
new_solution <- temp_step
# print("acepted")
}
return(list(new_best_value, new_solution))
}
n <- nrow(cov_matrix)
if (is.null(previous_position)) {
previous_position <- rep(0, n)
}
if (is.null(costs_per_contract)) {
costs_per_contract <- rep(0, n)
}
if (is.null(digits)) {
multiplier <- rep(1, n)
} else {
multiplier <- 10^digits
}
weights_per_contract <- notional_exposures * multiplier / capital
weights_optimal <- optimal_positions * weights_per_contract / multiplier
weights_previous <- previous_position * weights_per_contract / multiplier
costs_per_trade_in_weight <- (costs_per_contract / multiplier / capital) / weights_per_contract
print(weights_optimal)
best_solution <- rep(0, n)
best_value <- evaluate(weights_optimal, best_solution, cov_matrix)
while (1) {
res <- find_possible_new_best(weights_optimal, weights_per_contract, sign(weights_optimal), best_solution, best_value, cov_matrix)
new_best_value <- res[[1]]
new_solution <- res[[2]]
if (new_best_value < best_value) {
best_value <- new_best_value
best_solution <- new_solution
} else {
break
}
# print(best_value)
}
return(best_solution / (weights_per_contract / multiplier))
}
n
j <- 53;setNames(dynamic_portfolio(capital, optimal_positions[1:j] , notional_exposures[1:j],  cov_matrix[1:j,1:j], digits = NULL), today_trading$Symbol[1:j])  -> b
b
dynamic_portfolio <- function(capital, optimal_positions, notional_exposures, cov_matrix, previous_position=NULL, costs_per_contract=NULL, trade_shadow_cost=1, fractional=NULL) {
calculate_costs <- function(weights) {
trade_gap <- weights - weights_previous
trade_costs <- sum(abs(costs_per_contract_in_weight * trade_gap * trade_shadow_cost))
return(trade_costs)
}
evaluate <- function(weights_optimal, weights, cov_matrix) {
solution_gap <- weights_optimal - weights
track_error <- as.numeric(sqrt(t(solution_gap) %*%  cov_matrix %*% solution_gap))
trade_costs = calculate_costs(weights)
return(track_error + trade_costs)
}
find_possible_new_best <- function(weights_optimal, per_contract_value, direction, best_solution, best_value, cov_matrix){
new_best_value = best_value
new_solution = best_solution
count_assets = length(best_solution)
for(i in 1:count_assets) {
temp_step <- best_solution
temp_step[i] = temp_step[i] + per_contract_value[i] * direction[i]
temp_objective_value <-  evaluate(weights_optimal, temp_step, cov_matrix)
if(temp_objective_value < new_best_value) {
new_best_value = temp_objective_value
new_solution = temp_step
}
return (list(new_best_value, new_solution))
}
n <- nrow(cov_matrix)
if(is.null(previous_position))
previous_position <- rep(0, n)
if(is.null(costs_per_contract))
costs_per_contract <- rep(0, n)
# fractional is a new element. In the original algorithm you are force to move by one integer contract,
# but with CFDs you can move by fractions. So later "weights_per_contract" is actually "weights_per_fraction"
if(is.null(fractional))
fractional <- rep(1, n)
weights_per_contract <- notional_exposures  / capital
weights_optimal <- optimal_positions * weights_per_contract
weights_previous <- previous_position * weights_per_contract
costs_per_contract_in_weight <- (costs_per_contract / fractional / capital) / weights_per_contract
best_solution <- rep(0, n)
best_value <- evaluate(weights_optimal, best_solution, cov_matrix)
while(1) {
res <- find_possible_new_best(weights_optimal, weights_per_contract, sign(weights_optimal), best_solution, best_value, cov_matrix)
new_best_value <- res[[1]]
new_solution <- res[[2]]
if(new_best_value < best_value) {
best_value = new_best_value
best_solution = new_solution
} else
break
#print(best_value)
}
return(best_solution / (weights_per_contract))
}
j <- 53;setNames(dynamic_portfolio(capital, optimal_positions[1:j] , notional_exposures[1:j],  cov_matrix[1:j,1:j], digits = NULL), today_trading$Symbol[1:j])  -> b
j <- 53;setNames(dynamic_portfolio(capital, optimal_positions[1:j] , notional_exposures[1:j],  cov_matrix[1:j,1:j]), today_trading$Symbol[1:j])  -> b
dynamic_portfolio <- function(capital, optimal_positions, notional_exposures, cov_matrix,
previous_position = NULL, costs_per_contract = NULL, trade_shadow_cost = 1, digits = NULL) {
calculate_costs <- function(weights) {
trade_gap <- weights - weights_previous
trade_costs <- sum(abs(costs_per_contract * trade_gap * trade_shadow_cost))
return(trade_costs)
}
evaluate <- function(weights_optimal, weights, cov_matrix) {
solution_gap <- weights_optimal - weights
track_error <- as.numeric(sqrt(t(solution_gap) %*% cov_matrix %*% solution_gap))
trade_costs <- calculate_costs(weights)
# print(paste(track_error, trade_costs))
return(track_error + trade_costs)
}
find_possible_new_best <- function(weights_optimal, per_contract_value, direction, best_solution, best_value, cov_matrix) {
new_best_value <- best_value
new_solution <- best_solution
count_assets <- length(best_solution)
for (i in 1:count_assets) {
# print(i)
temp_step <- best_solution
temp_step[i] <- temp_step[i] + per_contract_value[i] * direction[i]
temp_objective_value <- evaluate(weights_optimal, temp_step, cov_matrix)
if (temp_objective_value < new_best_value) {
new_best_value <- temp_objective_value
new_solution <- temp_step
# print("acepted")
}
return(list(new_best_value, new_solution))
}
n <- nrow(cov_matrix)
if (is.null(previous_position)) {
previous_position <- rep(0, n)
}
if (is.null(costs_per_contract)) {
costs_per_contract <- rep(0, n)
}
if (is.null(digits)) {
multiplier <- rep(1, n)
} else {
multiplier <- 10^digits
}
multiplier <- 1
weights_per_contract <- notional_exposures * multiplier / capital
weights_optimal <- optimal_positions * weights_per_contract / multiplier
weights_previous <- previous_position * weights_per_contract / multiplier
costs_per_trade_in_weight <- (costs_per_contract / multiplier / capital) / weights_per_contract
print(weights_optimal)
best_solution <- rep(0, n)
best_value <- evaluate(weights_optimal, best_solution, cov_matrix)
while (1) {
res <- find_possible_new_best(weights_optimal, weights_per_contract, sign(weights_optimal), best_solution, best_value, cov_matrix)
new_best_value <- res[[1]]
new_solution <- res[[2]]
if (new_best_value < best_value) {
best_value <- new_best_value
best_solution <- new_solution
} else {
break
}
# print(best_value)
}
return(best_solution / (weights_per_contract / multiplier))
}
j <- 53;setNames(dynamic_portfolio(capital, optimal_positions[1:j] , notional_exposures[1:j],  cov_matrix[1:j,1:j]), today_trading$Symbol[1:j])  -> b
b
dynamic_portfolio <- function(capital, optimal_positions, notional_exposures, cov_matrix,                              previous_position = NULL, costs_per_contract = NULL, trade_shadow_cost = 1, digits = NULL) {
calculate_costs <- function(weights) {
trade_gap <- weights - weights_previous
trade_costs <- sum(abs(costs_per_contract * trade_gap * trade_shadow_cost))
return(trade_costs)
}
evaluate <- function(weights_optimal, weights, cov_matrix) {
solution_gap <- weights_optimal - weights
track_error <- as.numeric(sqrt(t(solution_gap) %*% cov_matrix %*% solution_gap))
trade_costs <- calculate_costs(weights)
return(track_error + trade_costs)
}
find_possible_new_best <- function(weights_optimal, per_contract_value, direction, best_solution, best_value, cov_matrix) {
new_best_value <- best_value
new_solution <- best_solution
count_assets <- length(best_solution)
for (i in 1:count_assets) {
temp_step <- best_solution
temp_step[i] <- temp_step[i] + per_contract_value[i] * direction[i]
temp_objective_value <- evaluate(weights_optimal, temp_step, cov_matrix)
if (temp_objective_value < new_best_value) {
new_best_value <- temp_objective_value
new_solution <- temp_step
}
return(list(new_best_value, new_solution))
}
n <- nrow(cov_matrix)
if (is.null(previous_position))
previous_position <- rep(0, n)
if (is.null(costs_per_contract))
costs_per_contract <- rep(0, n)
if (is.null(digits)) {
multiplier <- rep(1, n)
} else {
multiplier <- 10^digits
}
weights_per_contract <- notional_exposures * multiplier / capital
weights_optimal <- optimal_positions * weights_per_contract / multiplier
weights_previous <- previous_position * weights_per_contract / multiplier
costs_per_trade_in_weight <- (costs_per_contract / multiplier / capital) / weights_per_contract
best_solution <- rep(0, n)
best_value <- evaluate(weights_optimal, best_solution, cov_matrix)
while (1) {
res <- find_possible_new_best(weights_optimal, weights_per_contract, sign(weights_optimal), best_solution, best_value, cov_matrix)
new_best_value <- res[[1]]
new_solution <- res[[2]]
if (new_best_value < best_value) {
best_value <- new_best_value
best_solution <- new_solution
} else {
break
}
return(best_solution / (weights_per_contract / multiplier))
}
j <- 53;setNames(dynamic_portfolio(capital, optimal_positions[1:j] , notional_exposures[1:j],  cov_matrix[1:j,1:j]), today_trading$Symbol[1:j])  -> b
b
dynamic_portfolio <- function(capital, optimal_positions, notional_exposures, cov_matrix, previous_position=NULL, costs_per_contract=NULL, trade_shadow_cost=1, fractional=NULL) {
calculate_costs <- function(weights) {
trade_gap <- weights - weights_previous
trade_costs <- sum(abs(costs_per_contract_in_weight * trade_gap * trade_shadow_cost))
return(trade_costs)
}
evaluate <- function(weights_optimal, weights, cov_matrix) {
solution_gap <- weights_optimal - weights
track_error <- as.numeric(sqrt(t(solution_gap) %*%  cov_matrix %*% solution_gap))
trade_costs = calculate_costs(weights)
return(track_error + trade_costs)
}
find_possible_new_best <- function(weights_optimal, per_contract_value, direction, best_solution, best_value, cov_matrix){
new_best_value = best_value
new_solution = best_solution
count_assets = length(best_solution)
for(i in 1:count_assets) {
temp_step <- best_solution
temp_step[i] = temp_step[i] + per_contract_value[i] * direction[i]
temp_objective_value <-  evaluate(weights_optimal, temp_step, cov_matrix)
if(temp_objective_value < new_best_value) {
new_best_value = temp_objective_value
new_solution = temp_step
}
return (list(new_best_value, new_solution))
}
n <- nrow(cov_matrix)
if(is.null(previous_position))
previous_position <- rep(0, n)
if(is.null(costs_per_contract))
costs_per_contract <- rep(0, n)
# fractional is a new element. In the original algorithm you are force to move by one integer contract,
# but with CFDs you can move by fractions. So later "weights_per_contract" is actually "weights_per_fraction"
if(is.null(fractional))
fractional <- rep(1, n)
weights_per_contract <- notional_exposures  / capital
weights_optimal <- optimal_positions * weights_per_contract
weights_previous <- previous_position * weights_per_contract
costs_per_contract_in_weight <- (costs_per_contract / fractional / capital) / weights_per_contract
best_solution <- rep(0, n)
best_value <- evaluate(weights_optimal, best_solution, cov_matrix)
while(1) {
res <- find_possible_new_best(weights_optimal, weights_per_contract, sign(weights_optimal), best_solution, best_value, cov_matrix)
new_best_value <- res[[1]]
new_solution <- res[[2]]
if(new_best_value < best_value) {
best_value = new_best_value
best_solution = new_solution
} else
break
#print(best_value)
}
return(best_solution / (weights_per_contract))
}
j <- 53;setNames(dynamic_portfolio(capital, optimal_positions[1:j] , notional_exposures[1:j],  cov_matrix[1:j,1:j]), today_trading$Symbol[1:j])  -> b
dynamic_portfolio <- function(capital, optimal_positions, notional_exposures, cov_matrix,
previous_position = NULL, costs_per_contract = NULL, trade_shadow_cost = 1, digits = NULL) {
calculate_costs <- function(weights) {
trade_gap <- weights - weights_previous
trade_costs <- sum(abs(costs_per_contract * trade_gap * trade_shadow_cost))
return(trade_costs)
}
evaluate <- function(weights_optimal, weights, cov_matrix) {
solution_gap <- weights_optimal - weights
track_error <- as.numeric(sqrt(t(solution_gap) %*% cov_matrix %*% solution_gap))
trade_costs <- calculate_costs(weights)
# print(paste(track_error, trade_costs))
return(track_error + trade_costs)
}
find_possible_new_best <- function(weights_optimal, per_contract_value, direction, best_solution, best_value, cov_matrix) {
new_best_value <- best_value
new_solution <- best_solution
count_assets <- length(best_solution)
for (i in 1:count_assets) {
# print(i)
temp_step <- best_solution
temp_step[i] <- temp_step[i] + per_contract_value[i] * direction[i]
temp_objective_value <- evaluate(weights_optimal, temp_step, cov_matrix)
if (temp_objective_value < new_best_value) {
new_best_value <- temp_objective_value
new_solution <- temp_step
# print("acepted")
}
return(list(new_best_value, new_solution))
}
n <- nrow(cov_matrix)
if (is.null(previous_position)) {
previous_position <- rep(0, n)
}
if (is.null(costs_per_contract)) {
costs_per_contract <- rep(0, n)
}
if (is.null(digits)) {
multiplier <- rep(1, n)
} else {
multiplier <- 10^digits
}
multiplier <- 1
weights_per_contract <- notional_exposures * multiplier / capital
weights_optimal <- optimal_positions * weights_per_contract / multiplier
weights_previous <- previous_position * weights_per_contract / multiplier
costs_per_trade_in_weight <- (costs_per_contract / multiplier / capital) / weights_per_contract
print(weights_optimal)
best_solution <- rep(0, n)
best_value <- evaluate(weights_optimal, best_solution, cov_matrix)
while (1) {
res <- find_possible_new_best(weights_optimal, weights_per_contract, sign(weights_optimal), best_solution, best_value, cov_matrix)
new_best_value <- res[[1]]
new_solution <- res[[2]]
if (new_best_value < best_value) {
best_value <- new_best_value
best_solution <- new_solution
} else {
break
}
# print(best_value)
}
return(best_solution / (weights_per_contract / multiplier))
}
j <- 53;setNames(dynamic_portfolio(capital, optimal_positions[1:j] , notional_exposures[1:j],  cov_matrix[1:j,1:j]), today_trading$Symbol[1:j])  -> b
j <- 53;setNames(dynamic_portfolio(capital, optimal_positions[1:j] , notional_exposures[1:j],  cov_matrix[1:j,1:j], digits = NULL), today_trading$Symbol[1:j])  -> b
j <- 53;setNames(dynamic_portfolio(capital, optimal_positions[1:j] , notional_exposures[1:j],  cov_matrix[1:j,1:j], digits = today_trading$Digits[1:j]), today_trading$Symbol[1:j])
