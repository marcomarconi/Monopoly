{
## Some figures takes from the Risk Management section
# Figure 97: Portfolio volatility, check it is in line with target volatility
# full_df_exposures <- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), exposures) %>% arrange(Date)
# full_df_returns <- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), returns) %>% arrange(Date)
# full_df_vols<- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), vols) %>% arrange(Date)
# a <- sapply(181:nrow(full_df_returns),  function(i) { w <- as.numeric(full_df_exposures[i,-1]); w[is.na(w)] <- 0; S <-  cov(full_df_returns[(i-180):i,-1], use="pairwise.complete.obs"); S[is.na(S)] <- 0; sqrt( w %*% S %*% w  )  } )
# plot.ts(a*100); abline(h=target_vol*100)
# a <- rowSums(abs(full_df_exposures[,-1] * full_df_vols[,-1]), na.rm=T)
}
# Final Backtest
{
# A subset of instrument I might actually trade
CMC_selection_ <- c("ZN","G","GG","CC","CA","KC","RM","HG","ZC","CT","CL","RB","HO", "LF", "PL","PA",
"SI", "GC","HE","GF", "LE","LS","NG","ZO", "OJ","ZR","ZS","ZL","ZR","ZC","SW","ZM",
"ES","ZW","HS","NY","LX")
CMC_selection <- c("ZN","CA","RM","HG","CT","CL","GC","HE","LE","LS","NG","OJ","ZR","ZS","SW","ZW","HS","ES","BT")
Assets_all <- BackAdj
Assets <- BackAdj[CMC_selection] # or BackAdj[CMC_selection]
results <- list()
forecasts <- list()
exposures <- list()
returns <- list()
vols <- list()
strategies <- list()
target_vol <- 0.25
IDM = 2.5
FDMtrend <- 1.33
FDMcarry <- 1.05
FDMcsm <- 1.4
FDMskew <- 1.18
FDM <- 1.5
starting_year <- 2003
# Apply relative volatility
relative_vol <- FALSE
# Apply Marker Correlation
market_cor <- FALSE
# Symbol-wise results
symbol_wise <- TRUE
# Strategies weights
weights <- list("Long"=0, "Trend"=1, "Carry"=0, "Skew"=0, "CSM"=0,"Test"=0)
if(sum(unlist(weights)) != 1)
stop("Strategy weights do not sum to zero")
# Asset class indices
if(weights[["CSM"]] > 0) {
NPs <- list()
for(n in names(Assets_all)) {
df <- Assets_all[[n]]
df$Volatility = calculate_volatility(df$Return)
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$dNP = c(0, diff(df$NP))
NPs[[n]] <- select(df, Date, Symbol, Class, NP, dNP)
}
allNPs <- do.call(rbind, NPs)
Asset_class_indices <- group_by(allNPs, Class, Date) %>% summarise(Symbol=Symbol, R=mean(dNP)) %>%
arrange(Class, Date) %>% select(-Symbol)  %>%  unique %>% group_by( Class) %>% mutate(A=cumsum(R)) %>% ungroup()
}
# iterate over symbols
for(symbol in names(Assets)) {
cat(paste(symbol, ""))
df <- Assets[[symbol]]
df$Volatility = calculate_volatility(df$Return)
df$Position = target_vol / df$Volatility
df$Return[is.na(df$Return)] <- 0
df$ForecastLong <- df$ForecastTrend <- df$ForecastCarry <- df$ForecastCSM <- df$ForecastSkew <- df$ForecastTest <- 0
# Relative volatility (strategy 13, improvement is minimal, and we only apply it to trend)
df$M <- 1
if(relative_vol) {
df$RV <- relative_volatility(df$Volatility)
df$Q <- sapply(1:length(df$RV), function(i) sum(df$RV[i] > df$RV[1:i], na.rm=TRUE) / i)
df$M <- EMA(2 - 1.5 * df$Q, 10)
}
# Correlation with market
df$Cor <- 1
if(market_cor) {
df <- merge(df, select(BackAdj$ES, Date, Return) %>% mutate(ES=Return) %>% select(-Return), by="Date")
df$Cor <- multiple_cor(df$Return %>% na.locf(na.rm=F), df$ES %>% na.locf(na.rm=F))
df$Cor <- -df$Cor * 0.75 + 1.25
}
# Long-only
if(weights[["Long"]]  > 0) {
df$ForecastLong <- runif(n = nrow(df), 5, 15)
}
# Trend-following (strategy 9)
if(weights[["Trend"]]  > 0) {
df$ForecastEMA <- multiple_EMA(df$AdjClose, df$Close, df$Volatility)
df$ForecastDC <- multiple_DC(df$AdjClose, df$Close, df$Volatility)
df$ForecastKF <- multiple_KF(df$AdjClose, df$Close, df$Volatility)
df$ForecastTII <- multiple_TII(df$AdjClose, df$Close, df$Volatility)
df$ForecastTrend <- rowMeans(cbind(df$ForecastEMA, df$ForecastDC, df$ForecastKF, df$ForecastTII), na.rm = T) * FDMtrend * df$M * df$Cor
df$ForecastTrend <- cap_forecast(df$ForecastTrend)
}
# Carry (strategy 10)
if(weights[["Carry"]]  > 0) {
df$ForecastCarry <- multiple_Carry(df$Basis, df$Basis_distance, df$Volatility)  * FDMcarry
df$ForecastCarry <- cap_forecast(df$ForecastCarry)
}
# Cross-sectional momentum (strategy 19)
if(weights[["CSM"]]  > 0) {
df <- merge(df, filter(Asset_class_indices, Class==df$Class[1]) %>%  select(Date, A), by="Date") # Asset_class_indices obtained from before
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$ForecastCSM <- cross_sectional_momentum(df$NP, df$A) * FDMcsm
df$ForecastCSM <- cap_forecast(df$ForecastCSM)
}
# Skewness (strategy 24)
if(weights[["Skew"]]  > 0) {
df$ForecastSkew <- returns_skew(df$Return) * FDMskew
df$ForecastSkew <- cap_forecast(df$ForecastSkew)
}
if(weights[["Test"]]  > 0) {
}
{  # Tests
# # Kurtosis
# if(weights[["Test"]]  > 0) {
#   df$ForecastTest <- returns_kurtosis(df$Return) * FDMkurtosis
#   forecast <- rollapply(df$Return, width=20, kurt,  fill=NA, align="right")
#   df$ForecastTest <- cap_forecast(df$ForecastTest)
# }
# Acceleration
if(weights[["Test"]]  > 0) {
df$Forecast16 <- (EMA(df$AdjClose, 16) -  EMA(df$AdjClose, 64)) / (df$Close * df$Volatility / 16) * 4.1
df$Forecast32 <- (EMA(df$AdjClose, 32) -  EMA(df$AdjClose, 128)) / (df$Close * df$Volatility / 16) * 2.79
df$Forecast64 <- (EMA(df$AdjClose, 64) -  EMA(df$AdjClose, 256)) / (df$Close * df$Volatility / 16) * 1.91
df$Forecast128 <- (EMA(df$AdjClose, 128) -  EMA(df$AdjClose, 512)) / (df$Close * df$Volatility / 16) * 1.50
df$Acc16 <- c(rep(NA, 16), diff(df$Forecast16, 16)) * 1.90
df$Acc32 <- c(rep(NA, 32), diff(df$Forecast32, 32)) * 1.98
df$Acc64 <- c(rep(NA, 64), diff(df$Forecast64, 64)) * 2.05
df$Acc128 <- c(rep(NA, 128), diff(df$Forecast128, 128)) * 2.10
df$ForecastTest <- cap_forecast(rowMeans(cbind(df$Acc16 , df$Acc32 , df$Acc64, df$Acc128)) * 1.55)
}
# COT
# COT <- read_csv("/home/marco/trading/Systems/Monopoly/COT.csv")
# select(COT, c("Market and Exchange Names", "As of Date in Form YYYY-MM-DD", "Noncommercial Positions-Long (All)","Noncommercial Positions-Short (All)", "Commercial Positions-Long (All)","Commercial Positions-Short (All)")) -> a
# colnames(a) <- c("Name", "Date", "NC_long", "NC_short", "C_long", "C_short")
# mutate(a, NC=NC_long/(NC_long+NC_short),C=C_long/(C_long+C_short) ) -> COT
# if(weights[["Test"]]  > 0) {
#     df$COT <- to_load[to_load$Symbol==symbol,]$COT %>% gsub('\"', '', .)
#     if(is.na(df$COT[1]) | symbol =="CL"| symbol =="KO"| symbol =="TG") {
#         df$ForecastTest <- 0
#
#     } else {
#     cot <- filter(COT, Name==df$COT[1])  %>%  select(Date, C)
#     df_ <- df
#     df_ <- merge(df_, cot, by="Date", all = TRUE, incomparables = NA)
#     df <- arrange(df_, Date) %>% mutate(C = na.locf(C, na.rm=F))
#     df$C <- lag(df$C );
#     r <- c(0,diff(log(df$C))); r[r==0] <- NA; r = na.locf(r, na.rm=F)
#     f <- AbsoluteStrength(df$C, 20) /  calculate_volatility(r) * 28
#     f <- multiple_AS(df$C, df$C, calculate_volatility(r))
#     forecast <- f
#     df$ForecastTest <- (forecast)
#     }
# }
}
# Final trade
df$Forecast <- ( weights[["Long"]] * df$ForecastLong +
weights[["Trend"]] * df$ForecastTrend +
weights[["Carry"]] * df$ForecastCarry +
weights[["CSM"]] * df$ForecastCSM +
weights[["Skew"]] * df$ForecastSkew +
weights[["Test"]] * df$ForecastTest)
df$Forecast <- cap_forecast(df$Forecast * FDM)
df$Excess <- lag(df$Position * df$Forecast/10) * df$Return * IDM
df <- filter(df, year(Date) >= starting_year)
forecasts[[symbol]]  <-   select(df, Date, Forecast)
exposures[[symbol]]  <-  mutate(df, Exposure=Position * Forecast/10) %>% select(Date, Exposure)
returns[[symbol]]  <-  select(df, Date, Return)
vols[[symbol]]  <-  select(df, Date, Volatility)
results[[symbol]] <- select(df, Date, Excess)
strategies[[symbol]]  <-  dplyr::select(df, Date, ForecastLong, ForecastTrend, ForecastCarry, ForecastCSM,ForecastSkew, ForecastTest)
} # end of symbol sloop
print("")
portfolio <- merge_portfolio_list(results)
portfolio_weights <- 1 / length(names(Assets)) # equal weights per instrument
res <- portfolio_summary(as.matrix(portfolio[,-1]) * portfolio_weights, dates = portfolio$Date, plot_stats = TRUE, symbol_wise = symbol_wise  )
print(res$Aggregate %>% unlist)
all_forecasts <- do.call(rbind,forecasts)[,2] %>% na.omit
avg_forecast_turnover <- round(252 * mean(abs(diff(all_forecasts/10))), 2)
avg_trade_turnover <- round(length(rle(all_forecasts>0)$length) / (length(all_forecasts)/252), 2)
print(paste("Average Forecast Turnover:", avg_forecast_turnover))
print(paste("Average Trade Turnover:", avg_trade_turnover))
if(symbol_wise) {
res$Symbols$Class <- lapply(Assets[names(results)], function(x) x$Class[1]) %>% unlist
group_by(res$Symbols, Class) %>% summarise(SR_mean=mean(`Sharpe ratio`, na.rm=T), SR_sd=sd(`Sharpe ratio`, na.rm=T))
}
{
## Some figures takes from the Risk Management section
# Figure 97: Portfolio volatility, check it is in line with target volatility
# full_df_exposures <- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), exposures) %>% arrange(Date)
# full_df_returns <- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), returns) %>% arrange(Date)
# full_df_vols<- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), vols) %>% arrange(Date)
# a <- sapply(181:nrow(full_df_returns),  function(i) { w <- as.numeric(full_df_exposures[i,-1]); w[is.na(w)] <- 0; S <-  cov(full_df_returns[(i-180):i,-1], use="pairwise.complete.obs"); S[is.na(S)] <- 0; sqrt( w %*% S %*% w  )  } )
# plot.ts(a*100); abline(h=target_vol*100)
# a <- rowSums(abs(full_df_exposures[,-1] * full_df_vols[,-1]), na.rm=T)
}
relative_volatility
target_vol <- 0.4
plot(today_trading$Forecast)
graphics.off()
plot(today_trading$Forecast %>% sort)
points(today_trading$ForecastTrend %>% sort, col="red")
points(today_trading$ForecastCarry %>% sort, col="blue", pch=16)
points(today_trading$ForecastSkew %>% sort, col="green", pch=16)
today_trading$ForecastSkew %>% abs %>% mean
today_trading$ForecastCarry %>% abs %>% mean
today_trading$ForecastTrend %>% abs %>% mean
today_trading$Forecast %>% abs %>% mean
target_vol <- 0.4
dry_run
{
print(paste("Capital:", capital, "Target Volatility:", target_vol, "IDM:", IDM, "FDM:", FDM,
"Position Buffering Level:", position_buffering_level))
# create dirs&files
today_string <- gsub("-", "", today())
now_string <- gsub("-| |:", "", now())
if(!dry_run) {
if(!dir.exists(logs_dir))
dir.create(logs_dir)
if(!dir.exists(current_dir))
dir.create(current_dir)
if(!dir.exists(FX_dir))
dir.create(FX_dir)
}
# load instruments infos and calculate instruments weights from asset classes groups
print("Loading symbols info and previous positions file...")
instruments_info <- read_csv(instrument_file, col_names = TRUE, show_col_types = FALSE) %>% arrange(Symbol)
tradable_symbols <- filter(instruments_info, Tradable==TRUE) %>% pull(Symbol)
instruments_info <- mutate(instruments_info, Weight = ifelse(Symbol %in% tradable_symbols, 1/length(tradable_symbols), 0)) # uniform weight
# instruments_info$Weight <- instruments_info %>% group_by(Symbol) %>%   # class-based weight
#   summarise(Symbol=Symbol,
#             n0=length(unique(instruments_info$Class1)),
#             n1=length(unique(instruments_info$Class2[instruments_info$Class1==Class1])),
#             n2=length((instruments_info$Class2[instruments_info$Class2==Class2]))) %>%
#   ungroup %>% mutate(Weight=1/n0/n1/n2) %>% pull(Weight)
# load previous positions file
if(!file.exists(positions_file))
stop("Previous positions file does not exists.")
previous_trading <- read_csv(positions_file, col_names = TRUE, show_col_types = FALSE) %>% arrange(Symbol)
# scrape price and FX data
print("Scraping price and FX data...")
setwd(main_dir)
if(!dry_run)
system(paste("bash", scrape_script, scrape_dir, instrument_file, FX_dir, FX_file))
# load price data from previous scrape, we merge it we the current data.
# Important: we expect the current dir contains already some data (with Date and Close columns), download it manually the very first time.
print("Loading price data...")
instruments_data <- list()
for(symbol in instruments_info$Symbol) {
cat(paste(symbol, ""))
current_data <- load_current_cmc_data(symbol, current_dir)
scraped_data <- load_scraped_cmc_data(symbol, scrape_dir, load_daily = FALSE, load_weekly = FALSE)
symbol_data <- rbind(current_data, scraped_data) %>% group_by(Date) %>% summarize(Date=last(Date), Close=last(Close), Period=last(Period)) %>% ungroup %>% arrange(Date)
scraped_hc <- load_scraped_cmc_hc(symbol, scrape_dir)
instruments_data[[symbol]] <- list(Price=symbol_data, HC=scraped_hc)
nas <- sum(is.na(instruments_data[[symbol]]$Price$Close))
if(nas > 0) {
warning(paste(symbol, "price data has", nas, "NAs. They have been filled"))
instruments_data[[symbol]]$Price$Close <- na.locf(instruments_data[[symbol]]$Price$Close, na.rm=FALSE)
}
# load FX data from previous scrape
print("")
print("Loading FX data...")
FX_names <- read_csv(FX_file, col_names = FALSE, show_col_types = FALSE) %>% unlist
files <- list()
for(fx in FX_names) {
cat(paste(fx, ""))
f <- read_csv(paste0(FX_dir, "/", fx, ".csv"), col_names = TRUE, show_col_types = FALSE)
colnames(f) <- c("Date", "Rate")
files[[fx]] <- arrange(f, Date) %>% na.locf(na.rm=FALSE) %>% tail(1)
}
FX_rates <- do.call(rbind, files) %>% mutate(FX=toupper(sub("eur", "", FX_names)))
colnames(FX_rates) <- c("Date", "Rate", "FX")
# the covariance matrix
print("Calculate covariance matrix...")
closes <- lapply(instruments_data, function(x)x[[1]] %>% select(Date, Close))
closes_merged <- Reduce(function(...) full_join(..., by="Date"), closes) %>% arrange(Date) %>% na.locf(na.rm=F)
colnames(closes_merged) <- c("Date", names(instruments_data))
daily_returns <- data.frame(Date=as.Date(closes_merged$Date), apply(closes_merged[,-1], 2, function(x) c(0, diff(log(x)))))
daily_returns <- na.omit(daily_returns) # Potentially dangerous?
weekly_returns <- mutate(daily_returns, Date=yearweek(Date)) %>% group_by(Date) %>% summarise(across(everything(), ~mean(.x,na.rm=TRUE)))
vols <- data.frame(Date=daily_returns$Date, apply(daily_returns[,-1], 2, function(x) calculate_volatility(x)))
#cor_matrix <- cor(tail(weekly_returns[,-1], corr_length), use="pairwise.complete.obs") # static last corr matrix
Q <- runCorMatrix(as.matrix(weekly_returns[,-1]), n = corr_length) # running corr matrix (note: if we use absolute correlation we get an error in the dynamic portfolio)
cor_matrix <- Q[[length(Q)]]
last_day_vol <- tail(vols, 1)[-1]
cov_matrix <- diag(last_day_vol) %*% cor_matrix %*% diag(last_day_vol)
rownames(cov_matrix) <- colnames(cov_matrix) <-  names(instruments_data)
if(!dry_run) {
png(paste0(plots_dir, "/", today_string, "_Cor_matrix.png"), width = 800, height = 600)
heatmap(abs(cor_matrix[tradable_symbols,tradable_symbols]), Rowv = NA, Colv = NA, cexCol = 2, cexRow = 2)
dev.off()
}
# iterate over data and calculate positions
print("Calculate new positions...")
all_days <- list()
last_day <- list()
for(symbol in names(instruments_data)) {
cat(paste(symbol, ""))
df <- instruments_data[[symbol]][[1]]
hc <- instruments_data[[symbol]][[2]]
df$Symbol <- symbol
df$ForecastTrend <- df$ForecastCarry <- df$ForecastSkew <- df$Forecast <- df$PositionMax <- df$PositionOptimal <- df$PositionOptimized <- df$AdjFactor  <- df$RequiredTrade <- df$Buffer <- df$Trading <- df$PositionPrevious <- df$PositionUnrounded <- df$Position <- df$PositionChange <- df$PositionRisk  <- 0
df$Return <- c(0, diff(log(df$Close)))
df$Return[df$Period=="Weekly"]  <- df$Return[df$Period=="Weekly"] * 4.84 # adjust weekly data to daily volatility (4.84=252/52). Not sure if correct and/or necessary
df$Volatility <- calculate_volatility(df$Return)
df$Period <- NULL
fx <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(FX)
if(fx == "EUR") {
df$FX <- 1
} else {
df$FX <- dplyr::filter(FX_rates, FX == fx) %>% pull(Rate)
}
df$Weight <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Weight)
df$Product <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Product)
df$ContractSize <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(ContractSize)
df$PositionMin <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(PositionMin)
df$PositionTick <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(PositionTick)
df$Spread <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Spread)
df$Commission <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Commission)
df$RiskAdjCost <- df$Spread / df$Close / df$Volatility
# Relative volatility (strategy 13, it does not seems to add much)
{
df$M <- 1
# df$RV <- relative_volatility(df$Volatility)
# df$Q <- sapply(1:length(df$RV), function(i) sum(df$RV[i] > df$RV[1:i], na.rm=TRUE) / i)
# df$M <- EMA(2 - 1.5 * df$Q, 10)
}
# Trend-following (strategy 9)
df$multiple_EMA <- multiple_EMA(df$Close, df$Close, df$Volatility)
df$multiple_DC <- multiple_DC(df$Close, df$Close, df$Volatility)
df$multiple_KF <- multiple_KF(df$Close, df$Close, df$Volatility)
df$multiple_TII <- multiple_TII(df$Close, df$Close, df$Volatility)
df$ForecastTrend <- rowMeans(cbind(df$multiple_EMA, df$multiple_DC, df$multiple_KF, df$multiple_TII), na.rm=T)
df$ForecastTrend <- cap_forecast(df$ForecastTrend * FDMtrend * df$M)
# Carry
# It is based on cash contract interest rate, we remove the 3% commission, so low volatility assets like
# bonds are not negatively affected in this analysis. Of course low volatility assets must be played on the future contract
# if you want to obtain the carry, as interest rates of the cash are always negative (because of the 3% commission that
# is higher than the volatility itself). For high volatility assets you can choose between cash or future.
hc_max <- which.max(hc)
hc_commission <- case_when(
df$Product[1] == "Cash" ~ 0,
df$Product[1] == "Index" ~ 0.03,
df$Product[1] == "Future" ~ 0.03,
TRUE ~ NA_real_)
hc_value <- (hc[hc_max]+hc_commission)
# When carry is always against us (both long and short charge us), we assume it is zero
if(hc_value < 0)
hc_value <- 0
df$ForecastCarry <- ifelse(hc_max == 1, 1, -1) * hc_value / df$Volatility * 10
df$ForecastCarry <- cap_forecast(df$ForecastCarry * FDMcarry)
# Skewness (strategy 24)
df$ForecastSkew <- multiple_Skew(df$Return)
df$ForecastSkew <- cap_forecast(df$ForecastSkew * FDMskew)
# Final trade
df$Forecast <- (
strategy_weights$Trend * df$ForecastTrend +
strategy_weights$Carry * df$ForecastCarry +
strategy_weights$Skew  * df$ForecastSkew   ) * FDM
df$Forecast <- cap_forecast(df$Forecast)
df$InstCapital <- capital * df$Weight * IDM
df$Exposure <- df$InstCapital * target_vol/df$Volatility
df$PositionOptimal <-  (df$Exposure * df$FX * df$Forecast/10) /
(df$ContractSize * df$Close)
df$PositionMax <- (df$Exposure * df$FX * 20/10) /
(df$ContractSize * df$Close)
df$Buffer <- (df$Exposure * df$FX * position_buffering_level/10) / (df$ContractSize * df$Close)
df$Buffer <-  ifelse(df$Buffer < df$PositionMin, df$PositionMin, df$Buffer)
all_days[[symbol]] <- df
df <- arrange(df, desc(Date))
if(!dry_run)
write_csv(df, paste0(current_dir, "/", symbol, ".csv"))
# Be careful, now it is reverse-date sorted, you cannot run any other function like EMA etc..
last_day[[symbol]] <- df[1,]
}
print("")
# Final table
today_trading <- do.call(rbind, last_day)
if(!all(previous_trading$Symbol %in% today_trading$Symbol)) {
missing_prev <- previous_trading$Symbol[!(previous_trading$Symbol %in% today_trading$Symbol)]
missing_today <- today_trading$Symbol[!(today_trading$Symbol %in% previous_trading$Symbol)]
stop(paste("Previous position symbols (POSITION file) and current symbols (INSTRUMENTS file) do not match. Missing in current: ", missing_prev, ", missing in previous: ", missing_today, "\nFix it manually."))
}
today_trading$PositionPrevious <- previous_trading$Position
if(use_dynamic_portfolio) {
# Dynamic portfolio
optimal_positions <- with(today_trading, PositionOptimal)
notional_exposures <- with(today_trading, ContractSize * Close / FX)
costs_per_contract <- with(today_trading, ContractSize * (Spread/2) / FX)
previous_positions <- previous_trading$Position
fractionals <- with(today_trading, PositionMax / 20)
position_dynamic <- dynamic_portfolio(capital, optimal_positions, notional_exposures,  cov_matrix,
previous_position = previous_positions, max_positions = NULL, min_positions = NULL,
costs_per_contract=costs_per_contract, trade_shadow_cost = trade_shadow_cost, fractional = fractionals)
position_optimized <- round_position(position_dynamic, today_trading$PositionMin,  today_trading$PositionTick)
# Buffering
res <- buffering_portfolio(capital, position_optimized, previous_positions, notional_exposures, cov_matrix, target_vol, portfolio_buffering_level)
required_trades <- res[[1]]
portfolio_tracking_error <- res[[2]]
adjustment_factor <- res[[3]]
print(paste("Portfolio tracking error:", round(portfolio_tracking_error, 3), "against buffer level", portfolio_buffering_level/2*target_vol, "adjustment factor:", round(adjustment_factor, 3)))
# Update final positions
today_trading$PositionOptimized <- position_optimized
today_trading$AdjFactor <- adjustment_factor
today_trading$RequiredTrade <- required_trades
# if the optimal is zero, close the position. This is necessary otherwise sometimes open positions with high min position are never closed.
today_trading$RequiredTrade <- with(today_trading, ifelse(abs(RequiredTrade) > 0 & PositionPrevious != 0 & PositionOptimized == 0, -PositionPrevious, RequiredTrade))
} else {
today_trading$PositionOptimized <- NULL
today_trading$AdjFactor <- NULL
today_trading$RequiredTrade <- today_trading$PositionOptimal - today_trading$PositionPrevious
}
# trade only if the required trade if bigger than buffer, bigger than position tick size and bigger than minumum position
today_trading$Trading <- with(today_trading,
(abs(RequiredTrade) >= Buffer & abs(RequiredTrade) >= PositionTick & abs(RequiredTrade) >= PositionMin) |
(abs(PositionPrevious) != 0 & PositionOptimal == 0)
)
today_trading$PositionUnrounded <- with(today_trading,  ifelse(Trading, PositionPrevious +  RequiredTrade, PositionPrevious))
today_trading$Position <- with(today_trading,  round_position(PositionUnrounded, PositionMin, PositionTick))
today_trading$PositionChange <- today_trading$Position - today_trading$PositionPrevious
today_trading$PositionRisk <- abs(with(today_trading, Position * ContractSize * (Close / FX) * Volatility)) %>% round(2)
# Portfolio volatility
w <- with(today_trading, Position * ContractSize * Close / FX / capital) %>% as.numeric
portfolio_volatility <- round(as.numeric(sqrt(w %*% cov_matrix %*% w)) * 100, 2)
print(paste("Portfolio volatility:", portfolio_volatility, "%"))
# Portfolio correlation risk
risks <- lapply(1:length(all_days), function(i)  tail(all_days[[i]]$Volatility, 1)) %>% unlist
portfolio_correlation_risk <- round(sum(abs(w * risks)), 2) * 100
print(paste("Portfolio correlation risk:", portfolio_correlation_risk, "%"))
# Active positions
portfolio_positions <- sum(today_trading$Position != 0)
portfolio_symbols <- nrow(today_trading)
print(paste("Active positions:", portfolio_positions, "total symbols:", portfolio_symbols))
print("Positions to update:")
trades <- today_trading %>% filter(Trading == TRUE) %>%
dplyr::select(Date, Close, Symbol, PositionChange, Position, PositionPrevious, PositionMax, PositionOptimal, Forecast, ForecastTrend, ForecastCarry, ForecastSkew)
print(as.data.frame(trades))
# Write to file
if(!dry_run) {
write_csv(previous_trading, paste0(logs_dir, "/", now_string, ".POSITIONS.csv"))
write_csv(today_trading, "POSITIONS.csv")
portfolio_info <- read_csv(portfolio_file, show_col_types  = FALSE) %>% as.data.frame()
info <- tibble(Date=today_string, Symbols=portfolio_symbols,
Positions=portfolio_positions, Tracking_Error=NA, Volatility=portfolio_volatility,
Jump_Risk=NA, Correlation_Risk=portfolio_correlation_risk)
write_csv(rbind(info, portfolio_info), portfolio_file)
}
write_csv(today_trading, "XPOSITIONS.csv")
all
all$ZN %>% tail
all <- all_days
{
full <- Reduce(function(...) full_join(..., by="Date"), all) %>% arrange(Date) %>% na.omit
pricecloses <- full[,grep("^Date|^Close", colnames(full))]
colnames(pricecloses)<-c("Date", names(all))
contractsizes <- full[,grep("^Date|^ContractSize", colnames(full))]
colnames(contractsizes)<-c("Date", names(all))
symbolspreads <- full[,grep("^Date|^Spread", colnames(full))]
colnames(symbolspreads)<-c("Date", names(all))
positionoptimal <- full[,grep("^Date|^PositionOptimal", colnames(full))]
colnames(positionoptimal)<-c("Date", names(all))
positionmax <- full[,grep("^Date|^PositionMax", colnames(full))]
colnames(positionmax)<-c("Date", names(all))
positionmin <- full[,grep("^Date|^PositionMin", colnames(full))]
colnames(positionmin)<-c("Date", names(all))
positionticks <- full[,grep("^Date|^PositionTick", colnames(full))]
colnames(positionticks)<-c("Date", names(all))
returns <- full[,grep("^Date|^Return", colnames(full))]
colnames(returns)<-c("Date", names(all))
cov_matrix <- cov(returns[,-1])
fx <- full[,grep("^Date|^FX", colnames(full))]
colnames(fx)<-c("Date", names(all))
fr <- full[,grep("^Date|^Forecast\\.|^Forecast$", colnames(full))]
colnames(fr)<-c("Date", names(all))
volatilities <- full[,grep("^Date|^Volatility", colnames(full))]
colnames(volatilities)<-c("Date", names(all))
# Go thorought the optimal positions and calculate the optimized positions
{
previous_positions <- rep(0, ncol(positionoptimal)-1)
positionsoptimized <- matrix(0, nrow(full), ncol(positionoptimal)-1); colnames(positionsoptimized) <- names(all)
positionsbuffered <- matrix(0, nrow(full), ncol(positionoptimal)-1); colnames(positionsbuffered) <- names(all)
capital <- 14000
for(i in 2:nrow(full)){
print(i)
optimal_positions <- positionoptimal[i,-1] %>% unlist
FX <- fx[i,-1] %>% unlist
closes <- pricecloses[i,-1] %>% unlist
frs <- fr[i,-1] %>% unlist
spreads <- symbolspreads[i,-1] %>% unlist
fractionals <- (positionmax[i,-1] %>% unlist)/20
sizes <- contractsizes[i,-1] %>% unlist
max_positions <- positionmax[i,-1] %>% unlist
min_positions <- positionmin[i,-1] %>% unlist
vols <- volatilities[i,-1] %>% unlist
positions_ticks <- positionticks[i,-1] %>% unlist
notional_exposures <- (sizes * closes / FX) %>% unlist
costs_per_contract <-   ((sizes * spreads/2) / FX) %>% unlist
costs_per_contract <-   ( spreads/2/closes/(target_vol/vols)/10 ) %>% unlist
optimized_positions <- dynamic_portfolio(10*length(closes), frs, rep(1, length(closes)),  cov_matrix,
previous_position = previous_positions, max_positions = NULL,
min_positions = NULL,  costs_per_contract=costs_per_contract,
trade_shadow_cost = 50, fractional = rep(1, length(closes)))
positionsoptimized[i,] <- optimized_positions
res <- buffering_portfolio(10*length(closes), optimized_positions, previous_positions, rep(1, length(closes)), cov_matrix, 0.25, 0.01)
positionsbuffered[i,] <- positionsbuffered[i-1,] + res[[1]]
previous_positions <- positionsbuffered[i,]
}
positionsoptimized <- data.frame(Date=full$Date, positionsoptimized);
positionsbuffered <- data.frame(Date=full$Date, positionsbuffered);
}
print(as.data.frame(trades))
hc
