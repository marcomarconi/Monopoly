# Final trade
df$Forecast <- ( weights[["Trend"]] * df$ForecastTrend +
weights[["Carry"]] * df$ForecastCarry +
weights[["CSM"]] * df$ForecastCSM +
weights[["Skew"]] * df$ForecastSkew +
weights[["Test"]] * df$ForecastTest) / 10
df$Forecast <- lag(df$Forecast)
df$Excess <- df$Return * df$Position * df$Forecast * IDM
forecasts[[symbol]]  <-   select(df, Date, Forecast)
exposures[[symbol]]  <-  mutate(df, Exposure=Position * Forecast) %>% select(Date, Exposure)
returns[[symbol]]  <-  select(df, Date, Return)
vols[[symbol]]  <-  select(df, Date, Volatility)
results[[symbol]] <- select(df, Date, Excess)
} # end of symbol sloop
print("")
portfolio <- merge_portfolio_list(results)
weights <- 1 / length(names(Assets)) # equal weights per instrument
res <- portfolio_summary(as.matrix(portfolio[,-1]) * weights, dates = portfolio$Date, plot_stats = TRUE, symbol_wise = symbol_wise  )
print(res$Aggregate %>% unlist)
res <- portfolio_summary(as.matrix(portfolio[,-1]) * portfolio_weights, dates = as.Date(portfolio$Date), plot_stats = TRUE, symbol_wise = symbol_wise)
print(res$Aggregate %>% unlist)
all_forecasts <- do.call(rbind,forecasts)[,2] %>% na.omit
avg_forecast_turnover <- round(252 * mean(abs(diff(all_forecasts/10))), 2)
avg_trade_turnover <- round(length(rle(all_forecasts>0)$length) / (length(all_forecasts)/252), 2)
print(paste("Average Forecast Turnover:", avg_forecast_turnover))
print(paste("Average Trade Turnover:", avg_trade_turnover))
if(symbol_wise) {
res$Symbols$Class <- lapply(Assets[names(results)], function(x) x$Class[1]) %>% unlist
group_by(res$Symbols, Class) %>% summarise(SR_mean=mean(`Sharpe ratio`, na.rm=T), SR_sd=sd(`Sharpe ratio`, na.rm=T))
}
{
## Some figures takes from the Risk Management section
# Figure 97: Portfolio volatility, check it is in line with target volatility
# full_df_exposures <- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), exposures) %>% arrange(Date)
# full_df_returns <- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), returns) %>% arrange(Date)
# full_df_vols<- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), vols) %>% arrange(Date)
# a <- sapply(181:nrow(full_df_returns),  function(i) { w <- as.numeric(full_df_exposures[i,-1]); w[is.na(w)] <- 0; S <-  cov(full_df_returns[(i-180):i,-1], use="pairwise.complete.obs"); S[is.na(S)] <- 0; sqrt( w %*% S %*% w  )  } )
# plot.ts(a*100); abline(h=target_vol*100)
# a <- rowSums(abs(full_df_exposures[,-1] * full_df_vols[,-1]), na.rm=T)
}
# Final Backtest
{
# A subset of instrument I might actually trade
CMC_selection <- c("ZN","G","GG","CC","CA","KC","RM","HG","ZC","CT","CL","RB","HO", "LF", "PL","PA", "SI", "GC","HE","GF", "LE","LS","NG","ZO",
"OJ","ZR","ZS","ZL","ZR","ZC","SW","ZM",
"ES","DX","ZW","D6","HS","NY","LX","A6","B6","E6","J6","M6","N6","NR","QT","S6","T6","SK")
Assets <- BackAdj[CMC_selection] # or BackAdj[CMC_selection]
results <- list()
forecasts <- list()
exposures <- list()
returns <- list()
vols <- list()
target_vol <- 0.25
IDM = 2.5
FDMtrend <- 1.33
FDMcarry <- 1.05 # so small?
FDMcsm <- 1.4
FDMskew <- 1.18
FDM <- 1
starting_year <- 2023
# Apply relative volatility
relative_vol <- FALSE
# Apply Marker Correlation
market_cor <- FALSE
# Symbol-wise results
symbol_wise <- FALSE
# Strategies weights
weights <- list("Long"=0, "Trend"=0.4, "Carry"=0.5, "CSM"=0, "Skew"=0.1, "Test"=0)
if(sum(unlist(weights)) != 1)
warning("Strategy weights do not sum to zero")
# Asset class indices
if(weights[["CSM"]] > 0) {
NPs <- list()
for(n in names(Assets)) {
df <- Assets[[n]]
df$Volatility = calculate_volatility(df$Return)
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$dNP = c(0, diff(df$NP))
NPs[[n]] <- select(df, Date, Symbol, Class, NP, dNP)
}
allNPs <- do.call(rbind, NPs)
Asset_class_indices <- group_by(allNPs, Class, Date) %>% summarise(Symbol=Symbol, R=mean(dNP)) %>%
arrange(Class, Date) %>% select(-Symbol)  %>%  unique %>% group_by( Class) %>% mutate(A=cumsum(R)) %>% ungroup()
}
# iterate over symbols
for(symbol in names(Assets)) {
cat(paste(symbol, ""))
df <- Assets[[symbol]]
df$Volatility = calculate_volatility(df$Return)
df$Position = lag(target_vol / df$Volatility)
df$Return[is.na(df$Return)] <- 0
df$ForecastTrend <- df$ForecastCarry <- df$ForecastCSM <- df$ForecastSkew <- df$ForecastTest <- 0
# Relative volatility (strategy 13, improvement is minimal, and we only apply it to trend)
df$M <- 1
if(relative_vol) {
df$RV <- relative_volatility(df$Volatility)
df$Q <- sapply(1:length(df$RV), function(i) sum(df$RV[i] > df$RV[1:i], na.rm=TRUE) / i)
df$M <- EMA(2 - 1.5 * df$Q, 10)
}
# Correlation with market
df$Cor <- 1
if(market_cor) {
df <- merge(df, select(BackAdj$ES, Date, Return) %>% mutate(ES=Return) %>% select(-Return), by="Date")
df$Cor <- multiple_cor(df$Return %>% na.locf(na.rm=F), df$ES %>% na.locf(na.rm=F))
df$Cor <- -df$Cor * 0.75 + 1.25
}
# Trend-following (strategy 9)
if(weights[["Trend"]]  > 0) {
df$ForecastEMA <- multiple_EMA(df$AdjClose, df$Close, df$Volatility)
df$ForecastDC <- multiple_DC(df$AdjClose, df$Close, df$Volatility)
df$ForecastKF <- multiple_KF(df$AdjClose, df$Close, df$Volatility)
df$ForecastTII <- multiple_TII(df$AdjClose, df$Close, df$Volatility)
df$ForecastTrend <- rowMeans(cbind(df$ForecastEMA, df$ForecastDC, df$ForecastKF, df$ForecastTII)) * FDMtrend * df$M * df$Cor
df$ForecastTrend <- cap_forecast(df$ForecastTrend)
}
# Carry (strategy 10)
if(weights[["Carry"]]  > 0) {
df$ForecastCarry <- multiple_Carry(df$Basis, df$Basis_distance, df$Volatility)  * FDMcarry
df$ForecastCarry <- cap_forecast(df$ForecastCarry)
}
# Cross-sectional momentum (strategy 19)
if(weights[["CSM"]]  > 0) {
df <- merge(df, filter(Asset_class_indices, Class==df$Class[1]) %>%  select(Date, A), by="Date") # Asset_class_indices obtained from before
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$ForecastCSM <- cross_sectional_momentum(df$NP, df$A) * FDMcsm
df$ForecastCSM <- cap_forecast(df$ForecastCSM)
}
# Skewness (strategy 24)
if(weights[["Skew"]]  > 0) {
df$ForecastSkew <- returns_skew(df$Return) * FDMskew
df$ForecastSkew <- cap_forecast(df$ForecastSkew)
}
if(weights[["Test"]]  > 0) {
}
{  # Tests
# # Kurtosis
# if(weights[["Test"]]  > 0) {
#   df$ForecastTest <- returns_kurtosis(df$Return) * FDMkurtosis
#   forecast <- rollapply(df$Return, width=20, kurt,  fill=NA, align="right")
#   df$ForecastTest <- cap_forecast(df$ForecastTest)
# }
# Acceleration
# if(weights[["Test"]]  > 0) {
#   df$Forecast16 <- (EMA(df$AdjClose, 16) -  EMA(df$AdjClose, 64)) / (df$Close * df$Volatility / 16) * 4.1
#   df$Forecast32 <- (EMA(df$AdjClose, 32) -  EMA(df$AdjClose, 128)) / (df$Close * df$Volatility / 16) * 2.79
#   df$Forecast64 <- (EMA(df$AdjClose, 64) -  EMA(df$AdjClose, 256)) / (df$Close * df$Volatility / 16) * 1.91
#   df$Forecast128 <- (EMA(df$AdjClose, 128) -  EMA(df$AdjClose, 512)) / (df$Close * df$Volatility / 16) * 1.50
#   df$Acc16 <- c(rep(NA, 16), diff(df$Forecast16, 16)) * 1.90
#   df$Acc32 <- c(rep(NA, 32), diff(df$Forecast32, 32)) * 1.98
#   df$Acc64 <- c(rep(NA, 64), diff(df$Forecast64, 64)) * 2.05
#   df$Acc128 <- c(rep(NA, 128), diff(df$Forecast128, 128)) * 2.10
#   df$ForecastTest <- cap_forecast(rowMeans(cbind(df$Acc16 , df$Acc32 , df$Acc64, df$Acc128)) * 1.55)
# }
# COT
# COT <- read_csv("/home/marco/trading/Systems/Monopoly/COT.csv")
# select(COT, c("Market and Exchange Names", "As of Date in Form YYYY-MM-DD", "Noncommercial Positions-Long (All)","Noncommercial Positions-Short (All)", "Commercial Positions-Long (All)","Commercial Positions-Short (All)")) -> a
# colnames(a) <- c("Name", "Date", "NC_long", "NC_short", "C_long", "C_short")
# mutate(a, NC=NC_long/(NC_long+NC_short),C=C_long/(C_long+C_short) ) -> COT
# if(weights[["Test"]]  > 0) {
#     df$COT <- to_load[to_load$Symbol==symbol,]$COT %>% gsub('\"', '', .)
#     if(is.na(df$COT[1]) | symbol =="CL"| symbol =="KO"| symbol =="TG") {
#         df$ForecastTest <- 0
#
#     } else {
#     cot <- filter(COT, Name==df$COT[1])  %>%  select(Date, C)
#     df_ <- df
#     df_ <- merge(df_, cot, by="Date", all = TRUE, incomparables = NA)
#     df <- arrange(df_, Date) %>% mutate(C = na.locf(C, na.rm=F))
#     df$C <- lag(df$C );
#     r <- c(0,diff(log(df$C))); r[r==0] <- NA; r = na.locf(r, na.rm=F)
#     f <- AbsoluteStrength(df$C, 20) /  calculate_volatility(r) * 28
#     f <- multiple_AS(df$C, df$C, calculate_volatility(r))
#     forecast <- f
#     df$ForecastTest <- (forecast)
#     }
# }
}
# Final trade
df$Forecast <- ( weights[["Trend"]] * df$ForecastTrend +
weights[["Carry"]] * df$ForecastCarry +
weights[["CSM"]] * df$ForecastCSM +
weights[["Skew"]] * df$ForecastSkew +
weights[["Test"]] * df$ForecastTest) / 10
df$Forecast <- lag(df$Forecast)
df$Excess <- df$Return * df$Position * df$Forecast * IDM
df <- filter(df, year(Date) >= starting_year)
forecasts[[symbol]]  <-   select(df, Date, Forecast)
exposures[[symbol]]  <-  mutate(df, Exposure=Position * Forecast) %>% select(Date, Exposure)
returns[[symbol]]  <-  select(df, Date, Return)
vols[[symbol]]  <-  select(df, Date, Volatility)
results[[symbol]] <- select(df, Date, Excess)
} # end of symbol sloop
print("")
portfolio <- merge_portfolio_list(results)
weights <- 1 / length(names(Assets)) # equal weights per instrument
res <- portfolio_summary(as.matrix(portfolio[,-1]) * weights, dates = portfolio$Date, plot_stats = TRUE, symbol_wise = symbol_wise  )
print(res$Aggregate %>% unlist)
res <- portfolio_summary(as.matrix(portfolio[,-1]) * portfolio_weights, dates = as.Date(portfolio$Date), plot_stats = TRUE, symbol_wise = symbol_wise)
print(res$Aggregate %>% unlist)
all_forecasts <- do.call(rbind,forecasts)[,2] %>% na.omit
avg_forecast_turnover <- round(252 * mean(abs(diff(all_forecasts/10))), 2)
avg_trade_turnover <- round(length(rle(all_forecasts>0)$length) / (length(all_forecasts)/252), 2)
print(paste("Average Forecast Turnover:", avg_forecast_turnover))
print(paste("Average Trade Turnover:", avg_trade_turnover))
if(symbol_wise) {
res$Symbols$Class <- lapply(Assets[names(results)], function(x) x$Class[1]) %>% unlist
group_by(res$Symbols, Class) %>% summarise(SR_mean=mean(`Sharpe ratio`, na.rm=T), SR_sd=sd(`Sharpe ratio`, na.rm=T))
}
{
## Some figures takes from the Risk Management section
# Figure 97: Portfolio volatility, check it is in line with target volatility
# full_df_exposures <- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), exposures) %>% arrange(Date)
# full_df_returns <- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), returns) %>% arrange(Date)
# full_df_vols<- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), vols) %>% arrange(Date)
# a <- sapply(181:nrow(full_df_returns),  function(i) { w <- as.numeric(full_df_exposures[i,-1]); w[is.na(w)] <- 0; S <-  cov(full_df_returns[(i-180):i,-1], use="pairwise.complete.obs"); S[is.na(S)] <- 0; sqrt( w %*% S %*% w  )  } )
# plot.ts(a*100); abline(h=target_vol*100)
# a <- rowSums(abs(full_df_exposures[,-1] * full_df_vols[,-1]), na.rm=T)
}
{
suppressMessages(library(tidyverse))
suppressMessages(library(moments))
suppressMessages(library(TTR))
suppressMessages(library(lubridate))
suppressMessages(library(tsibble))
suppressMessages(library(zoo))
suppressMessages(library(moments))
suppressMessages(library(ggthemes))
suppressMessages(library(data.table))
suppressMessages(library(Rfast))
suppressMessages(library(optparse))
source("/home/marco/trading/Systems/Common/RiskManagement.R")
}
# Functions
{
# for some reason, scrapped CMC daily data are leaded one day, check for example https://www.cmcmarkets.com/en-gb/instruments/coffee-arabica-jul-2023?search=1
# weekly data is leaded 2 days
load_current_cmc_data <- function(symbol,  scrape_dir, load_daily=TRUE, load_weekly=TRUE, lagged=TRUE){
symbol_dir <- paste0(scrape_dir, "/", symbol)
df <- data.frame(Date=Date(), Close=as.numeric(), Period=as.character())
# # load intra-day data
df_intraday <- data.frame(Date=NA, Close=NA)
system(paste("cat", paste(list.files(symbol_dir, pattern = "intraday", full.names = TRUE), collapse = " "),  " | sort -u  > _tmp"))
df_intraday <- fread("_tmp", header= FALSE)
file.remove("_tmp")
colnames(df_intraday) <- c("Date", "Close")
df_intraday$Date <- as_date(df_intraday$Date)
df_intraday <- arrange(df_intraday, Date) %>% group_by(Date) %>% summarize(Date=last(Date), Close=last(Close))
#df_intraday <- tail(df_intraday, 1)
df_intraday$Period <- "Intraday"
# # load daily data, lag date by one day
df_daily <- data.frame(Date=Date(), Close=as.numeric(), Period=as.character())
if(load_daily) {
system(paste("cat", paste(list.files(symbol_dir, pattern = "daily", full.names = TRUE), collapse = " "),  " | sort -u  > _tmp"))
df_daily <- fread("_tmp", header= FALSE)
colnames(df_daily) <- c("Date", "Close")
df_daily <- arrange(df_daily, Date)
if(lagged)
df_daily <- df_daily %>% mutate(Date = as_date((ifelse(wday(Date) == "Fri", Date+2, Date+1  ))))
# only keep daily data up to the last element of intradaily data
df_daily <-  dplyr::filter(df_daily, Date < df_intraday$Date[1])
df_daily$Period <- "Daily"
file.remove("_tmp")
}
# load weekly data, lag date by two days
df_weekly <- data.frame(Date=Date(), Close=as.numeric(), Period=as.character())
if(load_weekly) {
system(paste("cat", paste(list.files(symbol_dir, pattern = "weekly", full.names = TRUE), collapse = " "),  " | sort -u  > _tmp"))
df_weekly <- fread("_tmp", header= FALSE)
colnames(df_weekly) <- c("Date", "Close")
df_weekly <- arrange(df_weekly, Date)
if(lagged) {
df_weekly[,1] <- df_weekly[,1]+2
df_weekly <- df_weekly[-1,]
}
# only keep weekly data up to the start of daily data
df_weekly <- mutate(df_weekly, Date=as.Date(Date)) %>% dplyr::filter(Date < df_daily$Date[1])
# interpolate weekly data to create daily data
# first, recreate full daily Date excluding weekends
dates <- seq(df_weekly$Date[1], df_weekly$Date[length(df_weekly$Date)], by=1) %>%
as_tibble() %>% mutate(Date=value) %>% select(-value) %>% dplyr::filter(!(lubridate::wday(Date, label = TRUE) %in% c("Sat", "Sun")))
# then interpolate
df_weekly <- merge(df_weekly, dates, by="Date", all=TRUE) %>% mutate(Close=na.approx(Close), Date=as_date(Date))
df_weekly$Period <- "Weekly"
file.remove("_tmp")
}
if(load_daily & load_weekly)
df <- rbind(df_weekly, df_daily) %>% group_by(Date) %>% summarize(Date=last(Date), Close=last(Close), Period=last(Period)) %>% ungroup %>% arrange(Date)
df <- rbind(df, df_intraday) %>% group_by(Date) %>% summarize(Date=last(Date), Close=last(Close), Period=last(Period)) %>% ungroup %>% arrange(Date)
#df <- rbind(df, mutate(df_intraday, Date=as_date(Date))) %>% mutate(Date=as.Date(Date))
df <- na.omit(df) %>% dplyr::select(Date, Close, Period)
if((length(unique(df$Date)) != length(df$Date)))
stop(paste("Duplicate dates in ", symbol))
if(tail(df$Date, 1) != today())
warning(paste("Last date does not correspond to today in ", symbol))
return(df)
}
load_current_cmc_hc <- function(symbol,  dir){
symbol_dir <- paste0(dir, "/", symbol)
l <- tail(sort(list.files(symbol_dir, pattern = "holding_cost")), 1)
f <- read_csv(paste0(symbol_dir, "/", l), show_col_types = FALSE, col_names = FALSE)
if(dim(f)[1] == 0) {
stop(paste("Holding cost file empty for symbol:", symbol))
hc <- c(0,0)
} else {
hc <- unlist(f[,-1])
}
return(hc)
}
load_historical_cmc_data <- function(symbol, dir){
symbol_file <- paste0(dir, "/", symbol, ".csv")
df <- fread(symbol_file) %>% mutate(Date=as.Date(Date)) %>% arrange(Date)
return(df)
}
multiple_EMA <- function(adjclose, close, volatility, spans=c(4, 8, 16, 32, 64), scalars=c(8.53, 5.95, 4.1, 2.79, 1.91), mult=4, cap=20, period=252) {
n <- length(spans)
EWMACs <- lapply(1:n, function(i) EMA(adjclose, spans[i]) -  EMA(adjclose, spans[i]*mult))
EWMACs <- lapply(1:n, function(i) EWMACs[[i]] / (close * volatility / sqrt(period)) * scalars[i] )
EWMACs <- lapply(1:n, function(i) cap_forecast(EWMACs[[i]], cap))
forecast <- rowMeans(do.call(cbind, EWMACs))
return(forecast)
}
multiple_DC <- function(adjclose, close, volatility, spans=c(20, 40, 80, 160, 320), scalars=c(0.67, 0.70, 0.73, 0.74, 0.74), cap=20, period=252) {
n <- length(spans)
DCs <- lapply(1:n, function(i) {dc <- DonchianChannel(adjclose, spans[i]); (adjclose - dc[,2]) / abs(dc[,1] - dc[,3])})
DCs <- lapply(1:n, function(i) EMA(na.locf(DCs[[i]], na.rm=F) * 40, spans[i]/4) * scalars[i] )
DCs <- lapply(1:n, function(i) cap_forecast(DCs[[i]], cap))
forecast <- rowMeans(do.call(cbind, DCs))
return(forecast)
}
KalmanFilterIndicator <- function(x, sharpness=1, K=1) {
n <- length(x)
value <- rep(NA, n)
distance <- rep(NA, n)
velocity <- rep(NA, n)
error <- rep(NA, n)
value[1] <- x[1]
velocity[1] <- 0
distance[1] <- 0
error[1] <- 0
for(i in 2:length(x)){
distance[i] <- x[i] - value[i-1]
error[i] <- value[i-1] + distance[i] * sqrt(sharpness * K / 100)
velocity[i] <- velocity[i-1] + distance[i]*K/100
value[i] <- error[i]+velocity[i]
}
return(cbind(value=value, velocity=velocity, distance=distance, error=error))
}
multiple_KF <- function(adjclose, close, volatility, spans=c(0.5, 1, 2, 5, 10), scalars=c(66, 55, 46, 37, 31), cap=20, period=252) {
n <- length(spans)
KFs <- lapply(1:n, function(i) KalmanFilterIndicator(adjclose, sharpness = 1, K = spans[i])[,2])
KFs <- lapply(1:n, function(i) KFs[[i]] / ((close * volatility / sqrt(period))) * scalars[i] )
KFs <- lapply(1:n, function(i) cap_forecast(KFs[[i]], cap))
forecast <- rowMeans(do.call(cbind, KFs))
return(forecast)
}
TII <- function(x, P = 60, ma=TTR::EMA) {
ma_p <- ma(x, P)
diff <- x - ma_p
pos_count <- runSum(diff>0, floor(P/2))
return(400 * (pos_count) / P - 100)
}
multiple_TII <- function(adjclose, close, volatility, spans=c(21, 63, 126, 252)) {
n <- length(spans)
TII <- lapply(1:n, function(i) TII(adjclose, P = spans[i]) / 5)
forecast <- rowMeans(do.call(cbind, TII))
return(forecast)
}
# basis and volatility are in percentage
multiple_Carry <- function(basis, expiry_difference, volatility, spans=c(21, 63, 126), scalar=30, expiry_span=12, cap=20) {
n <- length(spans)
Carry <- (basis / (expiry_difference / expiry_span)) / ( volatility )
Carry <- na.locf(Carry, na.rm=FALSE); Carry[is.na(Carry)] <- 0
EMAs <- lapply(1:n, function(i) EMA(Carry, spans[i]) * scalar)
EMAs <- lapply(1:n, function(i)  cap_forecast(EMAs[[i]], cap))
forecast <- rowMeans(do.call(cbind, EMAs))
return(forecast)
}
relative_volatility <- function(volatility, period=2520) {
return(unlist(Map(function(i) mean(tail(volatility[1:i], period), na.rm=TRUE), 1:length(volatility))))
}
# scalar have been readapted to fit CMC cash data
multiple_Skew <- function(returns, spans=c(60, 120, 240), scalars=c(21.1, 21.8, 22.8), cap=20) {
n <- length(spans)
returns[is.na(returns)] <- 0
Skews <- lapply(1:n, function(i) -rollapply(returns, width=spans[i], skew,  fill=NA, align="right"))
Skews <-  lapply(1:n, function(i) replace(Skews[[i]], is.na(Skews[[i]]), 0))
Skews <-  lapply(1:n, function(i) EMA(Skews[[i]], ceiling(spans[i]/4)) * scalars[i])
Skews <- lapply(1:n, function(i) cap_forecast(Skews[[i]], cap))
forecast <- rowMeans(do.call(cbind, Skews))
return(forecast)
}
# Parameters (maybe put them in a config file?)
{
main_dir <- "/home/marco/trading/Systems/Monopoly/ExecuteATFS/"
positions_file <- paste0(main_dir, "POSITIONS.csv")
instrument_file <- paste0(main_dir, "INSTRUMENTS.csv")
portfolio_file <- paste0(main_dir, "PORTFOLIO.csv")
FX_file <- paste0(main_dir, "FX.csv")
scrape_dir <- paste0(main_dir, "Data/Scrape/")
historical_dir <- paste0(main_dir, "Data/Historical/")
current_dir <- paste0(main_dir, "Data/Scrape/")
FX_dir <- paste0(main_dir, "FX/")
logs_dir <- paste0(main_dir, "Logs/")
scrape_script <- "SCRAPE_DAILY_DATA.sh"
target_vol <- 0.33
IDM = 3.5
FDMtrend <- 1.19
FDMcarry <- 3.0
FDMskew <- 1.21 # relaculated using CMC data and the skew rules above
FDM <- 1.5
strategy_weights <- list("Trend" = 0.4, "Carry" = 0.5, "Skew" = 0.1)
corr_length <- 25
portfolio_buffering_level <- 0.1
position_buffering_level <- 0.2
trade_shadow_cost <- 10
dry_run <- FALSE
}
# Read command arguments
option_list = list(
make_option(c("-c", "--capital"),  type="double", help="Account Capital."),
make_option(c("-d", "--dryrun"), action="store_true", default=FALSE, help="Do not write any file.")
);
opt_parser = OptionParser(option_list=option_list);
opt = parse_args(opt_parser);
capital <- opt$capital
dry_run <- opt$dryrun
capital
capital <- 14500
dry_run
dry_run <- TRUE
print(paste("Capital:", capital, "Target Volatility:", target_vol, "IDM:", IDM,
"Portfolio Buffering Level:", portfolio_buffering_level, "Position Buffering Level:", position_buffering_level,
"Trading Shadow Cost:", trade_shadow_cost))
# create dirs&files
today_string <- gsub("-", "", today())
now_string <- gsub("-| |:", "", now())
if(!dir.exists(logs_dir))
dir.create(logs_dir)
if(!dir.exists(current_dir))
dir.create(current_dir)
if(!dir.exists(FX_dir))
dir.create(FX_dir)
# load instruments infos and calculate instruments weights from asset classes groups (could be coded a little better maybe?)
print("Loading symbols info and previous positions file...")
instruments_info <- read_csv(instrument_file, col_names = TRUE, show_col_types = FALSE) %>% arrange(Symbol)
instruments_info$Weight <- instruments_info %>% group_by(Symbol) %>%
summarise(Symbol=Symbol,
n0=length(unique(instruments_info$Class1)),
n1=length(unique(instruments_info$Class2[instruments_info$Class1==Class1])),
n2=length((instruments_info$Class2[instruments_info$Class2==Class2]))) %>%
ungroup %>% mutate(Weight=1/n0/n1/n2) %>% pull(Weight)
# load previous positions file
if(!file.exists(positions_file))
stop("Previous positions file does not exists.")
previous_trading <- read_csv(positions_file, col_names = TRUE, show_col_types = FALSE) %>% arrange(Symbol)
# scrape price and FX data
print("Scraping price and FX data...")
setwd(main_dir)
# load price data from previous scrape
print("Loading price data...")
instruments_data <- list()
for(symbol in instruments_info$Symbol) {
cat(paste(symbol, ""))
historical_data <- load_historical_cmc_data(symbol, historical_dir)
current_data <- load_current_cmc_data(symbol, scrape_dir, load_daily = FALSE, load_weekly = FALSE)
symbol_data <- rbind(historical_data, current_data) %>% group_by(Date) %>% summarize(Date=last(Date), Close=last(Close), Period=last(Period)) %>% ungroup %>% arrange(Date)
current_hc <- load_current_cmc_hc(symbol, scrape_dir)
instruments_data[[symbol]] <- list(Price=symbol_data, HC=current_hc)
nas <- sum(is.na(instruments_data[[symbol]]$Price$Close))
if(nas > 0) {
warning(paste(symbol, "price data has", nas, "NAs. They have been filled"))
instruments_data[[symbol]]$Price$Close <- na.locf(instruments_data[[symbol]]$Price$Close, na.rm=FALSE)
}
# load FX data from previous scrape
print("")
print("Loading FX data...")
FX_names <- read_csv(FX_file, col_names = FALSE, show_col_types = FALSE) %>% unlist
files <- list()
for(fx in FX_names) {
cat(paste(fx, ""))
f <- read_csv(paste0(FX_dir, "/", fx, ".csv"), col_names = TRUE, show_col_types = FALSE)
colnames(f) <- c("Date", "Rate")
files[[fx]] <- arrange(f, Date) %>% na.locf(na.rm=FALSE) %>% tail(1)
}
FX_rates <- do.call(rbind, files) %>% mutate(FX=toupper(sub("eur", "", FX_names)))
colnames(FX_rates) <- c("Date", "Rate", "FX")
# the covariance matrix
print("Calculate covariance matrix...")
closes <- lapply(instruments_data, function(x)x[[1]] %>% select(Date, Close))
closes_merged <- Reduce(function(...) full_join(..., by="Date"), closes) %>% arrange(Date)
colnames(closes_merged) <- c("Date", names(instruments_data))
daily_returns <- data.frame(Date=as.Date(closes_merged$Date), apply(closes_merged[,-1], 2, function(x) c(0, diff(log(x)))))
daily_returns <- na.omit(daily_returns) # Potentially dangerous?
weekly_returns <- mutate(daily_returns, Date=yearweek(Date)) %>% group_by(Date) %>% summarise(across(everything(), ~mean(.x,na.rm=TRUE)))
vols <- data.frame(Date=daily_returns$Date, apply(daily_returns[,-1], 2, function(x) calculate_volatility(x)))
#cor_matrix <- cor(tail(weekly_returns[,-1], corr_length), use="pairwise.complete.obs") # static last corr matrix
Q <- runCorMatrix(as.matrix(weekly_returns[,-1])) # running corr matrix (note: if we use absolute correlation we get an error in the dynamic portfolio)
cor_matrix <- Q[[length(Q)]]
last_day_vol <- tail(vols, 1)[-1]
cov_matrix <- diag(last_day_vol) %*% cor_matrix %*% diag(last_day_vol)
rownames(cov_matrix) <- colnames(cov_matrix) <- names(instruments_data)
corrplot::corrplot(cor_matrix, ordeR="hclust")
corrplot::corrplot(cor_matrix, order="hclust")
calculate_IDM(weekly_returns[,-1], weights =  instruments_info$Weight)
calculate_IDM(daily_returns[,-1], weights =  instruments_info$Weight)
calculate_IDM(daily_returns[,-1], weights =  instruments_info$Weight, absolute_correlation = FALSE)
warnings()
calculate_IDM(daily_returns[,-1], weights =  instruments_info$Weight, absolute_correlation = FALSE)
calculate_IDM(weekly_returns[,-1], weights =  instruments_info$Weight, absolute_correlation = FALSE)
weekly_returns[,-1] -> a
a[a<0] <- 0
calculate_IDM(a, weights =  instruments_info$Weight, absolute_correlation = FALSE)
