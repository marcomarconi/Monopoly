}
allNPs <- do.call(rbind, NPs)
Asset_class_indices <- group_by(allNPs, Class, Date) %>% summarise(Symbol=Symbol, R=mean(dNP)) %>%
arrange(Class, Date) %>% select(-Symbol)  %>%  unique %>% group_by( Class) %>% mutate(A=cumsum(R)) %>% ungroup()
}
# iterate over symbols
for(symbol in names(Assets)) {
cat(paste(symbol, ""))
df <- Assets[[symbol]]
df$Volatility = calculate_volatility(df$Return)
df$Position = lag(target_vol / df$Volatility)
df$ForecastTrend <- df$ForecastCarry <- df$ForecastCSM <- df$ForecastSkew <- df$ForecastTest <- 0
# Relative volatility (strategy 13, improvement is minimal, and we only apply it to trend)
df$M <- 1
if(relative_vol) {
df$RV <- relative_volatility(df$Volatility)
df$Q <- sapply(1:length(df$RV), function(i) sum(df$RV[i] > df$RV[1:i], na.rm=TRUE) / i)
df$M <- EMA(2 - 1.5 * df$Q, 10)
}
# Correlation with market
df$Cor <- 1
if(market_cor) {
df <- merge(df, select(BackAdj$ES, Date, Return) %>% mutate(ES=Return) %>% select(-Return), by="Date")
df$Cor <- multiple_cor(df$Return %>% na.locf(na.rm=F), df$ES %>% na.locf(na.rm=F))
df$Cor <- -df$Cor + 1
}
# Trend-following (strategy 9)
if(weights[["Trend"]]  > 0) {
df$ForecastEMA <- multiple_EMA(df$AdjClose, df$Close, df$Volatility)
df$ForecastDC <- multiple_DC(df$AdjClose, df$Close, df$Volatility)
df$ForecastKF <- multiple_KF(df$AdjClose, df$Close, df$Volatility)
df$ForecastTII <- multiple_TII(df$AdjClose, df$Close, df$Volatility)
df$ForecastTrend <- rowMeans(cbind(df$ForecastEMA, df$ForecastDC, df$ForecastKF, df$ForecastTII)) * FDMtrend * df$M * df$Cor
df$ForecastTrend <- cap_forecast(df$ForecastTrend)
}
# Carry (strategy 10)
if(weights[["Carry"]]  > 0) {
df$ForecastCarry <- multiple_Carry(df$Basis, df$Basis_distance, df$Volatility)  * FDMcarry
df$ForecastCarry <- cap_forecast(df$ForecastCarry)
}
# Cross-sectional momentum (strategy 19)
if(weights[["CSM"]]  > 0) {
df <- merge(df, filter(Asset_class_indices, Class==df$Class[1]) %>%  select(Date, A), by="Date") # Asset_class_indices obtained from before
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$ForecastCSM <- cross_sectional_momentum(df$NP, df$A) * FDMcsm
df$ForecastCSM <- cap_forecast(df$ForecastCSM)
}
# Skewness (strategy 24)
if(weights[["Skew"]]  > 0) {
df$ForecastSkew <- returns_skew(df$Return) * FDMskew
df$ForecastSkew <- cap_forecast(df$ForecastSkew)
}
# # Kurtosis
if(weights[["Test"]]  > 0) {
#df$ForecastTest <- returns_kurtosis(df$Return) * FDMkurtosis
#forecast <- rollapply(df$Return, width=20, kurt,  fill=NA, align="right")
df$ForecastTest <- sign(multiple_EMA(df$AdjClose, df$Close, df$Volatility) )# * forecast
df$ForecastTest <- cap_forecast(df$ForecastTest)
}
# Acceleration
# if(weights[["Test"]]  > 0) {
#   df$Forecast16 <- (EMA(df$AdjClose, 16) -  EMA(df$AdjClose, 64)) / (df$Close * df$Volatility / 16) * 4.1
#   df$Forecast32 <- (EMA(df$AdjClose, 32) -  EMA(df$AdjClose, 128)) / (df$Close * df$Volatility / 16) * 2.79
#   df$Forecast64 <- (EMA(df$AdjClose, 64) -  EMA(df$AdjClose, 256)) / (df$Close * df$Volatility / 16) * 1.91
#   df$Forecast128 <- (EMA(df$AdjClose, 128) -  EMA(df$AdjClose, 512)) / (df$Close * df$Volatility / 16) * 1.50
#   df$Acc16 <- c(rep(NA, 16), diff(df$Forecast16, 16)) * 1.90
#   df$Acc32 <- c(rep(NA, 32), diff(df$Forecast32, 32)) * 1.98
#   df$Acc64 <- c(rep(NA, 64), diff(df$Forecast64, 64)) * 2.05
#   df$Acc128 <- c(rep(NA, 128), diff(df$Forecast128, 128)) * 2.10
#   df$ForecastTest <- cap_forecast(rowMeans(cbind(df$Acc16 , df$Acc32 , df$Acc64, df$Acc128)) * 1.55)
# }
# Final trade
df$Forecast <- ( weights[["Trend"]] * df$ForecastTrend +
weights[["Carry"]] * df$ForecastCarry +
weights[["CSM"]] * df$ForecastCSM +
weights[["Skew"]] * df$ForecastSkew +
weights[["Test"]] * df$ForecastTest) / 10
df$Forecast <- lag(df$Forecast)
df$Excess <- df$Return * df$Position * df$Forecast * IDM
exposures[[symbol]]  <-  mutate(df, Exposure=Position * Forecast) %>% select(Date, Exposure)
returns[[symbol]]  <-  select(df, Date, Return)
vols[[symbol]]  <-  select(df, Date, Volatility)
results[[symbol]] <- select(df, Date, Excess)
}
print("")
portfolio <- merge_portfolio_list(results)
res <- portfolio_summary(as.matrix(portfolio[,-1]), dates = portfolio$Date, plot_stats = TRUE, symbol_wise = symbol_wise  )
print(res$Aggregate %>% unlist)
if(symbol_wise) {
res$Symbols$Class <- lapply(Assets, function(x) x$Class[1]) %>% unlist
group_by(res$Symbols, Class) %>% summarise(SR_mean=mean(`Sharpe ratio`), SR_sd=sd(`Sharpe ratio`))
}
## Some figures takes from the Risk Management section
# Figure 97: Portfolio volatility, check it is in line with target volatility
# full_df_exposures <- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), exposures) %>% arrange(Date)
# full_df_returns <- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), returns) %>% arrange(Date)
# full_df_vols<- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), vols) %>% arrange(Date)
# a <- sapply(181:nrow(full_df_returns),  function(i) { w <- as.numeric(full_df_exposures[i,-1]); w[is.na(w)] <- 0; S <-  cov(full_df_returns[(i-180):i,-1], use="pairwise.complete.obs"); S[is.na(S)] <- 0; sqrt( w %*% S %*% w  )  } )
# plot.ts(a*100); abline(h=target_vol*100)
# a <- rowSums(abs(full_df_exposures[,-1] * full_df_vols[,-1]), na.rm=T)
}
# Final Backtest
{
# A subset of instrument I might actually trade
CMC_selection <- c("ZN","GG","CC","KC","HG","ZC","CT","CL","IM","GC","HE","LE","LS","NG","ZO","OJ","ZR","ZS","ES","SB","DX","ZW","D6")
Assets <- BackAdj# or BackAdj[CMC_selection]
results <- list()
exposures <- list()
returns <- list()
vols <- list()
target_vol <- 0.25
IDM = 2.5
FDMtrend <- 1.33
FDMcarry <- 1.05
FDMcsm <- 1.4
FDMskew <- 1.18
FDMkurtosis <- 1.18
# Apply relative volatility
relative_vol <- FALSE
# Apply Marker Correlation
market_cor <- TRUE
# Trend, Carry, CSM, Skew, Test
weights <- list("Trend"=0, "Carry"=0, "CSM"=0, "Skew"=1, "Test"=0)
if(sum(unlist(weights)) != 1)
warning("Strategy weights do not sum to zero")
# Symbol-wise results
symbol_wise <- TRUE
# Asset class indices
if(weights[["CSM"]] > 0) {
NPs <- list()
for(n in names(Assets)) {
df <- Assets[[n]]
df$Volatility = calculate_volatility(df$Return)
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$dNP = c(0, diff(df$NP))
NPs[[n]] <- select(df, Date, Symbol, Class, NP, dNP)
}
allNPs <- do.call(rbind, NPs)
Asset_class_indices <- group_by(allNPs, Class, Date) %>% summarise(Symbol=Symbol, R=mean(dNP)) %>%
arrange(Class, Date) %>% select(-Symbol)  %>%  unique %>% group_by( Class) %>% mutate(A=cumsum(R)) %>% ungroup()
}
# iterate over symbols
for(symbol in names(Assets)) {
cat(paste(symbol, ""))
df <- Assets[[symbol]]
df$Volatility = calculate_volatility(df$Return)
df$Position = lag(target_vol / df$Volatility)
df$ForecastTrend <- df$ForecastCarry <- df$ForecastCSM <- df$ForecastSkew <- df$ForecastTest <- 0
# Relative volatility (strategy 13, improvement is minimal, and we only apply it to trend)
df$M <- 1
if(relative_vol) {
df$RV <- relative_volatility(df$Volatility)
df$Q <- sapply(1:length(df$RV), function(i) sum(df$RV[i] > df$RV[1:i], na.rm=TRUE) / i)
df$M <- EMA(2 - 1.5 * df$Q, 10)
}
# Correlation with market
df$Cor <- 1
if(market_cor) {
df <- merge(df, select(BackAdj$ES, Date, Return) %>% mutate(ES=Return) %>% select(-Return), by="Date")
df$Cor <- multiple_cor(df$Return %>% na.locf(na.rm=F), df$ES %>% na.locf(na.rm=F))
df$Cor <- -df$Cor + 1
}
# Trend-following (strategy 9)
if(weights[["Trend"]]  > 0) {
df$ForecastEMA <- multiple_EMA(df$AdjClose, df$Close, df$Volatility)
df$ForecastDC <- multiple_DC(df$AdjClose, df$Close, df$Volatility)
df$ForecastKF <- multiple_KF(df$AdjClose, df$Close, df$Volatility)
df$ForecastTII <- multiple_TII(df$AdjClose, df$Close, df$Volatility)
df$ForecastTrend <- rowMeans(cbind(df$ForecastEMA, df$ForecastDC, df$ForecastKF, df$ForecastTII)) * FDMtrend * df$M * df$Cor
df$ForecastTrend <- cap_forecast(df$ForecastTrend)
}
# Carry (strategy 10)
if(weights[["Carry"]]  > 0) {
df$ForecastCarry <- multiple_Carry(df$Basis, df$Basis_distance, df$Volatility)  * FDMcarry
df$ForecastCarry <- cap_forecast(df$ForecastCarry)
}
# Cross-sectional momentum (strategy 19)
if(weights[["CSM"]]  > 0) {
df <- merge(df, filter(Asset_class_indices, Class==df$Class[1]) %>%  select(Date, A), by="Date") # Asset_class_indices obtained from before
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$ForecastCSM <- cross_sectional_momentum(df$NP, df$A) * FDMcsm
df$ForecastCSM <- cap_forecast(df$ForecastCSM)
}
# Skewness (strategy 24)
if(weights[["Skew"]]  > 0) {
df$ForecastSkew <- -returns_skew(df$Return) * FDMskew
df$ForecastSkew <- cap_forecast(df$ForecastSkew)
}
# # Kurtosis
if(weights[["Test"]]  > 0) {
#df$ForecastTest <- returns_kurtosis(df$Return) * FDMkurtosis
#forecast <- rollapply(df$Return, width=20, kurt,  fill=NA, align="right")
df$ForecastTest <- sign(multiple_EMA(df$AdjClose, df$Close, df$Volatility) )# * forecast
df$ForecastTest <- cap_forecast(df$ForecastTest)
}
# Acceleration
# if(weights[["Test"]]  > 0) {
#   df$Forecast16 <- (EMA(df$AdjClose, 16) -  EMA(df$AdjClose, 64)) / (df$Close * df$Volatility / 16) * 4.1
#   df$Forecast32 <- (EMA(df$AdjClose, 32) -  EMA(df$AdjClose, 128)) / (df$Close * df$Volatility / 16) * 2.79
#   df$Forecast64 <- (EMA(df$AdjClose, 64) -  EMA(df$AdjClose, 256)) / (df$Close * df$Volatility / 16) * 1.91
#   df$Forecast128 <- (EMA(df$AdjClose, 128) -  EMA(df$AdjClose, 512)) / (df$Close * df$Volatility / 16) * 1.50
#   df$Acc16 <- c(rep(NA, 16), diff(df$Forecast16, 16)) * 1.90
#   df$Acc32 <- c(rep(NA, 32), diff(df$Forecast32, 32)) * 1.98
#   df$Acc64 <- c(rep(NA, 64), diff(df$Forecast64, 64)) * 2.05
#   df$Acc128 <- c(rep(NA, 128), diff(df$Forecast128, 128)) * 2.10
#   df$ForecastTest <- cap_forecast(rowMeans(cbind(df$Acc16 , df$Acc32 , df$Acc64, df$Acc128)) * 1.55)
# }
# Final trade
df$Forecast <- ( weights[["Trend"]] * df$ForecastTrend +
weights[["Carry"]] * df$ForecastCarry +
weights[["CSM"]] * df$ForecastCSM +
weights[["Skew"]] * df$ForecastSkew +
weights[["Test"]] * df$ForecastTest) / 10
df$Forecast <- lag(df$Forecast)
df$Excess <- df$Return * df$Position * df$Forecast * IDM
exposures[[symbol]]  <-  mutate(df, Exposure=Position * Forecast) %>% select(Date, Exposure)
returns[[symbol]]  <-  select(df, Date, Return)
vols[[symbol]]  <-  select(df, Date, Volatility)
results[[symbol]] <- select(df, Date, Excess)
}
print("")
portfolio <- merge_portfolio_list(results)
res <- portfolio_summary(as.matrix(portfolio[,-1]), dates = portfolio$Date, plot_stats = TRUE, symbol_wise = symbol_wise  )
print(res$Aggregate %>% unlist)
if(symbol_wise) {
res$Symbols$Class <- lapply(Assets, function(x) x$Class[1]) %>% unlist
group_by(res$Symbols, Class) %>% summarise(SR_mean=mean(`Sharpe ratio`), SR_sd=sd(`Sharpe ratio`))
}
## Some figures takes from the Risk Management section
# Figure 97: Portfolio volatility, check it is in line with target volatility
# full_df_exposures <- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), exposures) %>% arrange(Date)
# full_df_returns <- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), returns) %>% arrange(Date)
# full_df_vols<- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), vols) %>% arrange(Date)
# a <- sapply(181:nrow(full_df_returns),  function(i) { w <- as.numeric(full_df_exposures[i,-1]); w[is.na(w)] <- 0; S <-  cov(full_df_returns[(i-180):i,-1], use="pairwise.complete.obs"); S[is.na(S)] <- 0; sqrt( w %*% S %*% w  )  } )
# plot.ts(a*100); abline(h=target_vol*100)
# a <- rowSums(abs(full_df_exposures[,-1] * full_df_vols[,-1]), na.rm=T)
}
returns_skew
View(res$Symbols)
# Final Backtest
{
# A subset of instrument I might actually trade
CMC_selection <- c("ZN","GG","CC","KC","HG","ZC","CT","CL","IM","GC","HE","LE","LS","NG","ZO","OJ","ZR","ZS","ES","SB","DX","ZW","D6")
Assets <- BackAdj# or BackAdj[CMC_selection]
results <- list()
exposures <- list()
returns <- list()
vols <- list()
target_vol <- 0.25
IDM = 2.5
FDMtrend <- 1.33
FDMcarry <- 1.05
FDMcsm <- 1.4
FDMskew <- 1.18
FDMkurtosis <- 1.18
# Apply relative volatility
relative_vol <- FALSE
# Apply Marker Correlation
market_cor <- TRUE
# Trend, Carry, CSM, Skew, Test
weights <- list("Trend"=0, "Carry"=0, "CSM"=0, "Skew"=1, "Test"=0)
if(sum(unlist(weights)) != 1)
warning("Strategy weights do not sum to zero")
# Symbol-wise results
symbol_wise <- TRUE
# Asset class indices
if(weights[["CSM"]] > 0) {
NPs <- list()
for(n in names(Assets)) {
df <- Assets[[n]]
df$Volatility = calculate_volatility(df$Return)
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$dNP = c(0, diff(df$NP))
NPs[[n]] <- select(df, Date, Symbol, Class, NP, dNP)
}
allNPs <- do.call(rbind, NPs)
Asset_class_indices <- group_by(allNPs, Class, Date) %>% summarise(Symbol=Symbol, R=mean(dNP)) %>%
arrange(Class, Date) %>% select(-Symbol)  %>%  unique %>% group_by( Class) %>% mutate(A=cumsum(R)) %>% ungroup()
}
# iterate over symbols
for(symbol in names(Assets)) {
cat(paste(symbol, ""))
df <- Assets[[symbol]]
df$Volatility = calculate_volatility(df$Return)
df$Position = lag(target_vol / df$Volatility)
df$ForecastTrend <- df$ForecastCarry <- df$ForecastCSM <- df$ForecastSkew <- df$ForecastTest <- 0
# Relative volatility (strategy 13, improvement is minimal, and we only apply it to trend)
df$M <- 1
if(relative_vol) {
df$RV <- relative_volatility(df$Volatility)
df$Q <- sapply(1:length(df$RV), function(i) sum(df$RV[i] > df$RV[1:i], na.rm=TRUE) / i)
df$M <- EMA(2 - 1.5 * df$Q, 10)
}
# Correlation with market
df$Cor <- 1
if(market_cor) {
df <- merge(df, select(BackAdj$ES, Date, Return) %>% mutate(ES=Return) %>% select(-Return), by="Date")
df$Cor <- multiple_cor(df$Return %>% na.locf(na.rm=F), df$ES %>% na.locf(na.rm=F))
df$Cor <- -df$Cor + 1
}
# Trend-following (strategy 9)
if(weights[["Trend"]]  > 0) {
df$ForecastEMA <- multiple_EMA(df$AdjClose, df$Close, df$Volatility)
df$ForecastDC <- multiple_DC(df$AdjClose, df$Close, df$Volatility)
df$ForecastKF <- multiple_KF(df$AdjClose, df$Close, df$Volatility)
df$ForecastTII <- multiple_TII(df$AdjClose, df$Close, df$Volatility)
df$ForecastTrend <- rowMeans(cbind(df$ForecastEMA, df$ForecastDC, df$ForecastKF, df$ForecastTII)) * FDMtrend * df$M * df$Cor
df$ForecastTrend <- cap_forecast(df$ForecastTrend)
}
# Carry (strategy 10)
if(weights[["Carry"]]  > 0) {
df$ForecastCarry <- multiple_Carry(df$Basis, df$Basis_distance, df$Volatility)  * FDMcarry
df$ForecastCarry <- cap_forecast(df$ForecastCarry)
}
# Cross-sectional momentum (strategy 19)
if(weights[["CSM"]]  > 0) {
df <- merge(df, filter(Asset_class_indices, Class==df$Class[1]) %>%  select(Date, A), by="Date") # Asset_class_indices obtained from before
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$ForecastCSM <- cross_sectional_momentum(df$NP, df$A) * FDMcsm
df$ForecastCSM <- cap_forecast(df$ForecastCSM)
}
# Skewness (strategy 24)
if(weights[["Skew"]]  > 0) {
df$ForecastSkew <- -returns_skew(df$Return) * FDMskew
df$ForecastSkew <- cap_forecast(df$ForecastSkew)
}
# # Kurtosis
if(weights[["Test"]]  > 0) {
#df$ForecastTest <- returns_kurtosis(df$Return) * FDMkurtosis
#forecast <- rollapply(df$Return, width=20, kurt,  fill=NA, align="right")
df$ForecastTest <- sign(multiple_EMA(df$AdjClose, df$Close, df$Volatility) )# * forecast
df$ForecastTest <- cap_forecast(df$ForecastTest)
}
# Acceleration
# if(weights[["Test"]]  > 0) {
#   df$Forecast16 <- (EMA(df$AdjClose, 16) -  EMA(df$AdjClose, 64)) / (df$Close * df$Volatility / 16) * 4.1
#   df$Forecast32 <- (EMA(df$AdjClose, 32) -  EMA(df$AdjClose, 128)) / (df$Close * df$Volatility / 16) * 2.79
#   df$Forecast64 <- (EMA(df$AdjClose, 64) -  EMA(df$AdjClose, 256)) / (df$Close * df$Volatility / 16) * 1.91
#   df$Forecast128 <- (EMA(df$AdjClose, 128) -  EMA(df$AdjClose, 512)) / (df$Close * df$Volatility / 16) * 1.50
#   df$Acc16 <- c(rep(NA, 16), diff(df$Forecast16, 16)) * 1.90
#   df$Acc32 <- c(rep(NA, 32), diff(df$Forecast32, 32)) * 1.98
#   df$Acc64 <- c(rep(NA, 64), diff(df$Forecast64, 64)) * 2.05
#   df$Acc128 <- c(rep(NA, 128), diff(df$Forecast128, 128)) * 2.10
#   df$ForecastTest <- cap_forecast(rowMeans(cbind(df$Acc16 , df$Acc32 , df$Acc64, df$Acc128)) * 1.55)
# }
# Final trade
df$Forecast <- ( weights[["Trend"]] * df$ForecastTrend +
weights[["Carry"]] * df$ForecastCarry +
weights[["CSM"]] * df$ForecastCSM +
weights[["Skew"]] * df$ForecastSkew +
weights[["Test"]] * df$ForecastTest) / 10
df$Forecast <- lag(df$Forecast)
df$Excess <- df$Return * df$Position * df$Forecast * IDM
exposures[[symbol]]  <-  mutate(df, Exposure=Position * Forecast) %>% select(Date, Exposure)
returns[[symbol]]  <-  select(df, Date, Return)
vols[[symbol]]  <-  select(df, Date, Volatility)
results[[symbol]] <- select(df, Date, Excess)
}
print("")
portfolio <- merge_portfolio_list(results)
res <- portfolio_summary(as.matrix(portfolio[,-1]), dates = portfolio$Date, plot_stats = TRUE, symbol_wise = symbol_wise  )
print(res$Aggregate %>% unlist)
if(symbol_wise) {
res$Symbols$Class <- lapply(Assets, function(x) x$Class[1]) %>% unlist
group_by(res$Symbols, Class) %>% summarise(SR_mean=mean(`Sharpe ratio`), SR_sd=sd(`Sharpe ratio`))
}
## Some figures takes from the Risk Management section
# Figure 97: Portfolio volatility, check it is in line with target volatility
# full_df_exposures <- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), exposures) %>% arrange(Date)
# full_df_returns <- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), returns) %>% arrange(Date)
# full_df_vols<- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), vols) %>% arrange(Date)
# a <- sapply(181:nrow(full_df_returns),  function(i) { w <- as.numeric(full_df_exposures[i,-1]); w[is.na(w)] <- 0; S <-  cov(full_df_returns[(i-180):i,-1], use="pairwise.complete.obs"); S[is.na(S)] <- 0; sqrt( w %*% S %*% w  )  } )
# plot.ts(a*100); abline(h=target_vol*100)
# a <- rowSums(abs(full_df_exposures[,-1] * full_df_vols[,-1]), na.rm=T)
}
# Final Backtest
{
# A subset of instrument I might actually trade
CMC_selection <- c("ZN","GG","CC","KC","HG","ZC","CT","CL","IM","GC","HE","LE","LS","NG","ZO","OJ","ZR","ZS","ES","SB","DX","ZW","D6")
Assets <- BackAdj# or BackAdj[CMC_selection]
results <- list()
exposures <- list()
returns <- list()
vols <- list()
target_vol <- 0.25
IDM = 2.5
FDMtrend <- 1.33
FDMcarry <- 1.05
FDMcsm <- 1.4
FDMskew <- 1.18
FDMkurtosis <- 1.18
# Apply relative volatility
relative_vol <- FALSE
# Apply Marker Correlation
market_cor <- TRUE
# Trend, Carry, CSM, Skew, Test
weights <- list("Trend"=0, "Carry"=0, "CSM"=0, "Skew"=1, "Test"=0)
if(sum(unlist(weights)) != 1)
warning("Strategy weights do not sum to zero")
# Symbol-wise results
symbol_wise <- TRUE
# Asset class indices
if(weights[["CSM"]] > 0) {
NPs <- list()
for(n in names(Assets)) {
df <- Assets[[n]]
df$Volatility = calculate_volatility(df$Return)
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$dNP = c(0, diff(df$NP))
NPs[[n]] <- select(df, Date, Symbol, Class, NP, dNP)
}
allNPs <- do.call(rbind, NPs)
Asset_class_indices <- group_by(allNPs, Class, Date) %>% summarise(Symbol=Symbol, R=mean(dNP)) %>%
arrange(Class, Date) %>% select(-Symbol)  %>%  unique %>% group_by( Class) %>% mutate(A=cumsum(R)) %>% ungroup()
}
# iterate over symbols
for(symbol in names(Assets)) {
cat(paste(symbol, ""))
df <- Assets[[symbol]]
df$Volatility = calculate_volatility(df$Return)
df$Position = lag(target_vol / df$Volatility)
df$ForecastTrend <- df$ForecastCarry <- df$ForecastCSM <- df$ForecastSkew <- df$ForecastTest <- 0
# Relative volatility (strategy 13, improvement is minimal, and we only apply it to trend)
df$M <- 1
if(relative_vol) {
df$RV <- relative_volatility(df$Volatility)
df$Q <- sapply(1:length(df$RV), function(i) sum(df$RV[i] > df$RV[1:i], na.rm=TRUE) / i)
df$M <- EMA(2 - 1.5 * df$Q, 10)
}
# Correlation with market
df$Cor <- 1
if(market_cor) {
df <- merge(df, select(BackAdj$ES, Date, Return) %>% mutate(ES=Return) %>% select(-Return), by="Date")
df$Cor <- multiple_cor(df$Return %>% na.locf(na.rm=F), df$ES %>% na.locf(na.rm=F))
df$Cor <- -df$Cor + 1
}
# Trend-following (strategy 9)
if(weights[["Trend"]]  > 0) {
df$ForecastEMA <- multiple_EMA(df$AdjClose, df$Close, df$Volatility)
df$ForecastDC <- multiple_DC(df$AdjClose, df$Close, df$Volatility)
df$ForecastKF <- multiple_KF(df$AdjClose, df$Close, df$Volatility)
df$ForecastTII <- multiple_TII(df$AdjClose, df$Close, df$Volatility)
df$ForecastTrend <- rowMeans(cbind(df$ForecastEMA, df$ForecastDC, df$ForecastKF, df$ForecastTII)) * FDMtrend * df$M * df$Cor
df$ForecastTrend <- cap_forecast(df$ForecastTrend)
}
# Carry (strategy 10)
if(weights[["Carry"]]  > 0) {
df$ForecastCarry <- multiple_Carry(df$Basis, df$Basis_distance, df$Volatility)  * FDMcarry
df$ForecastCarry <- cap_forecast(df$ForecastCarry)
}
# Cross-sectional momentum (strategy 19)
if(weights[["CSM"]]  > 0) {
df <- merge(df, filter(Asset_class_indices, Class==df$Class[1]) %>%  select(Date, A), by="Date") # Asset_class_indices obtained from before
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$ForecastCSM <- cross_sectional_momentum(df$NP, df$A) * FDMcsm
df$ForecastCSM <- cap_forecast(df$ForecastCSM)
}
# Skewness (strategy 24)
if(weights[["Skew"]]  > 0) {
df$ForecastSkew <- returns_skew(df$Return) * FDMskew
df$ForecastSkew <- cap_forecast(df$ForecastSkew)
}
# # Kurtosis
if(weights[["Test"]]  > 0) {
#df$ForecastTest <- returns_kurtosis(df$Return) * FDMkurtosis
#forecast <- rollapply(df$Return, width=20, kurt,  fill=NA, align="right")
df$ForecastTest <- sign(multiple_EMA(df$AdjClose, df$Close, df$Volatility) )# * forecast
df$ForecastTest <- cap_forecast(df$ForecastTest)
}
# Acceleration
# if(weights[["Test"]]  > 0) {
#   df$Forecast16 <- (EMA(df$AdjClose, 16) -  EMA(df$AdjClose, 64)) / (df$Close * df$Volatility / 16) * 4.1
#   df$Forecast32 <- (EMA(df$AdjClose, 32) -  EMA(df$AdjClose, 128)) / (df$Close * df$Volatility / 16) * 2.79
#   df$Forecast64 <- (EMA(df$AdjClose, 64) -  EMA(df$AdjClose, 256)) / (df$Close * df$Volatility / 16) * 1.91
#   df$Forecast128 <- (EMA(df$AdjClose, 128) -  EMA(df$AdjClose, 512)) / (df$Close * df$Volatility / 16) * 1.50
#   df$Acc16 <- c(rep(NA, 16), diff(df$Forecast16, 16)) * 1.90
#   df$Acc32 <- c(rep(NA, 32), diff(df$Forecast32, 32)) * 1.98
#   df$Acc64 <- c(rep(NA, 64), diff(df$Forecast64, 64)) * 2.05
#   df$Acc128 <- c(rep(NA, 128), diff(df$Forecast128, 128)) * 2.10
#   df$ForecastTest <- cap_forecast(rowMeans(cbind(df$Acc16 , df$Acc32 , df$Acc64, df$Acc128)) * 1.55)
# }
# Final trade
df$Forecast <- ( weights[["Trend"]] * df$ForecastTrend +
weights[["Carry"]] * df$ForecastCarry +
weights[["CSM"]] * df$ForecastCSM +
weights[["Skew"]] * df$ForecastSkew +
weights[["Test"]] * df$ForecastTest) / 10
df$Forecast <- lag(df$Forecast)
df$Excess <- df$Return * df$Position * df$Forecast * IDM
exposures[[symbol]]  <-  mutate(df, Exposure=Position * Forecast) %>% select(Date, Exposure)
returns[[symbol]]  <-  select(df, Date, Return)
vols[[symbol]]  <-  select(df, Date, Volatility)
results[[symbol]] <- select(df, Date, Excess)
}
print("")
portfolio <- merge_portfolio_list(results)
res <- portfolio_summary(as.matrix(portfolio[,-1]), dates = portfolio$Date, plot_stats = TRUE, symbol_wise = symbol_wise  )
print(res$Aggregate %>% unlist)
if(symbol_wise) {
res$Symbols$Class <- lapply(Assets, function(x) x$Class[1]) %>% unlist
group_by(res$Symbols, Class) %>% summarise(SR_mean=mean(`Sharpe ratio`), SR_sd=sd(`Sharpe ratio`))
}
## Some figures takes from the Risk Management section
# Figure 97: Portfolio volatility, check it is in line with target volatility
# full_df_exposures <- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), exposures) %>% arrange(Date)
# full_df_returns <- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), returns) %>% arrange(Date)
# full_df_vols<- Reduce(function(...) full_join(..., by = "Date", all = TRUE, incomparables = NA), vols) %>% arrange(Date)
# a <- sapply(181:nrow(full_df_returns),  function(i) { w <- as.numeric(full_df_exposures[i,-1]); w[is.na(w)] <- 0; S <-  cov(full_df_returns[(i-180):i,-1], use="pairwise.complete.obs"); S[is.na(S)] <- 0; sqrt( w %*% S %*% w  )  } )
# plot.ts(a*100); abline(h=target_vol*100)
# a <- rowSums(abs(full_df_exposures[,-1] * full_df_vols[,-1]), na.rm=T)
}
View(res$Symbols)
