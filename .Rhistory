hc_value <- (hc[hc_max]+hc_commission)
if(hc_value < 0)
hc_value <- 0
df$ForecastCarry <- ifelse(hc_max == 1, 1, -1) * hc_value / df$Volatility * 10
df$ForecastCarry <- cap_forecast(df$ForecastCarry * FDMcarry)
# Skewness (strategy 24)
df$ForecastSkew <- returns_skew(df$Return)
df$ForecastSkew <- cap_forecast(df$ForecastSkew * FDMskew)
# Final trade
df$Forecast <- (
strategy_weights$Trend * df$ForecastTrend +
strategy_weights$Carry * df$ForecastCarry +
strategy_weights$Skew  * df$ForecastSkew   )
df$Forecast <- cap_forecast(df$Forecast)
df$InstCapital <- capital * df$Weight * IDM
df$Exposure <- df$InstCapital * target_vol/df$Volatility
df$PositionRaw <-  (df$Exposure * df$FX * df$Forecast/10) /
(df$ContractSize * df$Close  )
{
# df$Buffer <-  df$Exposure * buffering /
#   (df$ContractSize * df$Close)
# df$BufferUp <- df$Position + df$Buffer
# df$BufferLow <- df$Position - df$Buffer
# A little simulation of position buffering, it can be removed
# df$PositionSim <- NA
# df$PositionSim[1] <- 0
# for(i in 2:nrow(df)) {
#   df$PositionSim[i] <- df$PositionSim[i-1]
#   if(is.na(df$BufferUp[i]) | is.na(df$Position[i]))
#     next
#   if(df$PositionSim[i-1] > df$BufferUp[i] | df$PositionSim[i-1] < df$BufferLow[i])
#     df$PositionSim[i] <- df$Position[i]
# }
}
# Be careful, now it is reverse-date sorted, you cannot run any other function like EMA etc..
df <- arrange(df, desc(Date))
#write_csv(df, paste0(instruments_logs, "/", symbol, ".csv"))
results[[symbol]] <- df[6,]
}
# Final table
today_trading <- do.call(rbind, results)
# Dynamic portfolio
optimal_positions <- with(today_trading, PositionRaw)
notional_exposures <- with(today_trading, ContractSize * Close / FX)
costs_per_contract <- with(today_trading, ContractSize * (Spread/2) / FX)
previous_position <- previous_trading[match(previous_trading$Symbol, today_trading$Symbol), ]$Position
position_dynamic <- dynamic_portfolio(capital, optimal_positions, notional_exposures,  cov_matrix,
previous_position = previous_position,
costs_per_contract=costs_per_contract, trade_shadow_cost = 0)
position_dynamic_rounded <- round_position(position_dynamic, today_trading$MinPosition,  today_trading$Decimals)
# Buffering
res <- buffering_portfolio(capital, position_dynamic_rounded, previous_position, notional_exposures, cov_matrix, buffering_level, target_vol)
required_trade <- res[[1]]
portfolio_tracking_error <- res[[2]]
# Final trading file
today_trading$PositionPrevious <- previous_position
today_trading$PositionDynamic <- position_dynamic
today_trading$Position <- position_dynamic_rounded
today_trading$RequiredTrade <- required_trade
portfolio_tracking_error
# iterate over data and calculate positions
results <- list()
for(symbol in names(instruments_data)) {
print(symbol)
df <- instruments_data[[symbol]][[1]]
hc <- instruments_data[[symbol]][[2]]
df$Symbol <- symbol
df$Forecast <- df$ForecastTrend <- df$ForecastCarry <- df$ForecastSkew <- df$PositionRaw <- df$PositionDynamic <- df$PositionPrevious <- df$RequiredTrade <- df$Position <- 0
df$Return <- c(0, diff(log(df$Close)))
df$Volatility = calculate_volatility(df$Return)
fx <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(FX)
if(fx == "EUR") {
df$FX <- 1
} else {
df$FX <- dplyr::filter(FX_rates, FX == fx) %>% pull(Rate)
}
df$Weight <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Weight)
df$Product <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Product)
df$ContractSize <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(ContractSize)
df$MinPosition <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(MinPosition)
df$TickSize <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(TickSize)
df$Decimals <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Decimals)
df$Spread <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Spread)
df$Commission <- dplyr::filter(instruments_info, Symbol == symbol) %>% pull(Commission)
df$CostPerTrade <- (df$Spread / 2 + df$Commission)
# Relative volatility (strategy 13, it does not seems to add much)
{
# df$M <- 1
# df$RV <- relative_volatility(df$Volatility) # quite slow, you can replace it with df$Volatility / runMean(df$Volatility, 2520))
# df$RV <- df$Volatility / runMean(df$Volatility, 252)
# df$Q <- sapply(1:length(df$RV), function(i) sum(df$RV[i] > df$RV[1:i], na.rm=TRUE) / i)
# df$M <- EMA(2 - 1.5 * df$Q, 10)
}
# Trend-following (strategy 9)
df$ForecastTrend <- rowMeans(do.call(cbind, lapply(list(multiple_EMA, multiple_DC, multiple_KF, multiple_TII), function(f) f(df$Close, df$Close, df$Volatility))))
df$ForecastTrend <- cap_forecast(df$ForecastTrend * FDMtrend)
# Carry
# It is based on cash contract interest rate, we remove the 3% commission, so low volatility assets like
# bonds are not negatively affected in this analysis. Of course low volatility assets must be played on the future contract
# if you want to obtain the carry, as interest rates of the cash are always negative (because of the 3% commission that
# is higher than the volatility itself). For high volatility assets you can choose between cash or future.
hc_max <- which.max(hc)
hc_commission <- case_when(
df$Product[1] == "Cash" ~ 0,
df$Product[1] == "Index" ~ 0.0087,
df$Product[1] == "Future" ~ 0.03,
TRUE ~ NA_real_)
hc_value <- (hc[hc_max]+hc_commission)
if(hc_value < 0)
hc_value <- 0
df$ForecastCarry <- ifelse(hc_max == 1, 1, -1) * hc_value / df$Volatility * 10
df$ForecastCarry <- cap_forecast(df$ForecastCarry * FDMcarry)
# Skewness (strategy 24)
df$ForecastSkew <- returns_skew(df$Return)
df$ForecastSkew <- cap_forecast(df$ForecastSkew * FDMskew)
# Final trade
df$Forecast <- (
strategy_weights$Trend * df$ForecastTrend +
strategy_weights$Carry * df$ForecastCarry +
strategy_weights$Skew  * df$ForecastSkew   )
df$Forecast <- cap_forecast(df$Forecast)
df$InstCapital <- capital * df$Weight * IDM
df$Exposure <- df$InstCapital * target_vol/df$Volatility
df$PositionRaw <-  (df$Exposure * df$FX * df$Forecast/10) /
(df$ContractSize * df$Close  )
{
# df$Buffer <-  df$Exposure * buffering /
#   (df$ContractSize * df$Close)
# df$BufferUp <- df$Position + df$Buffer
# df$BufferLow <- df$Position - df$Buffer
# A little simulation of position buffering, it can be removed
# df$PositionSim <- NA
# df$PositionSim[1] <- 0
# for(i in 2:nrow(df)) {
#   df$PositionSim[i] <- df$PositionSim[i-1]
#   if(is.na(df$BufferUp[i]) | is.na(df$Position[i]))
#     next
#   if(df$PositionSim[i-1] > df$BufferUp[i] | df$PositionSim[i-1] < df$BufferLow[i])
#     df$PositionSim[i] <- df$Position[i]
# }
}
# Be careful, now it is reverse-date sorted, you cannot run any other function like EMA etc..
df <- arrange(df, desc(Date))
#write_csv(df, paste0(instruments_logs, "/", symbol, ".csv"))
results[[symbol]] <- df[2,]
}
# Final Backtest
{
# A subset of instrument I might actually trade
CMC_selection <- c("ZN","GG","CC","KC","HG","ZC","CT","CL","IM","GC","HE","LE","LS","NG","ZO","OJ","ZR","ZS","ES","SB","DX","ZW","D6")
Assets <- BackAdj# or BackAdj[CMC_selection]
results <- list()
target_vol <- 0.25
IDM = 2.5
FDMtrend <- 1.33
FDMcarry <- 1.05
FDMcsm <- 1.4
FDMskew <- 1.18
FDMkurtosis <- 1.18
# Trend, Carry, CSM, Skew, Kurtosis
weights <- list("Trend"=0, "Carry"=0, "CSM"=1, "Skew"=0, "Test"=0.0)
# Apply relative volatility
relative_vol <- FALSE
if(sum(unlist(weights)) != 1)
warning("Strategy weights do not sum to zero")
# Asset class indices
if(weights[["CSM"]] > 0) {
NPs <- list()
for(n in names(Assets)) {
df <- Assets[[n]]
df$Volatility = calculate_volatility(df$Return)
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$dNP = c(0, diff(df$NP))
NPs[[n]] <- select(df, Date, Symbol, Class, NP, dNP)
}
allNPs <- do.call(rbind, NPs)
Asset_class_indices <- group_by(allNPs, Class, Date) %>% summarise(Symbol=Symbol, R=mean(dNP)) %>% arrange(Class, Date) %>% select(-Symbol)  %>%  unique %>% group_by( Class) %>% mutate(A=cumsum(R)) %>% ungroup()
}
# iterate over symbols
for(symbol in names(Assets)) {
print(symbol)
df <- Assets[[symbol]]
df$Volatility = calculate_volatility(df$Return)
df$Position = lag(target_vol / df$Volatility)
df$ForecastTrend <- df$ForecastCarry <- df$ForecastCSM <- df$ForecastSkew <- df$ForecastTest <- 0
# Relative volatility (strategy 13, improvement is minimal, and we only apply it to trend)
df$M <- 1
if(relative_vol) {
df$RV <- df$Volatility / relative_volatility(df$Volatility)
df$Q <- sapply(1:length(df$RV), function(i) sum(df$RV[i] > df$RV[1:i], na.rm=TRUE) / i)
df$M <- EMA(2 - 1.5 * df$Q, 10)
}
# Trend-following (strategy 9)
if(weights[["Trend"]]  > 0) {
df$ForecastEMA <- multiple_EMA(df$AdjClose, df$Close, df$Volatility)
df$ForecastDC <- multiple_DC(df$AdjClose, df$Close, df$Volatility)
df$ForecastKF <- multiple_KF(df$AdjClose, df$Close, df$Volatility)
df$ForecastTII <- multiple_TII(df$AdjClose, df$Close, df$Volatility)
df$ForecastTrend <- rowMeans(cbind(df$ForecastEMA, df$ForecastDC, df$ForecastKF, df$ForecastTII)) * FDMtrend * df$M
df$ForecastTrend <- cap_forecast(df$ForecastTrend)
}
# Carry (strategy 10)
if(weights[["Carry"]]  > 0) {
df$ForecastCarry <- multiple_Carry(df$Basis, df$Basis_distance, df$Volatility)  * FDMcarry
df$ForecastCarry <- cap_forecast(df$ForecastCarry)
}
# Cross-sectional momentum (strategy 19)
if(weights[["CSM"]]  > 0) {
df <- merge(df, filter(Asset_class_indices, Class==df$Class[1]) %>%  select(Date, A), by="Date") # Asset_class_indices obtained from before
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$ForecastCSM <- cross_sectional_momentum(df$NP, df$A) * FDMcsm
df$ForecastCSM <- cap_forecast(df$ForecastCSM)
}
# Skewness (strategy 24)
if(weights[["Skew"]]  > 0) {
df$ForecastSkew <- returns_skew(df$Return) * FDMskew
df$ForecastSkew <- cap_forecast(df$ForecastSkew)
}
# # Kurtosis
# if(weights[["Test"]]  > 0) {
#   df$ForecastTest <- returns_kurtosis(df$Return) * FDMkurtosis
#   df$ForecastTest <- cap_forecast(df$ForecastTest)
# }
# Acceleration
# if(weights[["Test"]]  > 0) {
#   df$Forecast16 <- (EMA(df$AdjClose, 16) -  EMA(df$AdjClose, 64)) / (df$Close * df$Volatility / 16) * 4.1
#   df$Forecast32 <- (EMA(df$AdjClose, 32) -  EMA(df$AdjClose, 128)) / (df$Close * df$Volatility / 16) * 2.79
#   df$Forecast64 <- (EMA(df$AdjClose, 64) -  EMA(df$AdjClose, 256)) / (df$Close * df$Volatility / 16) * 1.91
#   df$Forecast128 <- (EMA(df$AdjClose, 128) -  EMA(df$AdjClose, 512)) / (df$Close * df$Volatility / 16) * 1.50
#   df$Acc16 <- c(rep(NA, 16), diff(df$Forecast16, 16)) * 1.90
#   df$Acc32 <- c(rep(NA, 32), diff(df$Forecast32, 32)) * 1.98
#   df$Acc64 <- c(rep(NA, 64), diff(df$Forecast64, 64)) * 2.05
#   df$Acc128 <- c(rep(NA, 128), diff(df$Forecast128, 128)) * 2.10
#   df$ForecastTest <- cap_forecast(rowMeans(cbind(df$Acc16 , df$Acc32 , df$Acc64, df$Acc128)) * 1.55)
# }
# Final trade
df$Trade <- (  weights[["Trend"]] * df$ForecastTrend +
weights[["Carry"]] * df$ForecastCarry +
weights[["CSM"]] * df$ForecastCSM +
weights[["Skew"]] * df$ForecastSkew +
weights[["Test"]] * df$ForecastTest) / 10
df$Trade <- lag(df$Trade)
df$Excess <- df$Return * df$Position * df$Trade * IDM
results[[symbol]] <- select(df, Date, Excess)
}
portfolio <- merge_portfolio_list(results)
res <- portfolio_summary(as.matrix(portfolio[,-1]), dates = portfolio$Date, plot_stats = TRUE, symbol_wise = FALSE  )
print(res$Aggregate %>% unlist)
}
{
library(tidyverse)
library(Rfast)
library(TTR)
library(lubridate)
library(tsibble)
library(zoo)
library(moments)
library(ggthemes)
source("/home/marco/trading/Systems/Common/Indicators.R")
}
# Final Backtest
{
# A subset of instrument I might actually trade
CMC_selection <- c("ZN","GG","CC","KC","HG","ZC","CT","CL","IM","GC","HE","LE","LS","NG","ZO","OJ","ZR","ZS","ES","SB","DX","ZW","D6")
Assets <- BackAdj# or BackAdj[CMC_selection]
results <- list()
target_vol <- 0.25
IDM = 2.5
FDMtrend <- 1.33
FDMcarry <- 1.05
FDMcsm <- 1.4
FDMskew <- 1.18
FDMkurtosis <- 1.18
# Trend, Carry, CSM, Skew, Kurtosis
weights <- list("Trend"=0, "Carry"=0, "CSM"=1, "Skew"=0, "Test"=0.0)
# Apply relative volatility
relative_vol <- FALSE
if(sum(unlist(weights)) != 1)
warning("Strategy weights do not sum to zero")
# Asset class indices
if(weights[["CSM"]] > 0) {
NPs <- list()
for(n in names(Assets)) {
df <- Assets[[n]]
df$Volatility = calculate_volatility(df$Return)
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$dNP = c(0, diff(df$NP))
NPs[[n]] <- select(df, Date, Symbol, Class, NP, dNP)
}
allNPs <- do.call(rbind, NPs)
Asset_class_indices <- group_by(allNPs, Class, Date) %>% summarise(Symbol=Symbol, R=mean(dNP)) %>% arrange(Class, Date) %>% select(-Symbol)  %>%  unique %>% group_by( Class) %>% mutate(A=cumsum(R)) %>% ungroup()
}
# iterate over symbols
for(symbol in names(Assets)) {
print(symbol)
df <- Assets[[symbol]]
df$Volatility = calculate_volatility(df$Return)
df$Position = lag(target_vol / df$Volatility)
df$ForecastTrend <- df$ForecastCarry <- df$ForecastCSM <- df$ForecastSkew <- df$ForecastTest <- 0
# Relative volatility (strategy 13, improvement is minimal, and we only apply it to trend)
df$M <- 1
if(relative_vol) {
df$RV <- df$Volatility / relative_volatility(df$Volatility)
df$Q <- sapply(1:length(df$RV), function(i) sum(df$RV[i] > df$RV[1:i], na.rm=TRUE) / i)
df$M <- EMA(2 - 1.5 * df$Q, 10)
}
# Trend-following (strategy 9)
if(weights[["Trend"]]  > 0) {
df$ForecastEMA <- multiple_EMA(df$AdjClose, df$Close, df$Volatility)
df$ForecastDC <- multiple_DC(df$AdjClose, df$Close, df$Volatility)
df$ForecastKF <- multiple_KF(df$AdjClose, df$Close, df$Volatility)
df$ForecastTII <- multiple_TII(df$AdjClose, df$Close, df$Volatility)
df$ForecastTrend <- rowMeans(cbind(df$ForecastEMA, df$ForecastDC, df$ForecastKF, df$ForecastTII)) * FDMtrend * df$M
df$ForecastTrend <- cap_forecast(df$ForecastTrend)
}
# Carry (strategy 10)
if(weights[["Carry"]]  > 0) {
df$ForecastCarry <- multiple_Carry(df$Basis, df$Basis_distance, df$Volatility)  * FDMcarry
df$ForecastCarry <- cap_forecast(df$ForecastCarry)
}
# Cross-sectional momentum (strategy 19)
if(weights[["CSM"]]  > 0) {
df <- merge(df, filter(Asset_class_indices, Class==df$Class[1]) %>%  select(Date, A), by="Date") # Asset_class_indices obtained from before
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$ForecastCSM <- cross_sectional_momentum(df$NP, df$A) * FDMcsm
df$ForecastCSM <- cap_forecast(df$ForecastCSM)
}
# Skewness (strategy 24)
if(weights[["Skew"]]  > 0) {
df$ForecastSkew <- returns_skew(df$Return) * FDMskew
df$ForecastSkew <- cap_forecast(df$ForecastSkew)
}
# # Kurtosis
# if(weights[["Test"]]  > 0) {
#   df$ForecastTest <- returns_kurtosis(df$Return) * FDMkurtosis
#   df$ForecastTest <- cap_forecast(df$ForecastTest)
# }
# Acceleration
# if(weights[["Test"]]  > 0) {
#   df$Forecast16 <- (EMA(df$AdjClose, 16) -  EMA(df$AdjClose, 64)) / (df$Close * df$Volatility / 16) * 4.1
#   df$Forecast32 <- (EMA(df$AdjClose, 32) -  EMA(df$AdjClose, 128)) / (df$Close * df$Volatility / 16) * 2.79
#   df$Forecast64 <- (EMA(df$AdjClose, 64) -  EMA(df$AdjClose, 256)) / (df$Close * df$Volatility / 16) * 1.91
#   df$Forecast128 <- (EMA(df$AdjClose, 128) -  EMA(df$AdjClose, 512)) / (df$Close * df$Volatility / 16) * 1.50
#   df$Acc16 <- c(rep(NA, 16), diff(df$Forecast16, 16)) * 1.90
#   df$Acc32 <- c(rep(NA, 32), diff(df$Forecast32, 32)) * 1.98
#   df$Acc64 <- c(rep(NA, 64), diff(df$Forecast64, 64)) * 2.05
#   df$Acc128 <- c(rep(NA, 128), diff(df$Forecast128, 128)) * 2.10
#   df$ForecastTest <- cap_forecast(rowMeans(cbind(df$Acc16 , df$Acc32 , df$Acc64, df$Acc128)) * 1.55)
# }
# Final trade
df$Trade <- (  weights[["Trend"]] * df$ForecastTrend +
weights[["Carry"]] * df$ForecastCarry +
weights[["CSM"]] * df$ForecastCSM +
weights[["Skew"]] * df$ForecastSkew +
weights[["Test"]] * df$ForecastTest) / 10
df$Trade <- lag(df$Trade)
df$Excess <- df$Return * df$Position * df$Trade * IDM
results[[symbol]] <- select(df, Date, Excess)
}
portfolio <- merge_portfolio_list(results)
res <- portfolio_summary(as.matrix(portfolio[,-1]), dates = portfolio$Date, plot_stats = TRUE, symbol_wise = FALSE  )
print(res$Aggregate %>% unlist)
}
cross_sectional_momentum <- function(instrument_np, class_np, spans=c(20, 40, 80, 160, 320), scalars=c(108.5, 153.5, 217.1, 296.8, 376.3), cap=20) {
n <- length(spans)
relative_np  <- (instrument_np - class_np) / 100
Os <- lapply(1:n, function(i) EMA(c(rep(NA, spans[i]), diff(relative_np, lag=spans[i]) / spans[i]), ceiling(spans[i]/4)) * scalars[i])
Os <- lapply(1:n, function(i) ifelse(Os[[i]] > cap, cap, ifelse(Os[[i]] < -cap, -cap, Os[[i]] ) ))
forecast <- rowMeans(do.call(cbind, Os))
return(forecast)
}
# Final Backtest
{
# A subset of instrument I might actually trade
CMC_selection <- c("ZN","GG","CC","KC","HG","ZC","CT","CL","IM","GC","HE","LE","LS","NG","ZO","OJ","ZR","ZS","ES","SB","DX","ZW","D6")
Assets <- BackAdj# or BackAdj[CMC_selection]
results <- list()
target_vol <- 0.25
IDM = 2.5
FDMtrend <- 1.33
FDMcarry <- 1.05
FDMcsm <- 1.4
FDMskew <- 1.18
FDMkurtosis <- 1.18
# Trend, Carry, CSM, Skew, Kurtosis
weights <- list("Trend"=0, "Carry"=0, "CSM"=1, "Skew"=0, "Test"=0.0)
# Apply relative volatility
relative_vol <- FALSE
if(sum(unlist(weights)) != 1)
warning("Strategy weights do not sum to zero")
# Asset class indices
if(weights[["CSM"]] > 0) {
NPs <- list()
for(n in names(Assets)) {
df <- Assets[[n]]
df$Volatility = calculate_volatility(df$Return)
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$dNP = c(0, diff(df$NP))
NPs[[n]] <- select(df, Date, Symbol, Class, NP, dNP)
}
allNPs <- do.call(rbind, NPs)
Asset_class_indices <- group_by(allNPs, Class, Date) %>% summarise(Symbol=Symbol, R=mean(dNP)) %>% arrange(Class, Date) %>% select(-Symbol)  %>%  unique %>% group_by( Class) %>% mutate(A=cumsum(R)) %>% ungroup()
}
# iterate over symbols
for(symbol in names(Assets)) {
print(symbol)
df <- Assets[[symbol]]
df$Volatility = calculate_volatility(df$Return)
df$Position = lag(target_vol / df$Volatility)
df$ForecastTrend <- df$ForecastCarry <- df$ForecastCSM <- df$ForecastSkew <- df$ForecastTest <- 0
# Relative volatility (strategy 13, improvement is minimal, and we only apply it to trend)
df$M <- 1
if(relative_vol) {
df$RV <- df$Volatility / relative_volatility(df$Volatility)
df$Q <- sapply(1:length(df$RV), function(i) sum(df$RV[i] > df$RV[1:i], na.rm=TRUE) / i)
df$M <- EMA(2 - 1.5 * df$Q, 10)
}
# Trend-following (strategy 9)
if(weights[["Trend"]]  > 0) {
df$ForecastEMA <- multiple_EMA(df$AdjClose, df$Close, df$Volatility)
df$ForecastDC <- multiple_DC(df$AdjClose, df$Close, df$Volatility)
df$ForecastKF <- multiple_KF(df$AdjClose, df$Close, df$Volatility)
df$ForecastTII <- multiple_TII(df$AdjClose, df$Close, df$Volatility)
df$ForecastTrend <- rowMeans(cbind(df$ForecastEMA, df$ForecastDC, df$ForecastKF, df$ForecastTII)) * FDMtrend * df$M
df$ForecastTrend <- cap_forecast(df$ForecastTrend)
}
# Carry (strategy 10)
if(weights[["Carry"]]  > 0) {
df$ForecastCarry <- multiple_Carry(df$Basis, df$Basis_distance, df$Volatility)  * FDMcarry
df$ForecastCarry <- cap_forecast(df$ForecastCarry)
}
# Cross-sectional momentum (strategy 19)
if(weights[["CSM"]]  > 0) {
df <- merge(df, filter(Asset_class_indices, Class==df$Class[1]) %>%  select(Date, A), by="Date") # Asset_class_indices obtained from before
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$ForecastCSM <- cross_sectional_momentum(df$NP, df$A) * FDMcsm
df$ForecastCSM <- cap_forecast(df$ForecastCSM)
}
# Skewness (strategy 24)
if(weights[["Skew"]]  > 0) {
df$ForecastSkew <- returns_skew(df$Return) * FDMskew
df$ForecastSkew <- cap_forecast(df$ForecastSkew)
}
# # Kurtosis
# if(weights[["Test"]]  > 0) {
#   df$ForecastTest <- returns_kurtosis(df$Return) * FDMkurtosis
#   df$ForecastTest <- cap_forecast(df$ForecastTest)
# }
# Acceleration
# if(weights[["Test"]]  > 0) {
#   df$Forecast16 <- (EMA(df$AdjClose, 16) -  EMA(df$AdjClose, 64)) / (df$Close * df$Volatility / 16) * 4.1
#   df$Forecast32 <- (EMA(df$AdjClose, 32) -  EMA(df$AdjClose, 128)) / (df$Close * df$Volatility / 16) * 2.79
#   df$Forecast64 <- (EMA(df$AdjClose, 64) -  EMA(df$AdjClose, 256)) / (df$Close * df$Volatility / 16) * 1.91
#   df$Forecast128 <- (EMA(df$AdjClose, 128) -  EMA(df$AdjClose, 512)) / (df$Close * df$Volatility / 16) * 1.50
#   df$Acc16 <- c(rep(NA, 16), diff(df$Forecast16, 16)) * 1.90
#   df$Acc32 <- c(rep(NA, 32), diff(df$Forecast32, 32)) * 1.98
#   df$Acc64 <- c(rep(NA, 64), diff(df$Forecast64, 64)) * 2.05
#   df$Acc128 <- c(rep(NA, 128), diff(df$Forecast128, 128)) * 2.10
#   df$ForecastTest <- cap_forecast(rowMeans(cbind(df$Acc16 , df$Acc32 , df$Acc64, df$Acc128)) * 1.55)
# }
# Final trade
df$Trade <- (  weights[["Trend"]] * df$ForecastTrend +
weights[["Carry"]] * df$ForecastCarry +
weights[["CSM"]] * df$ForecastCSM +
weights[["Skew"]] * df$ForecastSkew +
weights[["Test"]] * df$ForecastTest) / 10
df$Trade <- lag(df$Trade)
df$Excess <- df$Return * df$Position * df$Trade * IDM
results[[symbol]] <- select(df, Date, Excess)
}
portfolio <- merge_portfolio_list(results)
res <- portfolio_summary(as.matrix(portfolio[,-1]), dates = portfolio$Date, plot_stats = TRUE, symbol_wise = FALSE  )
print(res$Aggregate %>% unlist)
}
allNPs %>% head
lapply(names(Assets), function(x) x$Return) %>% do.call(cbind, .) -> Returns
lapply(names(Assets), function(x) Assets[[x]]]$Return) %>% do.call(cbind, .) -> Returns
lapply(names(Assets), function(x) Assets[[x]]$Return) %>% do.call(cbind, .) -> Returns
full_df <- Reduce(function(...) full_join(..., by="Date", all=TRUE, incomparables = NA), Assets)
full_df %>% colnames()
Returns <- full_df[,grep("Date|Return", colnames(full_df))]
colnames(Returns) <- c("Date", names(Assets))
tail(Returns)
head(Returns)
Returns <- arrange(Returns, Date)
head(Returns)
tail(Returns)
full_df <- Reduce(function(...) full_join(..., by="Date", all=TRUE, incomparables = NA), Assets) %>% arrage(as.Date(Date))
full_df <- Reduce(function(...) full_join(..., by="Date", all=TRUE, incomparables = NA), Assets) %>% arrange(as.Date(Date))
Returns <- full_df[,grep("Date|Return", colnames(full_df))]
head(Returns)
Returns <- full_df[,grep("Date|Return", colnames(full_df))]
head(Returns)
colnames(Returns) <- c("Date", names(Assets))
head(Returns)
tail(Returns)
cov(Returns, use="pairwise.complete.obs") %>% corrplot::corrplot(order="hclust")
cov(Returns[,-1], use="pairwise.complete.obs") %>% corrplot::corrplot(order="hclust")
View(Returns)
cor(Returns[,-1], use="pairwise.complete.obs") %>% corrplot::corrplot(order="hclust")
graphics.off()
cor(Returns[,-1], use="pairwise.complete.obs") %>% corrplot::corrplot(order="hclust")
pca <- prcomp(Returns[,-1])
pca <- prcomp(Returns[,-1] %>% na.omit)
plot(pca)
pca
library(ggfortify)
autoplot(pca)
autoplot(pca, labels=TRUE)
autoplot(pca, label=TRUE)
pca <- prcomp(Returns[,-1] %>% na.omit %>% t)
autoplot(pca, label=TRUE)
