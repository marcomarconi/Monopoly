basis_distance <- rep(NA, nrow(m)); # months between basis contracts
spot <- rep(NA, nrow(m)); # implied spot price as defined in gorton et. al 2013
spread <- rep(NA, nrow(m)); # returns difference between current and forward contract
rollover <- rep(FALSE, nrow(m)); # rollover dates
contract <- rep(NA, nrow(m)); # current contract
maturity <- rep(NA, nrow(m)); # days to maturity
difference <- rep(NA, nrow(m)); # returns considering rollover (in log differences)
ret <- rep(NA, nrow(m)); # returns considering rollover (in price points)
first <- NA # first value to use to adjust
last <- 0 # last value to use to adjust
i <- 1
i <- 100
j <- 100
k <- ifelse(j+forward > ncol(m), ncol(m), j+forward )
k
code_j <- colnames(n)[j]
code_k <- colnames(n)[h]
code_j
colnames(n)
code_j <- colnames(m)[j]
code_k <- colnames(m)[h]
code_j
code_k
year_j <- as.numeric(substr(code_j, nchar(code_j)-1, nchar(code_j))); year_j <- ifelse(year_j > 40, year_j + 1900, year_j + 2000)
year_k <- as.numeric(substr(code_k, nchar(code_k)-1, nchar(code_k))); year_k <- ifelse(year_k > 40, year_k + 1900, year_k + 2000)
month_j <- as.numeric(substr(code_j, nchar(code_j)-2, nchar(code_j)-2));
month_k <- as.numeric(substr(code_k, nchar(code_k)-2, nchar(code_k)-2));
year_j
year_k
as.numeric(substr(code_k, nchar(code_k)-1, nchar(code_k)));
as.numeric(substr(code_j, nchar(code_j)-1, nchar(code_j)));
code_k
code_j
j
k
code_j <- colnames(m)[j]
code_k <- colnames(m)[k]
year_j <- as.numeric(substr(code_j, nchar(code_j)-1, nchar(code_j))); year_j <- ifelse(year_j > 40, year_j + 1900, year_j + 2000)
year_k <- as.numeric(substr(code_k, nchar(code_k)-1, nchar(code_k))); year_k <- ifelse(year_k > 40, year_k + 1900, year_k + 2000)
month_j <- as.numeric(substr(code_j, nchar(code_j)-2, nchar(code_j)-2));
month_k <- as.numeric(substr(code_k, nchar(code_k)-2, nchar(code_k)-2));
year_j
year_k
month_j
code_j
as.numeric(substr(code_j, nchar(code_j)-2, nchar(code_j)-2));
substr(code_j, nchar(code_j)-2, nchar(code_j)-2)
month_j <- month_code[substr(code_j, nchar(code_j)-2, nchar(code_j)-2)];
month_j
month_code
month_code <- setNames(1:12,c("f", "g", "h", "j", "k", "m", "n", "q", "u", "v", "x", "z"))
month_j <- month_code[substr(code_j, nchar(code_j)-2, nchar(code_j)-2)];
month_j
month_j %>% as.numeric()
month_j <- as.numeric(month_code[substr(code_j, nchar(code_j)-2, nchar(code_j)-2)]);
month_k <- as.numeric(month_code[substr(code_k, nchar(code_k)-2, nchar(code_k)-2)]);
yearmonth_j <- yearmonth(paste0(year_j, "-", month_j))
yearmonth_k <- yearmonth(paste0(year_k, "-", month_k))
yearmonth_j
yearmonth_k
yearmonth_k - yearmonth_j
# create a backadjusted future contract, another way
backadjust_future <- function(df, N=1, D=c(), forward=1) {
month_code <- setNames(1:12,c("f", "g", "h", "j", "k", "m", "n", "q", "u", "v", "x", "z"))
if(length(D) == 0)
D <- rep(FALSE, nrow(df))
m <- as.matrix(df[,-1]) # the first column is supposed to be the Date
d <- as.Date(df[,1]) # dates
sc <- rep(NA, ncol(m)) # contracts starts
ec <- rep(NA, ncol(m)) # contracts ends
for(j in 1:ncol(m)) {
a <- which(is.nan(m[,j]))
sc[j] <- a[1]+1
ec[j] <- a[2]-1
}
j <- 1;
i <- 1;
continous <- rep(NA, nrow(m)); # the final continous backadjusted contract
nearest <- rep(NA, nrow(m)); # the final neareast contract
basis <- rep(NA, nrow(m)); # basis as defined in gorton et. al 2013
basis_distance <- rep(NA, nrow(m)); # months between basis contracts
spot <- rep(NA, nrow(m)); # implied spot price as defined in gorton et. al 2013
spread <- rep(NA, nrow(m)); # returns difference between current and forward contract
rollover <- rep(FALSE, nrow(m)); # rollover dates
contract <- rep(NA, nrow(m)); # current contract
maturity <- rep(NA, nrow(m)); # days to maturity
difference <- rep(NA, nrow(m)); # returns considering rollover (in log differences)
ret <- rep(NA, nrow(m)); # returns considering rollover (in price points)
first <- NA # first value to use to adjust
last <- 0 # last value to use to adjust
for(i in 3:(nrow(m)-1)) { # this assume first and last entries are Inf
ret[i] <- log(m[i,j] / m[i-1,j])
difference[i] <- m[i,j] - m[i-1,j]
d_found <- D[d[i]] # we reached a user-defined rollover date
if(is.na(d_found))
d_found <- FALSE
if(j < ncol(m) && (i >= ec[j]-N+2 | d_found)) {
j <- j + 1;
rollover[i] <- TRUE
ret[i] <- log(m[i,j] / m[i-1,j])
difference[i] <- m[i,j] - m[i-1,j]
}
nearest[i] <- m[i,j]
continous[i] <- m[i,j] - m[i-1,j]
contract[i] <- colnames(m)[j]
maturity[i] <- ec[j] - i
if(j < ncol(m)) {
k <- ifelse(j+forward > ncol(m), ncol(m), j+forward )
code_j <- colnames(m)[j]
code_k <- colnames(m)[k]
year_j <- as.numeric(substr(code_j, nchar(code_j)-1, nchar(code_j))); year_j <- ifelse(year_j > 40, year_j + 1900, year_j + 2000)
year_k <- as.numeric(substr(code_k, nchar(code_k)-1, nchar(code_k))); year_k <- ifelse(year_k > 40, year_k + 1900, year_k + 2000)
month_j <- as.numeric(month_code[substr(code_j, nchar(code_j)-2, nchar(code_j)-2)]);
month_k <- as.numeric(month_code[substr(code_k, nchar(code_k)-2, nchar(code_k)-2)]);
yearmonth_j <- yearmonth(paste0(year_j, "-", month_j))
yearmonth_k <- yearmonth(paste0(year_k, "-", month_k))
#ratio <- ifelse(log, m[i,j] - m[i,k], m[i,j] / m[i,k])
#basis[i] <- period * (ratio - 1) / ((ec[k]-i) - (ec[j]-i)) # as defined in Gorton et al. 2013
basis[i] <- log(m[i,j]) - log(m[i,k]) # simple log difference between contracts
basis_distance[i] <- yearmonth_k - yearmonth_j
spread[i] <- ret[i] - ifelse(log,  (m[i,k] - m[i-1,k]),  log(m[i,k] / m[i-1,k]))
spot[i] <- ifelse(log, log(m[i,j]), m[i,j]) * (1 + basis[i] / period * (ec[j]-i)) # as defined in Gorton et al. 2013
}
if(!(is.na(m[i,j]) | is.nan(m[i,j]))) {
last <- m[i,j]
if(is.na(first))
first <- m[i,j]
}
continous[is.na(continous)] <- 0
continous <- first + cumsum(continous)
continous <- continous + (last - continous[length(continous)])
final <- data.frame(
Date=df[,1], Nearest=nearest, Backadjusted=continous, Return=ret, Difference=difference, Adjs=continous-nearest,
Contract=contract, Rollover=rollover, Maturity=maturity,
Basis=basis, Basis_distance=basis_distance, Spot=spot, Spread=spread )
delete <- c()
for(i in 1:nrow(m)) # if a row wall all NAs (probably because it just stored a Nan) in the original data, remove it from the final result
if(all(is.na(m[i,])))
delete <- c(delete, i)
if(length(delete) > 0)
final <- final[-delete,]
return(final)
}
# Backadjust the prices
BackAdj <- list()
for(symbol in names(Futures)) {
BackAdj[[symbol]] <- backadjust_future(Futures[[symbol]], N=1, forward = 1)
BackAdj[[symbol]]$Symbol <- symbol
}
backadjust_future(Futures[[symbol]], N=1, forward = 1) -> a
symbol
backadjust_future(Futures[[symbol]], N=1, forward = 1) -> a
ym <- rep(NA, ncol(m)) # contracts name in yearmonth
for(j in 1:ncol(m)) {
a <- which(is.nan(m[,j]))
sc[j] <- a[1]+1
ec[j] <- a[2]-1
code <- colnames(m)[j]
year_j <- as.numeric(substr(code_j, nchar(code_j)-1, nchar(code_j))); year_j <- ifelse(year_j > 40, year_j + 1900, year_j + 2000)
month_j <- as.numeric(month_code[substr(code_j, nchar(code_j)-2, nchar(code_j)-2)]);
ym[j] <- yearmonth(paste0(year_j, "-", month_j))
}
ym
j
code <- colnames(m)[j]
year_j <- as.numeric(substr(code_j, nchar(code_j)-1, nchar(code_j))); year_j <- ifelse(year_j > 40, year_j + 1900, year_j + 2000)
month_j <- as.numeric(month_code[substr(code_j, nchar(code_j)-2, nchar(code_j)-2)]);
code
year_j
month_j
yearmonth(paste0(year_j, "-", month_j))
ym
ym <- rep(NA, ncol(m)) # contracts name in yearmonth
for(j in 1:ncol(m)) {
a <- which(is.nan(m[,j]))
sc[j] <- a[1]+1
ec[j] <- a[2]-1
code <- colnames(m)[j]
year_j <- as.numeric(substr(code_j, nchar(code_j)-1, nchar(code_j))); year_j <- ifelse(year_j > 40, year_j + 1900, year_j + 2000)
month_j <- as.numeric(month_code[substr(code_j, nchar(code_j)-2, nchar(code_j)-2)]);
ym[j] <- yearmonth(paste0(year_j, "-", month_j))
}
ym
ym <- rep(yearmonth(), ncol(m)) # contracts name in yearmonth
ym
rep(yearmonth(), ncol(m))
rep(yearmonth(""), ncol(m))
rep(yearmonth(0), ncol(m))
ym <- rep(yearmonth(0), ncol(m)) # contracts name in yearmonth
for(j in 1:ncol(m)) {
a <- which(is.nan(m[,j]))
sc[j] <- a[1]+1
ec[j] <- a[2]-1
code <- colnames(m)[j]
year_j <- as.numeric(substr(code_j, nchar(code_j)-1, nchar(code_j))); year_j <- ifelse(year_j > 40, year_j + 1900, year_j + 2000)
month_j <- as.numeric(month_code[substr(code_j, nchar(code_j)-2, nchar(code_j)-2)]);
ym[j] <- yearmonth(paste0(year_j, "-", month_j))
}
ym
yearmonth(paste0(year_j, "-", month_j))
yearmonth(paste0(year_j, "-", month_j)) %>% class
yearmonth(paste0(year_j, "-", month_j))[1]
yearmonth(paste0(year_j, "-", month_j))[[1]]
ym <- list(rep(NA, ncol(m))) # contracts name in yearmonth
ym
yearmonth(paste0(year_j, "-", month_j))
yearmonth(paste0(year_j, "-", month_j)) %>% class
yearmonth(paste0(year_j, "-", month_j)) %>% str
yearmonth(paste0(year_j, "-", month_j)) -> a
a
class(a)
ym <- rep(NA, ncol(m)) # contracts name in yearmonth
ym
ym[5] <- a
ym
ym <- rep(yearmonth(0), ncol(m)) # contracts name in yearmonth
ym
ym[5] <- a
ym
ym <- rep(yearmonth(0), ncol(m)) # contracts name in yearmonth
for(j in 1:ncol(m)) {
a <- which(is.nan(m[,j]))
sc[j] <- a[1]+1
ec[j] <- a[2]-1
code <- colnames(m)[j]
year_j <- as.numeric(substr(code_j, nchar(code_j)-1, nchar(code_j))); year_j <- ifelse(year_j > 40, year_j + 1900, year_j + 2000)
month_j <- as.numeric(month_code[substr(code_j, nchar(code_j)-2, nchar(code_j)-2)]);
ym[j] <- yearmonth(paste0(year_j, "-", month_j))
}
ym
colnames(m)[j]
year_j <- as.numeric(substr(code_j, nchar(code_j)-1, nchar(code_j))); year_j <- ifelse(year_j > 40, year_j + 1900, year_j + 2000)
month_j <- as.numeric(month_code[substr(code_j, nchar(code_j)-2, nchar(code_j)-2)]);
yearmonth(paste0(year_j, "-", month_j))
year_j
month_j
ym <- rep(yearmonth(0), ncol(m)) # contracts name in yearmonth
for(j in 1:ncol(m)) {
a <- which(is.nan(m[,j]))
sc[j] <- a[1]+1
ec[j] <- a[2]-1
code_j <- colnames(m)[j]
year_j <- as.numeric(substr(code_j, nchar(code_j)-1, nchar(code_j))); year_j <- ifelse(year_j > 40, year_j + 1900, year_j + 2000)
month_j <- as.numeric(month_code[substr(code_j, nchar(code_j)-2, nchar(code_j)-2)]);
ym[j] <- yearmonth(paste0(year_j, "-", month_j))
}
[j]
ym
# create a backadjusted future contract, another way
backadjust_future <- function(df, N=1, D=c(), forward=1) {
month_code <- setNames(1:12,c("f", "g", "h", "j", "k", "m", "n", "q", "u", "v", "x", "z"))
if(length(D) == 0)
D <- rep(FALSE, nrow(df))
m <- as.matrix(df[,-1]) # the first column is supposed to be the Date
d <- as.Date(df[,1]) # dates
sc <- rep(NA, ncol(m)) # contracts starts
ec <- rep(NA, ncol(m)) # contracts ends
ym <- rep(yearmonth(0), ncol(m)) # contracts name in yearmonth
for(j in 1:ncol(m)) {
a <- which(is.nan(m[,j]))
sc[j] <- a[1]+1
ec[j] <- a[2]-1
code_j <- colnames(m)[j]
year_j <- as.numeric(substr(code_j, nchar(code_j)-1, nchar(code_j))); year_j <- ifelse(year_j > 40, year_j + 1900, year_j + 2000)
month_j <- as.numeric(month_code[substr(code_j, nchar(code_j)-2, nchar(code_j)-2)]);
ym[j] <- yearmonth(paste0(year_j, "-", month_j))
}
j <- 1;
i <- 1;
continous <- rep(NA, nrow(m)); # the final continous backadjusted contract
nearest <- rep(NA, nrow(m)); # the final neareast contract
basis <- rep(NA, nrow(m)); # basis as defined in gorton et. al 2013
basis_distance <- rep(NA, nrow(m)); # months between basis contracts
spot <- rep(NA, nrow(m)); # implied spot price as defined in gorton et. al 2013
spread <- rep(NA, nrow(m)); # returns difference between current and forward contract
rollover <- rep(FALSE, nrow(m)); # rollover dates
contract <- rep(NA, nrow(m)); # current contract
maturity <- rep(NA, nrow(m)); # days to maturity
difference <- rep(NA, nrow(m)); # returns considering rollover (in log differences)
ret <- rep(NA, nrow(m)); # returns considering rollover (in price points)
first <- NA # first value to use to adjust
last <- 0 # last value to use to adjust
for(i in 3:(nrow(m)-1)) { # this assume first and last entries are Inf
ret[i] <- log(m[i,j] / m[i-1,j])
difference[i] <- m[i,j] - m[i-1,j]
d_found <- D[d[i]] # we reached a user-defined rollover date
if(is.na(d_found))
d_found <- FALSE
if(j < ncol(m) && (i >= ec[j]-N+2 | d_found)) {
j <- j + 1;
rollover[i] <- TRUE
ret[i] <- log(m[i,j] / m[i-1,j])
difference[i] <- m[i,j] - m[i-1,j]
}
nearest[i] <- m[i,j]
continous[i] <- m[i,j] - m[i-1,j]
contract[i] <- colnames(m)[j]
maturity[i] <- ec[j] - i
if(j < ncol(m)) {
k <- ifelse(j+forward > ncol(m), ncol(m), j+forward )
#ratio <- ifelse(log, m[i,j] - m[i,k], m[i,j] / m[i,k])
#basis[i] <- period * (ratio - 1) / ((ec[k]-i) - (ec[j]-i)) # as defined in Gorton et al. 2013
basis[i] <- log(m[i,j]) - log(m[i,k]) # simple log difference between contracts
basis_distance[i] <- ym[k] - ym[j] # distance in months
spread[i] <- ret[i] - ifelse(log,  (m[i,k] - m[i-1,k]),  log(m[i,k] / m[i-1,k]))
spot[i] <- ifelse(log, log(m[i,j]), m[i,j]) * (1 + basis[i] / period * (ec[j]-i)) # as defined in Gorton et al. 2013
}
if(!(is.na(m[i,j]) | is.nan(m[i,j]))) {
last <- m[i,j]
if(is.na(first))
first <- m[i,j]
}
continous[is.na(continous)] <- 0
continous <- first + cumsum(continous)
continous <- continous + (last - continous[length(continous)])
final <- data.frame(
Date=df[,1], Nearest=nearest, Backadjusted=continous, Return=ret, Difference=difference, Adjs=continous-nearest,
Contract=contract, Rollover=rollover, Maturity=maturity,
Basis=basis, Basis_distance=basis_distance, Spot=spot, Spread=spread )
delete <- c()
for(i in 1:nrow(m)) # if a row wall all NAs (probably because it just stored a Nan) in the original data, remove it from the final result
if(all(is.na(m[i,])))
delete <- c(delete, i)
if(length(delete) > 0)
final <- final[-delete,]
return(final)
}
# Backadjust the prices
BackAdj <- list()
for(symbol in names(Futures)) {
BackAdj[[symbol]] <- backadjust_future(Futures[[symbol]], N=1, forward = 1)
BackAdj[[symbol]]$Symbol <- symbol
}
backadjust_future(Futures[[symbol]], N=1, forward = 1) -> a
View(a)
# create a backadjusted future contract, another way
backadjust_future <- function(df, N=1, D=c(), forward=1) {
month_code <- setNames(1:12,c("f", "g", "h", "j", "k", "m", "n", "q", "u", "v", "x", "z"))
if(length(D) == 0)
D <- rep(FALSE, nrow(df))
m <- as.matrix(df[,-1]) # the first column is supposed to be the Date
d <- as.Date(df[,1]) # dates
sc <- rep(NA, ncol(m)) # contracts starts
ec <- rep(NA, ncol(m)) # contracts ends
ym <- rep(yearmonth(0), ncol(m)) # contracts name in yearmonth
for(j in 1:ncol(m)) {
a <- which(is.nan(m[,j]))
sc[j] <- a[1]+1
ec[j] <- a[2]-1
code_j <- colnames(m)[j]
year_j <- as.numeric(substr(code_j, nchar(code_j)-1, nchar(code_j))); year_j <- ifelse(year_j > 40, year_j + 1900, year_j + 2000)
month_j <- as.numeric(month_code[substr(code_j, nchar(code_j)-2, nchar(code_j)-2)]);
ym[j] <- yearmonth(paste0(year_j, "-", month_j))
}
j <- 1;
i <- 1;
continous <- rep(NA, nrow(m)); # the final continous backadjusted contract
nearest <- rep(NA, nrow(m)); # the final neareast contract
basis <- rep(NA, nrow(m)); # basis as defined in gorton et. al 2013
basis_distance <- rep(NA, nrow(m)); # months between basis contracts
spot <- rep(NA, nrow(m)); # implied spot price as defined in gorton et. al 2013
spread <- rep(NA, nrow(m)); # returns difference between current and forward contract
rollover <- rep(FALSE, nrow(m)); # rollover dates
contract <- rep(NA, nrow(m)); # current contract
maturity <- rep(NA, nrow(m)); # days to maturity
difference <- rep(NA, nrow(m)); # returns considering rollover (in log differences)
ret <- rep(NA, nrow(m)); # returns considering rollover (in price points)
first <- NA # first value to use to adjust
last <- 0 # last value to use to adjust
for(i in 3:(nrow(m)-1)) { # this assume first and last entries are Inf
ret[i] <- log(m[i,j] / m[i-1,j])
difference[i] <- m[i,j] - m[i-1,j]
d_found <- D[d[i]] # we reached a user-defined rollover date
if(is.na(d_found))
d_found <- FALSE
if(j < ncol(m) && (i >= ec[j]-N+2 | d_found)) {
j <- j + 1;
rollover[i] <- TRUE
ret[i] <- log(m[i,j] / m[i-1,j])
difference[i] <- m[i,j] - m[i-1,j]
}
nearest[i] <- m[i,j]
continous[i] <- m[i,j] - m[i-1,j]
contract[i] <- colnames(m)[j]
maturity[i] <- ec[j] - i
if(j < ncol(m)) {
k <- ifelse(j+forward > ncol(m), ncol(m), j+forward )
#ratio <- ifelse(log, m[i,j] - m[i,k], m[i,j] / m[i,k])
#basis[i] <- period * (ratio - 1) / ((ec[k]-i) - (ec[j]-i)) # as defined in Gorton et al. 2013
basis[i] <- log(m[i,j]) - log(m[i,k]) # simple log difference between contracts
basis_distance[i] <- ym[k] - ym[j] # distance in months
spread[i] <- ret[i] - ifelse(log,  (m[i,k] - m[i-1,k]),  log(m[i,k] / m[i-1,k]))
spot[i] <- ifelse(log, log(m[i,j]), m[i,j]) * (1 + basis[i] / period * (ec[j]-i)) # as defined in Gorton et al. 2013
}
if(!(is.na(m[i,j]) | is.nan(m[i,j]))) {
last <- m[i,j]
if(is.na(first))
first <- m[i,j]
}
continous[is.na(continous)] <- 0
continous <- first + cumsum(continous)
continous <- continous + (last - continous[length(continous)])
final <- data.frame(
Date=df[,1], Nearest=nearest, Backadjusted=continous, Return=ret, Difference=difference, Adjs=continous-nearest,
Contract=contract, Rollover=rollover, Maturity=maturity,
Basis=basis, Basis_distance=basis_distance, Spot=spot, Spread=spread )
delete <- c()
for(i in 1:nrow(m)) # if a row wall all NAs (probably because it just stored a Nan) in the original data, remove it from the final result
if(all(is.na(m[i,])))
delete <- c(delete, i)
if(length(delete) > 0)
final <- final[-delete,]
return(final)
}
# Backadjust the prices
BackAdj <- list()
for(symbol in names(Futures)) {
print(symbol)
BackAdj[[symbol]] <- backadjust_future(Futures[[symbol]], N=1, forward = 1)
BackAdj[[symbol]]$Symbol <- symbol
}
# create a backadjusted future contract, another way
backadjust_future <- function(df, N=1, D=c(), forward=1) {
month_code <- setNames(1:12,c("f", "g", "h", "j", "k", "m", "n", "q", "u", "v", "x", "z"))
if(length(D) == 0)
D <- rep(FALSE, nrow(df))
m <- as.matrix(df[,-1]) # the first column is supposed to be the Date
d <- as.Date(df[,1]) # dates
sc <- rep(NA, ncol(m)) # contracts starts
ec <- rep(NA, ncol(m)) # contracts ends
ym <- rep(yearmonth(0), ncol(m)) # contracts name in yearmonth
for(j in 1:ncol(m)) {
a <- which(is.nan(m[,j]))
sc[j] <- a[1]+1
ec[j] <- a[2]-1
code_j <- colnames(m)[j]
year_j <- as.numeric(substr(code_j, nchar(code_j)-1, nchar(code_j))); year_j <- ifelse(year_j > 40, year_j + 1900, year_j + 2000)
month_j <- as.numeric(month_code[substr(code_j, nchar(code_j)-2, nchar(code_j)-2)]);
ym[j] <- yearmonth(paste0(year_j, "-", month_j))
}
j <- 1;
i <- 1;
continous <- rep(NA, nrow(m)); # the final continous backadjusted contract
nearest <- rep(NA, nrow(m)); # the final neareast contract
basis <- rep(NA, nrow(m)); # basis as defined in gorton et. al 2013
basis_distance <- rep(NA, nrow(m)); # months between basis contracts
spot <- rep(NA, nrow(m)); # implied spot price as defined in gorton et. al 2013
spread <- rep(NA, nrow(m)); # returns difference between current and forward contract
rollover <- rep(FALSE, nrow(m)); # rollover dates
contract <- rep(NA, nrow(m)); # current contract
maturity <- rep(NA, nrow(m)); # days to maturity
difference <- rep(NA, nrow(m)); # returns considering rollover (in log differences)
ret <- rep(NA, nrow(m)); # returns considering rollover (in price points)
first <- NA # first value to use to adjust
last <- 0 # last value to use to adjust
for(i in 3:(nrow(m)-1)) { # this assume first and last entries are Inf
ret[i] <- log(m[i,j] / m[i-1,j])
difference[i] <- m[i,j] - m[i-1,j]
d_found <- D[d[i]] # we reached a user-defined rollover date
if(is.na(d_found))
d_found <- FALSE
if(j < ncol(m) && (i >= ec[j]-N+2 | d_found)) {
j <- j + 1;
rollover[i] <- TRUE
ret[i] <- log(m[i,j] / m[i-1,j])
difference[i] <- m[i,j] - m[i-1,j]
}
nearest[i] <- m[i,j]
continous[i] <- m[i,j] - m[i-1,j]
contract[i] <- colnames(m)[j]
maturity[i] <- ec[j] - i
if(j < ncol(m)) {
k <- ifelse(j+forward > ncol(m), ncol(m), j+forward )
#ratio <- ifelse(log, m[i,j] - m[i,k], m[i,j] / m[i,k])
#basis[i] <- period * (ratio - 1) / ((ec[k]-i) - (ec[j]-i)) # as defined in Gorton et al. 2013
basis[i] <- log(m[i,j]) - log(m[i,k]) # simple log difference between contracts
basis_distance[i] <- ym[k] - ym[j] # distance in months
spread[i] <- ret[i] -  log(m[i,k] / m[i-1,k])
spot[i] <-  m[i,j] * (1 + basis[i] / period * (ec[j]-i)) # as defined in Gorton et al. 2013
}
if(!(is.na(m[i,j]) | is.nan(m[i,j]))) {
last <- m[i,j]
if(is.na(first))
first <- m[i,j]
}
continous[is.na(continous)] <- 0
continous <- first + cumsum(continous)
continous <- continous + (last - continous[length(continous)])
final <- data.frame(
Date=df[,1], Nearest=nearest, Backadjusted=continous, Return=ret, Difference=difference, Adjs=continous-nearest,
Contract=contract, Rollover=rollover, Maturity=maturity,
Basis=basis, Basis_distance=basis_distance, Spot=spot, Spread=spread )
delete <- c()
for(i in 1:nrow(m)) # if a row wall all NAs (probably because it just stored a Nan) in the original data, remove it from the final result
if(all(is.na(m[i,])))
delete <- c(delete, i)
if(length(delete) > 0)
final <- final[-delete,]
return(final)
}
# Backadjust the prices
BackAdj <- list()
for(symbol in names(Futures)) {
print(symbol)
BackAdj[[symbol]] <- backadjust_future(Futures[[symbol]], N=1, forward = 1)
BackAdj[[symbol]]$Symbol <- symbol
}
rm(Futures)
View(BackAdj$ZN)
View(BackAdj$GE)
View(BackAdj$AE)
View(BackAdj$RB)
