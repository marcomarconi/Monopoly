# df$RV <- relative_volatility(df$Volatility) # quite slow, you can replace it with df$Volatility / runMean(df$Volatility, 2520))
# df$RV <- df$Volatility / runMean(df$Volatility, 252)
# df$Q <- sapply(1:length(df$RV), function(i) sum(df$RV[i] > df$RV[1:i], na.rm=TRUE) / i)
# df$M <- EMA(2 - 1.5 * df$Q, 10)
# Trend-following (strategy 9)
df$ForecastEMA <- multiple_EMA(df$AdjClose, df$Close, df$Volatility)
df$ForecastDC <- multiple_DC(df$AdjClose, df$Close, df$Volatility)
df$ForecastKF <- multiple_KF(df$AdjClose, df$Close, df$Volatility)
df$ForecastTII <- multiple_TII(df$AdjClose, df$Close, df$Volatility)
df$ForecastTrend <- rowMeans(cbind(df$ForecastEMA, df$ForecastDC, df$ForecastKF, df$ForecastTII)) * FDMtrend * df$M
df$ForecastTrend <- cap_forecast(df$ForecastTrend)
# Carry (strategy 10)
df$ForecastCarry <- 0
df$ForecastCarry <- multiple_Carry(df$Basis, df$Basis_distance, df$Volatility)  * FDMcarry
df$ForecastCarry <- cap_forecast(df$ForecastCarry)
# Cross-sectional momentum (strategy 19)
df$ForecastCSM <- 0
if(weights[3]  > 0) {
df <- merge(df, filter(Asset_class_indices, Class==df$Class[1]) %>%  select(Date, A), by="Date") # Asset_class_indices obtained from before
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$ForecastCSM <- cross_sectional_momentum(df$NP, df$A) * FDMcsm
df$ForecastCSM <- cap_forecast(df$ForecastCSM)
}
# Skewness (strategy 24)
if(weights[4]  > 0) {
df$ForecastSKEW <- returns_skew(df$Return) * FDMskew
df$ForecastSKEW <- cap_forecast(df$ForecastSKEW)
}
# Final trade
df$Trade <- (weights[1] * df$ForecastTrend + weights[2] * df$ForecastCarry + weights[3] * df$ForecastCSM + weights[4] * df$ForecastSKEW) / 10
df$Trade <- lag(df$Trade)
df$Excess <- df$Return * df$Position * df$Trade * IDM
results[[symbol]] <- select(df, Date, Excess)
}
portfolio <- merge_portfolio_list(results)
res <- portfolio_summary(as.matrix(portfolio[,-1]), dates = portfolio$Date, plot_stats = TRUE, symbol_wise = FALSE  )
print(res$Aggregate %>% unlist)
}
# Final Backtest
{
# A subset of instrument I might actually trade
CMC_selection <- c("ZN","GG","CC","KC","HG","ZC","CT","CL","IM","GC","HE","LE","LS","NG","ZO","OJ","ZR","ZS","ES","SB","DX","ZW","D6")
Assets <- BackAdj[CMC_selection] # or BackAdj[CMC_selection]
results <- list()
target_vol <- 0.25
IDM = 2.5
FDMtrend <- 1.33
FDMcarry <- 1.05
FDMcsm <- 1.4
FDMskew <- 1.18
# Trend, Carry, CSM, Skew
weights <- c(0.25, 0.25, 0.25, 0.25)
# Asset class indices
if(weights[3] > 0) {
NPs <- list()
for(n in names(Assets)) {
df <- Assets[[n]]
df$Volatility = calculate_volatility(df$Return)
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$dNP = c(0, diff(df$NP))
NPs[[n]] <- select(df, Date, Symbol, Class, NP, dNP)
}
allNPs <- do.call(rbind, NPs)
Asset_class_indices <- group_by(allNPs, Class, Date) %>% summarise(Symbol=Symbol, R=mean(dNP)) %>% arrange(Class, Date) %>% select(-Symbol)  %>%  unique %>% group_by( Class) %>% mutate(A=cumsum(R)) %>% ungroup()
}
for(symbol in names(Assets)) {
print(symbol)
df <- Assets[[symbol]]
df$Volatility = calculate_volatility(df$Return)
df$Position = lag(target_vol / df$Volatility)
df$ForecastTrend <- df$ForecastCarry <- df$ForecastCSM <- df$ForecastSKEW <- 0
# Relative volatility (strategy 13, it does not seems to add much)
df$M <- 1
# df$RV <- relative_volatility(df$Volatility) # quite slow, you can replace it with df$Volatility / runMean(df$Volatility, 2520))
# df$RV <- df$Volatility / runMean(df$Volatility, 252)
# df$Q <- sapply(1:length(df$RV), function(i) sum(df$RV[i] > df$RV[1:i], na.rm=TRUE) / i)
# df$M <- EMA(2 - 1.5 * df$Q, 10)
# Trend-following (strategy 9)
df$ForecastEMA <- multiple_EMA(df$AdjClose, df$Close, df$Volatility)
df$ForecastDC <- multiple_DC(df$AdjClose, df$Close, df$Volatility)
df$ForecastKF <- multiple_KF(df$AdjClose, df$Close, df$Volatility)
df$ForecastTII <- multiple_TII(df$AdjClose, df$Close, df$Volatility)
df$ForecastTrend <- rowMeans(cbind(df$ForecastEMA, df$ForecastDC, df$ForecastKF, df$ForecastTII)) * FDMtrend * df$M
df$ForecastTrend <- cap_forecast(df$ForecastTrend)
# Carry (strategy 10)
df$ForecastCarry <- 0
df$ForecastCarry <- multiple_Carry(df$Basis, df$Basis_distance, df$Volatility)  * FDMcarry
df$ForecastCarry <- cap_forecast(df$ForecastCarry)
# Cross-sectional momentum (strategy 19)
df$ForecastCSM <- 0
if(weights[3]  > 0) {
df <- merge(df, filter(Asset_class_indices, Class==df$Class[1]) %>%  select(Date, A), by="Date") # Asset_class_indices obtained from before
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$ForecastCSM <- cross_sectional_momentum(df$NP, df$A) * FDMcsm
df$ForecastCSM <- cap_forecast(df$ForecastCSM)
}
# Skewness (strategy 24)
if(weights[4]  > 0) {
df$ForecastSKEW <- returns_skew(df$Return) * FDMskew
df$ForecastSKEW <- cap_forecast(df$ForecastSKEW)
}
# Final trade
df$Trade <- (weights[1] * df$ForecastTrend + weights[2] * df$ForecastCarry + weights[3] * df$ForecastCSM + weights[4] * df$ForecastSKEW) / 10
df$Trade <- lag(df$Trade)
df$Excess <- df$Return * df$Position * df$Trade * IDM
results[[symbol]] <- select(df, Date, Excess)
}
portfolio <- merge_portfolio_list(results)
res <- portfolio_summary(as.matrix(portfolio[,-1]), dates = portfolio$Date, plot_stats = TRUE, symbol_wise = FALSE  )
print(res$Aggregate %>% unlist)
}
# Final Backtest
{
# A subset of instrument I might actually trade
CMC_selection <- c("ZN","GG","CC","KC","HG","ZC","CT","CL","IM","GC","HE","LE","LS","NG","ZO","OJ","ZR","ZS","ES","SB","DX","ZW","D6")
Assets <- BackAdj[CMC_selection] # or BackAdj[CMC_selection]
results <- list()
target_vol <- 0.25
IDM = 2.5
FDMtrend <- 1.33
FDMcarry <- 1.05
FDMcsm <- 1.4
FDMskew <- 1.18
# Trend, Carry, CSM, Skew
weights <- c(0.4, 0.4, 0, 0.2)
# Asset class indices
if(weights[3] > 0) {
NPs <- list()
for(n in names(Assets)) {
df <- Assets[[n]]
df$Volatility = calculate_volatility(df$Return)
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$dNP = c(0, diff(df$NP))
NPs[[n]] <- select(df, Date, Symbol, Class, NP, dNP)
}
allNPs <- do.call(rbind, NPs)
Asset_class_indices <- group_by(allNPs, Class, Date) %>% summarise(Symbol=Symbol, R=mean(dNP)) %>% arrange(Class, Date) %>% select(-Symbol)  %>%  unique %>% group_by( Class) %>% mutate(A=cumsum(R)) %>% ungroup()
}
for(symbol in names(Assets)) {
print(symbol)
df <- Assets[[symbol]]
df$Volatility = calculate_volatility(df$Return)
df$Position = lag(target_vol / df$Volatility)
df$ForecastTrend <- df$ForecastCarry <- df$ForecastCSM <- df$ForecastSKEW <- 0
# Relative volatility (strategy 13, it does not seems to add much)
df$M <- 1
# df$RV <- relative_volatility(df$Volatility) # quite slow, you can replace it with df$Volatility / runMean(df$Volatility, 2520))
# df$RV <- df$Volatility / runMean(df$Volatility, 252)
# df$Q <- sapply(1:length(df$RV), function(i) sum(df$RV[i] > df$RV[1:i], na.rm=TRUE) / i)
# df$M <- EMA(2 - 1.5 * df$Q, 10)
# Trend-following (strategy 9)
df$ForecastEMA <- multiple_EMA(df$AdjClose, df$Close, df$Volatility)
df$ForecastDC <- multiple_DC(df$AdjClose, df$Close, df$Volatility)
df$ForecastKF <- multiple_KF(df$AdjClose, df$Close, df$Volatility)
df$ForecastTII <- multiple_TII(df$AdjClose, df$Close, df$Volatility)
df$ForecastTrend <- rowMeans(cbind(df$ForecastEMA, df$ForecastDC, df$ForecastKF, df$ForecastTII)) * FDMtrend * df$M
df$ForecastTrend <- cap_forecast(df$ForecastTrend)
# Carry (strategy 10)
df$ForecastCarry <- 0
df$ForecastCarry <- multiple_Carry(df$Basis, df$Basis_distance, df$Volatility)  * FDMcarry
df$ForecastCarry <- cap_forecast(df$ForecastCarry)
# Cross-sectional momentum (strategy 19)
df$ForecastCSM <- 0
if(weights[3]  > 0) {
df <- merge(df, filter(Asset_class_indices, Class==df$Class[1]) %>%  select(Date, A), by="Date") # Asset_class_indices obtained from before
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$ForecastCSM <- cross_sectional_momentum(df$NP, df$A) * FDMcsm
df$ForecastCSM <- cap_forecast(df$ForecastCSM)
}
# Skewness (strategy 24)
if(weights[4]  > 0) {
df$ForecastSKEW <- returns_skew(df$Return) * FDMskew
df$ForecastSKEW <- cap_forecast(df$ForecastSKEW)
}
# Final trade
df$Trade <- (weights[1] * df$ForecastTrend + weights[2] * df$ForecastCarry + weights[3] * df$ForecastCSM + weights[4] * df$ForecastSKEW) / 10
df$Trade <- lag(df$Trade)
df$Excess <- df$Return * df$Position * df$Trade * IDM
results[[symbol]] <- select(df, Date, Excess)
}
portfolio <- merge_portfolio_list(results)
res <- portfolio_summary(as.matrix(portfolio[,-1]), dates = portfolio$Date, plot_stats = TRUE, symbol_wise = FALSE  )
print(res$Aggregate %>% unlist)
}
# Final Backtest
{
# A subset of instrument I might actually trade
CMC_selection <- c("ZN","GG","CC","KC","HG","ZC","CT","CL","IM","GC","HE","LE","LS","NG","ZO","OJ","ZR","ZS","ES","SB","DX","ZW","D6")
Assets <- BackAdj # or BackAdj[CMC_selection]
results <- list()
target_vol <- 0.25
IDM = 2.5
FDMtrend <- 1.33
FDMcarry <- 1.05
FDMcsm <- 1.4
FDMskew <- 1.18
# Trend, Carry, CSM, Skew
weights <- c(0.4, 0.4, 0, 0.2)
# Asset class indices
if(weights[3] > 0) {
NPs <- list()
for(n in names(Assets)) {
df <- Assets[[n]]
df$Volatility = calculate_volatility(df$Return)
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$dNP = c(0, diff(df$NP))
NPs[[n]] <- select(df, Date, Symbol, Class, NP, dNP)
}
allNPs <- do.call(rbind, NPs)
Asset_class_indices <- group_by(allNPs, Class, Date) %>% summarise(Symbol=Symbol, R=mean(dNP)) %>% arrange(Class, Date) %>% select(-Symbol)  %>%  unique %>% group_by( Class) %>% mutate(A=cumsum(R)) %>% ungroup()
}
for(symbol in names(Assets)) {
print(symbol)
df <- Assets[[symbol]]
df$Volatility = calculate_volatility(df$Return)
df$Position = lag(target_vol / df$Volatility)
df$ForecastTrend <- df$ForecastCarry <- df$ForecastCSM <- df$ForecastSKEW <- 0
# Relative volatility (strategy 13, it does not seems to add much)
df$M <- 1
# df$RV <- relative_volatility(df$Volatility) # quite slow, you can replace it with df$Volatility / runMean(df$Volatility, 2520))
# df$RV <- df$Volatility / runMean(df$Volatility, 252)
# df$Q <- sapply(1:length(df$RV), function(i) sum(df$RV[i] > df$RV[1:i], na.rm=TRUE) / i)
# df$M <- EMA(2 - 1.5 * df$Q, 10)
# Trend-following (strategy 9)
df$ForecastEMA <- multiple_EMA(df$AdjClose, df$Close, df$Volatility)
df$ForecastDC <- multiple_DC(df$AdjClose, df$Close, df$Volatility)
df$ForecastKF <- multiple_KF(df$AdjClose, df$Close, df$Volatility)
df$ForecastTII <- multiple_TII(df$AdjClose, df$Close, df$Volatility)
df$ForecastTrend <- rowMeans(cbind(df$ForecastEMA, df$ForecastDC, df$ForecastKF, df$ForecastTII)) * FDMtrend * df$M
df$ForecastTrend <- cap_forecast(df$ForecastTrend)
# Carry (strategy 10)
df$ForecastCarry <- 0
df$ForecastCarry <- multiple_Carry(df$Basis, df$Basis_distance, df$Volatility)  * FDMcarry
df$ForecastCarry <- cap_forecast(df$ForecastCarry)
# Cross-sectional momentum (strategy 19)
df$ForecastCSM <- 0
if(weights[3]  > 0) {
df <- merge(df, filter(Asset_class_indices, Class==df$Class[1]) %>%  select(Date, A), by="Date") # Asset_class_indices obtained from before
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$ForecastCSM <- cross_sectional_momentum(df$NP, df$A) * FDMcsm
df$ForecastCSM <- cap_forecast(df$ForecastCSM)
}
# Skewness (strategy 24)
if(weights[4]  > 0) {
df$ForecastSKEW <- returns_skew(df$Return) * FDMskew
df$ForecastSKEW <- cap_forecast(df$ForecastSKEW)
}
# Final trade
df$Trade <- (weights[1] * df$ForecastTrend + weights[2] * df$ForecastCarry + weights[3] * df$ForecastCSM + weights[4] * df$ForecastSKEW) / 10
df$Trade <- lag(df$Trade)
df$Excess <- df$Return * df$Position * df$Trade * IDM
results[[symbol]] <- select(df, Date, Excess)
}
portfolio <- merge_portfolio_list(results)
res <- portfolio_summary(as.matrix(portfolio[,-1]), dates = portfolio$Date, plot_stats = TRUE, symbol_wise = FALSE  )
print(res$Aggregate %>% unlist)
}
CMC_selection
CMC_selection %>% length
names(BackAdj)
length(BackAdj)
View(res$Symbols)
# Final Backtest
{
# A subset of instrument I might actually trade
CMC_selection <- c("ZN","GG","CC","KC","HG","ZC","CT","CL","IM","GC","HE","LE","LS","NG","ZO","OJ","ZR","ZS","ES","SB","DX","ZW","D6")
Assets <- BackAdj # or BackAdj[CMC_selection]
results <- list()
target_vol <- 0.25
IDM = 2.5
FDMtrend <- 1.33
FDMcarry <- 1.05
FDMcsm <- 1.4
FDMskew <- 1.18
# Trend, Carry, CSM, Skew
weights <- c(0.4, 0.4, 0, 0.2)
# Asset class indices
if(weights[3] > 0) {
NPs <- list()
for(n in names(Assets)) {
df <- Assets[[n]]
df$Volatility = calculate_volatility(df$Return)
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$dNP = c(0, diff(df$NP))
NPs[[n]] <- select(df, Date, Symbol, Class, NP, dNP)
}
allNPs <- do.call(rbind, NPs)
Asset_class_indices <- group_by(allNPs, Class, Date) %>% summarise(Symbol=Symbol, R=mean(dNP)) %>% arrange(Class, Date) %>% select(-Symbol)  %>%  unique %>% group_by( Class) %>% mutate(A=cumsum(R)) %>% ungroup()
}
for(symbol in names(Assets)) {
print(symbol)
df <- Assets[[symbol]]
df$Volatility = calculate_volatility(df$Return)
df$Position = lag(target_vol / df$Volatility)
df$ForecastTrend <- df$ForecastCarry <- df$ForecastCSM <- df$ForecastSKEW <- 0
# Relative volatility (strategy 13, it does not seems to add much)
df$M <- 1
# df$RV <- relative_volatility(df$Volatility) # quite slow, you can replace it with df$Volatility / runMean(df$Volatility, 2520))
# df$RV <- df$Volatility / runMean(df$Volatility, 252)
# df$Q <- sapply(1:length(df$RV), function(i) sum(df$RV[i] > df$RV[1:i], na.rm=TRUE) / i)
# df$M <- EMA(2 - 1.5 * df$Q, 10)
# Trend-following (strategy 9)
df$ForecastEMA <- multiple_EMA(df$AdjClose, df$Close, df$Volatility)
df$ForecastDC <- multiple_DC(df$AdjClose, df$Close, df$Volatility)
df$ForecastKF <- multiple_KF(df$AdjClose, df$Close, df$Volatility)
df$ForecastTII <- multiple_TII(df$AdjClose, df$Close, df$Volatility)
df$ForecastTrend <- rowMeans(cbind(df$ForecastEMA, df$ForecastDC, df$ForecastKF, df$ForecastTII)) * FDMtrend * df$M
df$ForecastTrend <- cap_forecast(df$ForecastTrend)
# Carry (strategy 10)
df$ForecastCarry <- 0
df$ForecastCarry <- multiple_Carry(df$Basis, df$Basis_distance, df$Volatility)  * FDMcarry
df$ForecastCarry <- cap_forecast(df$ForecastCarry)
# Cross-sectional momentum (strategy 19)
df$ForecastCSM <- 0
if(weights[3]  > 0) {
df <- merge(df, filter(Asset_class_indices, Class==df$Class[1]) %>%  select(Date, A), by="Date") # Asset_class_indices obtained from before
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$ForecastCSM <- cross_sectional_momentum(df$NP, df$A) * FDMcsm
df$ForecastCSM <- cap_forecast(df$ForecastCSM)
}
# Skewness (strategy 24)
if(weights[4]  > 0) {
df$ForecastSKEW <- returns_skew(df$Return) * FDMskew
df$ForecastSKEW <- cap_forecast(df$ForecastSKEW)
}
# Final trade
df$Trade <- (weights[1] * df$ForecastTrend + weights[2] * df$ForecastCarry + weights[3] * df$ForecastCSM + weights[4] * df$ForecastSKEW) / 10
df$Trade <- lag(df$Trade)
df$Excess <- df$Return * df$Position * df$Trade * IDM
results[[symbol]] <- select(df, Date, Excess)
}
portfolio <- merge_portfolio_list(results)
res <- portfolio_summary(as.matrix(portfolio[,-1]), dates = portfolio$Date, plot_stats = TRUE, symbol_wise = TRUE  )
print(res$Aggregate %>% unlist)
}
strategy_performance <- function(returns, dates=NULL, period=252) {
# if(any(is.na(returns)))
#   stop("strategy_performance: NAs are not allowed, replace them with zeros")
if(!is.null(dates) & class(dates) != "Date")
stop(paste("strategy_performance: dates should be of class Date"))
if(class(returns) != "numeric")
stop(paste("strategy_performance: returns should be of class numeric"))
if(is.null(dates))
dates <- seq(as.Date("1970/01/01"), by = "day", length.out = length(returns))
df <- data.frame(Dates=dates, Returns=returns) %>% arrange(Dates)
annual_returns <- group_by(df, year(Dates)) %>% summarise(Dates=first(year(Dates)), Returns = sum(Returns, na.rm=TRUE)) %>% pull(Returns)
monthly_returns <- group_by(df, yearmonth(Dates)) %>% summarise(Dates=first(yearmonth(Dates)), Returns = sum(Returns, na.rm=TRUE)) %>% pull(Returns)
mean_ann_ret <- mean(annual_returns, na.rm=TRUE) * 100
ann_sd <- sd(df$Returns, na.rm=TRUE) * sqrt(period) * 100
sr <- mean(df$Returns, na.rm=TRUE) / sd(df$Returns, na.rm=TRUE) * sqrt(period)
skew <- skewness(monthly_returns, na.rm=TRUE)
q <- quantile(df$Returns[df$Returns!=0], probs=c(0.01, 0.3, 0.7, 0.99), na.rm=TRUE)
lower_tail <- as.numeric(q[1] / q[2] / 4.43)
upper_tail <- as.numeric(q[4] / q[3] / 4.43)
cum_returns = cumsum(replace(df$Returns, is.na(df$Returns), 0))
peak = cummax(cum_returns)
drawdown = peak - cum_returns
max_drawdown <- -(exp(drawdown[which.max(drawdown)])-1)*100
avg_drawdown <- -(exp(mean(drawdown))-1)*100
gpr <-  sum(df$Returns, na.rm=TRUE) / sum(abs(df$Returns[df$Returns<0]), na.rm=TRUE)
cum_annual_returns = cumsum(replace(annual_returns, is.na(annual_returns), 0))
r2 <- summary(lm(1:length(cum_annual_returns) ~ 0+cum_annual_returns))$adj.r.squared
#turnover <- round(length(rle(as.vector(na.omit(sign(returns))))$length) / period, 1)
results <- list("Mean annual return"=mean_ann_ret,
"Annualized standard deviation"=ann_sd,
"Sharpe ratio"=sr,
"Skew"=skew,
"Lower tail"=lower_tail,
"Upper tail"=upper_tail,
"Max drawdown"=max_drawdown,
"Average drawdown"=avg_drawdown,
"GPR"=gpr,
"R2"=r2
)
return(lapply(results, round, 2))
}
portfolio_summary <- function(portfolio, dates=NULL, period=252, benchmark.dates=NULL, benchmark.returns=NULL, plot_stats=FALSE, symbol_wise=FALSE) {
# if(any(is.na(portfolio)))
#   stop("portfolio_summary: NAs are not allowed, replace them with zeros")
if(!is.null(dates) & class(dates) != "Date")
stop(paste("portfolio_summary: dates should be of class Date"))
if(class(portfolio) != "matrix")
stop(paste("portfolio_summary: portfolio should be of class matrix"))
if(is.null(dates))
dates <- seq(as.Date("1970/01/01"), by = "day", length.out = length(returns))
returns <- rowMeans(portfolio, na.rm=TRUE)
results <- strategy_performance(returns, dates = dates, period=period)
SRs <- apply(portfolio, 2, function(x) mean(x, na.rm=TRUE) / sd(x, na.rm=TRUE) * sqrt(period))
results[["SR avg"]] <- round(mean(SRs), 2)
results[["SR sd"]] <- round(sd(SRs), 2)
# Benchmark comparison
alpha <- NA
beta <- NA
if(!is.null(benchmark.dates)) {
benchmark <- data.frame(Dates=benchmark.dates, Returns=benchmark.returns)
df <- data.frame(Dates=dates, Returns=returns)
z <- merge(benchmark, df, by="Dates") %>% na.omit
z <- group_by(z, yearmonth(Dates)) %>% summarise(X=sum(Returns.x, na.rm=TRUE), Y=sum(Returns.y, na.rm=TRUE))
fit <- (lm(Y ~ X, z))
alpha <- as.numeric(coef(fit)[1]) * 100 * 12
beta <- as.numeric(coef(fit)[2])
results[["alpha"]] <- round(alpha, 2)
results[["beta"]] <- round(beta, 2)
results[["correlation"]] <- round(cor(z$X, z$Y, use = "pairwise.complete.obs"), 2)
}
if(plot_stats) {
par(mfrow=c(2,1), mar=c(2,4,1,0.5))
returns <- replace(returns, is.na(returns), 0) * 100
cum_returns <- cumsum(returns)
plot(sort(as.Date(dates)), cum_returns, ylab="Equity curve %")
chunks <- group_by(data.frame(Date=as.Date(dates), ret=returns), year(Date)) %>%
summarise(sum=round(sum(ret),1), first=first(Date), .groups = 'drop')
abline(v=chunks$first, lty=2, lwd=0.5)
text(x=chunks$first+period/2, y=max(cum_returns), labels=chunks$sum, cex = 0.75)
matplot(apply(portfolio, 2, function(x) cumsum(replace(x, is.na(x), 0))  ), type = "l", lwd=2, lty=1, ylab="Assets curves %", xaxt="n")
abline(h=0, lwd=2)
axis(side = 1, labels=dates, at=seq(1, length(dates)), tick = FALSE)
}
symbol_result <- NULL
if(symbol_wise) {
symbol_result <- apply(portfolio, 2, function(x) unlist(strategy_performance(x, dates = dates))) %>% t
}
return(list(Aggregate=results, Symbols=symbol_result))
}
merge_portfolio_list <- function(portfolio_list) {
full_df <- Reduce(function(...) full_join(..., by="Date", all=TRUE, incomparables = NA), portfolio_list) %>% arrange(Date)
colnames(full_df) <- c("Date", names(portfolio_list))
#full_df[is.na(full_df)] <- 0
return(full_df)
}
# in percentages
calculate_volatility <- function(returns, long_span=252, short_span=35,  weights=c(0.3, 0.7), period=252){
vol_short <- sqrt(EMA(replace(returns, is.na(returns), 0)^2, short_span))
vol_long <- runMean(vol_short, long_span)
vol <-  (weights[1] * vol_long + weights[2] * vol_short) * sqrt(period) # one year instead of ten
return(vol)
}
cor(cbind(trend, carry, value, skew), use="pairwise.complete.obs") %>% round(.,2)
# Final Backtest
{
# A subset of instrument I might actually trade
CMC_selection <- c("ZN","GG","CC","KC","HG","ZC","CT","CL","IM","GC","HE","LE","LS","NG","ZO","OJ","ZR","ZS","ES","SB","DX","ZW","D6")
Assets <- BackAdj # or BackAdj[CMC_selection]
results <- list()
target_vol <- 0.25
IDM = 2.5
FDMtrend <- 1.33
FDMcarry <- 1.05
FDMcsm <- 1.4
FDMskew <- 1.18
# Trend, Carry, CSM, Skew
weights <- c(0.4, 0.4, 0, 0.2)
# Asset class indices
if(weights[3] > 0) {
NPs <- list()
for(n in names(Assets)) {
df <- Assets[[n]]
df$Volatility = calculate_volatility(df$Return)
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$dNP = c(0, diff(df$NP))
NPs[[n]] <- select(df, Date, Symbol, Class, NP, dNP)
}
allNPs <- do.call(rbind, NPs)
Asset_class_indices <- group_by(allNPs, Class, Date) %>% summarise(Symbol=Symbol, R=mean(dNP)) %>% arrange(Class, Date) %>% select(-Symbol)  %>%  unique %>% group_by( Class) %>% mutate(A=cumsum(R)) %>% ungroup()
}
for(symbol in names(Assets)) {
print(symbol)
df <- Assets[[symbol]]
df$Volatility = calculate_volatility(df$Return)
df$Position = lag(target_vol / df$Volatility)
df$ForecastTrend <- df$ForecastCarry <- df$ForecastCSM <- df$ForecastSKEW <- 0
# Relative volatility (strategy 13, it does not seems to add much)
df$M <- 1
# df$RV <- relative_volatility(df$Volatility) # quite slow, you can replace it with df$Volatility / runMean(df$Volatility, 2520))
# df$RV <- df$Volatility / runMean(df$Volatility, 252)
# df$Q <- sapply(1:length(df$RV), function(i) sum(df$RV[i] > df$RV[1:i], na.rm=TRUE) / i)
# df$M <- EMA(2 - 1.5 * df$Q, 10)
# Trend-following (strategy 9)
df$ForecastEMA <- multiple_EMA(df$AdjClose, df$Close, df$Volatility)
df$ForecastDC <- multiple_DC(df$AdjClose, df$Close, df$Volatility)
df$ForecastKF <- multiple_KF(df$AdjClose, df$Close, df$Volatility)
df$ForecastTII <- multiple_TII(df$AdjClose, df$Close, df$Volatility)
df$ForecastTrend <- rowMeans(cbind(df$ForecastEMA, df$ForecastDC, df$ForecastKF, df$ForecastTII)) * FDMtrend * df$M
df$ForecastTrend <- cap_forecast(df$ForecastTrend)
# Carry (strategy 10)
df$ForecastCarry <- 0
df$ForecastCarry <- multiple_Carry(df$Basis, df$Basis_distance, df$Volatility)  * FDMcarry
df$ForecastCarry <- cap_forecast(df$ForecastCarry)
# Cross-sectional momentum (strategy 19)
df$ForecastCSM <- 0
if(weights[3]  > 0) {
df <- merge(df, filter(Asset_class_indices, Class==df$Class[1]) %>%  select(Date, A), by="Date") # Asset_class_indices obtained from before
df$NP <- normalize_price(df$AdjClose, df$Close, df$Volatility)
df$ForecastCSM <- cross_sectional_momentum(df$NP, df$A) * FDMcsm
df$ForecastCSM <- cap_forecast(df$ForecastCSM)
}
# Skewness (strategy 24)
if(weights[4]  > 0) {
df$ForecastSKEW <- returns_skew(df$Return) * FDMskew
df$ForecastSKEW <- cap_forecast(df$ForecastSKEW)
}
# Final trade
df$Trade <- (weights[1] * df$ForecastTrend + weights[2] * df$ForecastCarry + weights[3] * df$ForecastCSM + weights[4] * df$ForecastSKEW) / 10
df$Trade <- lag(df$Trade)
df$Excess <- df$Return * df$Position * df$Trade * IDM
results[[symbol]] <- select(df, Date, Excess)
}
portfolio <- merge_portfolio_list(results)
res <- portfolio_summary(as.matrix(portfolio[,-1]), dates = portfolio$Date, plot_stats = TRUE, symbol_wise = TRUE  )
print(res$Aggregate %>% unlist)
}
View(res$Symbols)
